<html>
  <head>
    <title>fpl features and syntax</title>
    <style>
      .gel {
        font-weight: bold;
      }
      .optional {
        font-style: italic;
      }
    </style>
  </head>
  <body>
    <div>
      Fpl is a lex/yacc/bison alternative, born of my frustration with
      those tools and of reading about other parser generators (such
      as https://pdos.csail.mit.edu/~baford/packrat/thesis/).
      <p>A more logical excuse for fpl is that at some point jest needs
      to be rewritten in jest, and if I use existing parser generator
      languages, I'm going to be tied to c or whatever language those
      parser generators generate. So I need something which will generate
      jest (unless I want to code the parser by hand, which is possible).
    </div>
    <div>
      Key differences from other existing parser generators:
      <ul>
        <li>Scanning and parsing are not separate in fpl.  Token
        specifications (e.g. regular expressions) are done in the
        relevant gramatical rules.
        Equivalent<sup><a href="#not_really_equivalent">*</a></sup>
        tokens are folded together behind the scenes.  In practice,
        this means fewer files (and scanner/parser languages) to
        have to deal with.
        <li>In contrast to how grammars are 
        <li>Parsers generated by fpl will attempt to recognize
        the grammar they are given within the input stream they
        are given, and then halt as soon as they find 
        
      </ul>
    </div>
    <div>
      fpl gramatical elements:
      <ul>
        <li> <span class="gel">#</span> comment
        <li> <span class="gel">@</span> <a href="#directives">directive</a>
        <li> <span class="gel">+{</span><span class="optional">code</span><span class="gel">}+</span> code block
        <li> <span class="optional"></span><span class="optional">code</span><span class="gel">}+</span> code block
        <li> <span class="optional"></span><a href="#rules">production rule</a></span>
        <li> XXX sub-fpl files fill in
      </ul>
    </div>
    <div id="directives">
      <span class="subhead">Directives</span>
      <p>Valid directives are:
      <ul>
        <ul><code>@produces</code> (required) - tells the parser generator
        the type to be returned from code generation rules and from the
        generated parser itself.  See <a href=#examples">examples</a>.
      </ul>
    </div>
    <div id="rules">
      <span class="subhead">Production rules</span>
      <p>Production rules are of the form:
      <pre>
        &lt;<a href="#expressions">exprs</a> to match&gt; -&gt; &lt;production name&gt; { &lt;code&gt; }
                   or
        &lt;<a href="#exprsessions">exprs</a> to match&gt; -&gt; &lt;production name&gt; ;
      </pre>

      <div id="exprs">
        Expressions may be any of:
        <ul>
          <li> quoted string (eg <code>"xxx"</code> or <code>'yyy'</code>)
          <li> regular expression within slashes (eg /0x[0-9a-fA-F]+/)
          <li> names of other productions as plain text (no spaces)
        </ul>
        <p>The first 2 effectively specify scan tokens.  Single or double quotes
        are equivalent, and specify an exact match to look for.  Regular
        expressions can be used to specify 
        The third case specifies 
        <p> Expressions may be followed directly by (no space) one of
        *, +, or ? to mean 0-or-more, 1-or-more, or 0-or-1 respectively.
      </div>
    </div>
    <div id="examples">
      <span class="subhead">Examples:</span>
      <pre>
        #
        # https://en.wikipedia.org/wiki/Recursive_ascent_parser
        # .. actually we've now blown off recursive ascent in favor
        # of a state-function lalr approach, mainly because getting
        # the generated products to the generated code was too
        # weird in recursive ascent.  or, at least I couldn't figure
        # out a reasonable way to do it.  maybe there is a way.
        # moving on.
        #
        # Bison:
        #
        #   expr : expr '+' term   { $$ = $1 + $3; }
        #        | expr '-' term   { $$ = $1 - $3; }
        #        | term            { $$ = $1; }
        #        ;
        #
        #   term : '(' expr ')'    { $$ = $2; }
        #        | num             { $$ = $1; }
        #        ;
        #
        #   num : '0'              { $$ = 0; }
        #       | '1'              { $$ = 1; }
        #       ;
        #
        # fpl equivalent:
        # ACTUALLY adding onto the above, because the above is too limited
        # for me to care.

        @produces int

        aexpr '+' mexpr -&gt; aexpr +{ return arg_0 + arg_2; }+
        aexpr '-' mexpr -&gt; aexpr +{ return arg_0 - arg_2; }+
        mexpr           -&gt; aexpr ;

        mexpr '*' term  -&gt; mexpr +{ return arg_0 * arg_2; }+
        mexpr '/' term  -&gt; mexpr +{ return arg_0 / arg_2; }+
        mexpr '%' term  -&gt; mexpr +{ return arg_0 % arg_2; }+
        term            -&gt; mexpr ;

        '-' term        -&gt; term +{ return -arg_1; }+
        '(' aexpr ')'   -&gt; term +{ return arg_1;  }+
        /[0-9]+/        -&gt; term +{
            return std::stoi(arg_0);
        }+

      </pre>
    </div>
    <hr>
    <div id="footnotes">
      <div id="not_really_equivalent"><sup>*</sup>
        With regular expressions, you can trick fpl2cc into having
        ambiguous, "secretly" equivalent, or overlapping tokens.
        For example, it won't know that <code>/[1-3]/</code> and
        <code>/[123]/</code> are equivalent or that
        <code>/[a-z]+/</code> and <code>/[a-f]+/<code> can both
        match some of the same strings.
        In practice this mostly does not matter, but I recommend you
        keep your regexes tidy and minimal to avoid any surprises.
    </div>
  </body>
</html>
