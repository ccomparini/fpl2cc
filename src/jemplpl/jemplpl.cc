
#line 4 "src/fpl2cc/fpl_x_parser.h.jemp" 

#ifndef jemplpl_parser_H
#define jemplpl_parser_H

/*
  generated by fpl2cc v1.3 from src/fpl2cc/fpl_x_parser.h.jemp

  options:
        src_fpl: src/jemplpl/jemplpl.fpl
    src_path: /Users/chris/projects/jest2/src/grammarlib
    out: 
    output_fn: src/jemplpl/jemplpl.cc
    check_only: false
    debug: false
    debug_types: false
    debug_melds: false
    entry_points: (missing arg 0)
    embed_include_path: 
    generate_code: true
    generate_main: false
    help: false
    single_step: false
    depfile: 
    statedump: src/jemplpl/jemplpl.states
    dump_dependencies: false
    lr_stack_reserve: 1000
    param_stack_reserve: 1000
    new_parser: false


  calculated goal(s):
    { complete }

 */

//  elements:
//    _fpl_null
//    fragment
//    complete
//    text
//    '@@'
//    '@/*'
//    /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
//    '*/@'
//    /\\n\?/
//    '@parameter:'
//    /[^@]+/
//    '@'
//    '@include:'
//    leading_ws
//    /@declare\\s+/
//    identifier
//    ':'
//    /(\?:[^@]|(\?:@@))*/
//    /@realign:\\s*/
//    '#'
//    !'#'
//    template_variant
//    '@-'
//    subst_start
//    '-@'
//    trailing_ws
//    subst_end
//    /(\?:[^-@]|-[^@])+/
//    rest_of_sub
//    /\\n*[ \\t]+/
//    /[ \\t]*\\n+[ \\t]+(\?!@)/
//    /[ \\t]*\\n/
//    /#\\s*/
//    /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/
//    /[^@\\n]+/
//    /[a-zA-Z_][a-zA-Z_0-9]+/
//    /[ \\t]+/
//    sp
//    ␄_fpl_goal

//  rules:
//     fragment+:fragments -> complete
//    text+:chunks -> fragment
//    '@@':at_sign -> text
//    '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment
//    '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment
//    '@include:'^ /[^@]+/:include_file '@'^ /\\n\?/^ -> fragment
//    leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment
//    /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment
//    '#'^ !'#':variant_expression '#'^ -> template_variant
//    leading_ws?^ '@-':arg_1 -> subst_start
//    '@':arg_0 -> subst_start
//    '-@':arg_0 trailing_ws?^ -> subst_end
//    '@':arg_0 -> subst_end
//    /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub
//    /\\n*[ \\t]+/:ws -> leading_ws
//    /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws
//    /[ \\t]*\\n/:ws -> trailing_ws
//    subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment
//    subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment
//    /[^@\\n]+/:t -> text
//    leading_ws -> text
//    trailing_ws -> text
//    /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier
//    /[ \\t]+/:space -> sp
//    complete -> _fpl_goal


#line 26 "src/fpl2cc/fpl_x_parser.h.jemp" 


#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>

#include "fpl2cc/fpl_reader.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"


#line 46 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 47 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1 "src/jemplpl/jemplpl.fpl"

/*

 jemplpl - .jemp to c++ converter.

 Given one or more template files, creates corresponding c++ functions
 white return strings containing filled-in copies of said templates,
 and writes them to stdout.

 */

#include <filesystem>
#include <iostream>
#include <list>
#include <set>
#include <string>

#include "fpl2cc/fpl_reader.h"
#include "util/c_str_escape.h"
#include "util/jerror.h"
#include "util/join.h"
#include "util/searchpath.h"
#include "util/stringformat.h"
#include "util/utf8_buffer.h"

#define VERSION_MAJ 0
#define VERSION_MIN 9


#line 165 "src/jemplpl/jemplpl.cc"


#line 49 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 50 "src/fpl2cc/fpl_x_parser.h.jemp" 



#line 52 "src/fpl2cc/fpl_x_parser.h.jemp" 


class jemplpl_parser {

    public:

    #line 61 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 62 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 66 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 69 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // complete (0:1):      •fragment+:fragments                                                                                     => state 37 (src/grammarlib/jemp.fpl:12)
    // fragment (1:1):      •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (3:4):      •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 46 (src/grammarlib/jemp.fpl:24)
    // fragment (4:4):      •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 38 (src/grammarlib/jemp.fpl:35)
    // fragment (5:4):      •'@include:'^ /[^@]+/:include_file '@'^ /\\n\?/^                                                         => state 42 (src/grammarlib/jemp.fpl:40)
    // fragment (6:7):      •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 29 (src/grammarlib/jemp.fpl:46)
    // fragment (6:6):      leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:46)
    // fragment (7:4):      •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 51 (src/grammarlib/jemp.fpl:59)
    // subst_start (9:2):   •leading_ws?^ '@-':arg_1                                                                                 => state 29 (src/grammarlib/jemp.fpl:66)
    // subst_start (9:1):   leading_ws?^ •'@-':arg_1                                                                                 => state 30 (src/grammarlib/jemp.fpl:66)
    // subst_start (10:1):  •'@':arg_0                                                                                               => state 50 (src/grammarlib/jemp.fpl:67)
    // leading_ws (14:1):   •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:77)
    // trailing_ws (15:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:91)
    // trailing_ws (16:1):  •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:95)
    // fragment (17:6):     •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:103)
    // fragment (18:5):     •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:106)
    // fragment (19:3):     •subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 9  (src/grammarlib/jemp.fpl:118)
    // fragment (20:3):     •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:123)
    // text (21:1):         •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:127)
    // text (22:1):         •leading_ws                                                                                              => state 29 (src/grammarlib/jemp.fpl:131)
    // text (23:1):         •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:132)
    // _fpl_goal (26:1):    •complete                                                                                                => state 55 (src/fpl2cc/productions.h:4299)
    //
    void state_0() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__fragment(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_37);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_start(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_9);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__complete(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_55);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_5(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_46);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_9(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_38);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_12(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_42);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_14(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_18(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_51);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_22(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_50);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (23:0):  trailing_ws • => (reduce) (src/grammarlib/jemp.fpl:132)
    //
    void state_1() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__trailing_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // trailing_ws has base step num 0; canonical step is <23.0 = trailing_ws>
            ReductionParameter<std::string> arg_trailing_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_23 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_trailing_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (1:1):      •text+:chunks                   => state 2  (src/grammarlib/jemp.fpl:15)
    // fragment (1:0):      text+:chunks •                  => (reduce) (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                   => state 4  (src/grammarlib/jemp.fpl:20)
    // leading_ws (14:1):   •/\\n*[ \\t]+/:ws               => state 5  (src/grammarlib/jemp.fpl:77)
    // trailing_ws (15:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:91)
    // trailing_ws (16:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:95)
    // text (21:1):         •/[^@\\n]+/:t                   => state 6  (src/grammarlib/jemp.fpl:127)
    // text (22:1):         •leading_ws                     => state 3  (src/grammarlib/jemp.fpl:131)
    // text (23:1):         •trailing_ws                    => state 1  (src/grammarlib/jemp.fpl:132)
    //
    void state_2() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_3);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__text(
            lr_read_pos, true
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__text(
            argument_start, true
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // chunks has base step num 0; canonical step is <1.0 = text+:chunks>
            ReductionParameter<std::string> arg_chunks(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            1
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_1 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_chunks
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (22:0):  leading_ws • => (reduce) (src/grammarlib/jemp.fpl:131)
    //
    void state_3() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__leading_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // leading_ws has base step num 0; canonical step is <22.0 = leading_ws>
            ReductionParameter<std::string> arg_leading_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_22 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_leading_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (2:0):  '@@':at_sign • => (reduce) (src/grammarlib/jemp.fpl:20)
    //
    void state_4() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_4(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_4(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // at_sign has base step num 0; canonical step is <2.0 = '@@':at_sign>
            ReductionParameter<Terminal> arg_at_sign(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_2 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_at_sign
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // leading_ws (14:0):  /\\n*[ \\t]+/:ws • => (reduce) (src/grammarlib/jemp.fpl:77)
    //
    void state_5() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_29(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_29(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // ws has base step num 0; canonical step is <14.0 = /\\n*[ \\t]+/:ws>
            ReductionParameter<Terminal> arg_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_14 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _leading_ws);
            lr_push(_leading_ws, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (21:0):  /[^@\\n]+/:t • => (reduce) (src/grammarlib/jemp.fpl:127)
    //
    void state_6() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_34(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_34(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // t has base step num 0; canonical step is <21.0 = /[^@\\n]+/:t>
            ReductionParameter<Terminal> arg_t(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_21 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_t
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // trailing_ws (15:0):  /[ \\t]*\\n+[ \\t]+(\?!@)/:ws • => (reduce) (src/grammarlib/jemp.fpl:91)
    //
    void state_7() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_30(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_30(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // ws has base step num 0; canonical step is <15.0 = /[ \\t]*\\n+[ \\t]+(\?!@)/:ws>
            ReductionParameter<Terminal> arg_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_15 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _trailing_ws);
            lr_push(_trailing_ws, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // trailing_ws (16:0):  /[ \\t]*\\n/:ws • => (reduce) (src/grammarlib/jemp.fpl:95)
    //
    void state_8() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_31(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_31(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // ws has base step num 0; canonical step is <16.0 = /[ \\t]*\\n/:ws>
            ReductionParameter<Terminal> arg_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_16 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _trailing_ws);
            lr_push(_trailing_ws, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (17:5):  subst_start^ •/#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 17 (src/grammarlib/jemp.fpl:103)
    // fragment (18:4):  subst_start^ •/#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 17 (src/grammarlib/jemp.fpl:106)
    // fragment (19:2):  subst_start^ •/(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 10 (src/grammarlib/jemp.fpl:118)
    // fragment (20:2):  subst_start^ •/(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 15 (src/grammarlib/jemp.fpl:123)
    //
    void state_9() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_32(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_17);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_33(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_10);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_27(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_15);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:2):  •'-@':arg_0 trailing_ws?^                                                       => state 13 (src/grammarlib/jemp.fpl:69)
    // subst_end (12:1):  •'@':arg_0                                                                      => state 12 (src/grammarlib/jemp.fpl:70)
    // fragment (19:1):   subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement •subst_end^  => state 11 (src/grammarlib/jemp.fpl:118)
    //
    void state_10() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_11);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_24(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (19:0):  subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:118)
    //
    void state_11() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_33(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_start(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_33(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_end(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_3_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // control_statement has base step num 1; canonical step is <19.1 = /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement>
            ReductionParameter<Terminal> arg_control_statement(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_19 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_control_statement
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (12:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:70)
    //
    void state_12() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_0 has base step num 0; canonical step is <12.0 = '@':arg_0>
            ReductionParameter<Terminal> arg_arg_0(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_12 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_0
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:1):    '-@':arg_0 •trailing_ws?^       => state 14 (src/grammarlib/jemp.fpl:69)
    // subst_end (11:0):    '-@':arg_0 trailing_ws?^ •      => (reduce) (src/grammarlib/jemp.fpl:69)
    // trailing_ws (15:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:91)
    // trailing_ws (16:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:95)
    //
    void state_13() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_14);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_24(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_24(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__trailing_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_2_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_0 has base step num 0; canonical step is <11.0 = '-@':arg_0>
            ReductionParameter<Terminal> arg_arg_0(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_11 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_0
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:0):  '-@':arg_0 trailing_ws?^ • => (reduce) (src/grammarlib/jemp.fpl:69)
    //
    void state_14() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_24(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_24(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__trailing_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_2_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_0 has base step num 0; canonical step is <11.0 = '-@':arg_0>
            ReductionParameter<Terminal> arg_arg_0(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_11 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_0
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:2):  •'-@':arg_0 trailing_ws?^                              => state 13 (src/grammarlib/jemp.fpl:69)
    // subst_end (12:1):  •'@':arg_0                                             => state 12 (src/grammarlib/jemp.fpl:70)
    // fragment (20:1):   subst_start^ /(\?:[^-@]|-[^@])+/:variable •subst_end^  => state 16 (src/grammarlib/jemp.fpl:123)
    //
    void state_15() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_16);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_24(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (20:0):  subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:123)
    //
    void state_16() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_27(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_start(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_27(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_end(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_3_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // variable has base step num 1; canonical step is <20.1 = /(\?:[^-@]|-[^@])+/:variable>
            ReductionParameter<Terminal> arg_variable(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_20 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_variable
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (17:4):    subst_start^ /#\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 18 (src/grammarlib/jemp.fpl:103)
    // fragment (18:3):    subst_start^ /#\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 18 (src/grammarlib/jemp.fpl:106)
    // identifier (24:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                           => state 28 (src/grammarlib/jemp.fpl:135)
    //
    void state_17() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__identifier(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_18);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_35(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_28);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (8:3):  •'#'^ !'#':variant_expression '#'^                                                                       => state 25 (src/grammarlib/jemp.fpl:64)
    // rest_of_sub (13:1):      •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 22 (src/grammarlib/jemp.fpl:71)
    // fragment (17:3):         subst_start^ /#\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^  => state 19 (src/grammarlib/jemp.fpl:103)
    // fragment (18:2):         subst_start^ /#\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^                           => state 23 (src/grammarlib/jemp.fpl:106)
    //
    void state_18() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__template_variant(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_19);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_23);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_19(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_25);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_27(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_22);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // rest_of_sub (13:1):  •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 22 (src/grammarlib/jemp.fpl:71)
    // fragment (17:2):     subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^  => state 20 (src/grammarlib/jemp.fpl:103)
    //
    void state_19() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_20);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_27(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_22);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:2):  •'-@':arg_0 trailing_ws?^                                                                                => state 13 (src/grammarlib/jemp.fpl:69)
    // subst_end (12:1):  •'@':arg_0                                                                                               => state 12 (src/grammarlib/jemp.fpl:70)
    // fragment (17:1):   subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^  => state 21 (src/grammarlib/jemp.fpl:103)
    //
    void state_20() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_21);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_24(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (17:0):  subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:103)
    //
    void state_21() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__rest_of_sub(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__template_variant(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_32(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_start(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_32(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__identifier(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__template_variant(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__rest_of_sub(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_4_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_end(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_5_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_6_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // jempl_args has base step num 4; canonical step is <17.4 = rest_of_sub:jempl_args>
            ReductionParameter<std::string> arg_jempl_args(
            *this, step_4_start + 0,
            step_5_start - step_4_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // jempl_name has base step num 2; canonical step is <17.2 = identifier:jempl_name>
            ReductionParameter<std::string> arg_jempl_name(
            *this, step_2_start + 0,
            step_3_start - step_2_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // variant has base step num 3; canonical step is <17.3 = template_variant:variant>
            ReductionParameter<std::string> arg_variant(
            *this, step_3_start + 0,
            step_4_start - step_3_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_17 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_jempl_args
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_jempl_name
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_variant
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // rest_of_sub (13:0):  /(\?:[^-@]|-[^@])+/:arg_0 • => (reduce) (src/grammarlib/jemp.fpl:71)
    //
    void state_22() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_27(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_27(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_0 has base step num 0; canonical step is <13.0 = /(\?:[^-@]|-[^@])+/:arg_0>
            ReductionParameter<Terminal> arg_arg_0(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_13 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_0
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _rest_of_sub);
            lr_push(_rest_of_sub, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:2):  •'-@':arg_0 trailing_ws?^                                                       => state 13 (src/grammarlib/jemp.fpl:69)
    // subst_end (12:1):  •'@':arg_0                                                                      => state 12 (src/grammarlib/jemp.fpl:70)
    // fragment (18:1):   subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^  => state 24 (src/grammarlib/jemp.fpl:106)
    //
    void state_23() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_24);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_24(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (18:0):  subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:106)
    //
    void state_24() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__rest_of_sub(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_32(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_start(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_32(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__identifier(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__rest_of_sub(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__subst_end(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_4_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_5_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // jempl_args has base step num 3; canonical step is <18.3 = rest_of_sub:jempl_args>
            ReductionParameter<std::string> arg_jempl_args(
            *this, step_3_start + 0,
            step_4_start - step_3_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // jempl_name has base step num 2; canonical step is <18.2 = identifier:jempl_name>
            ReductionParameter<std::string> arg_jempl_name(
            *this, step_2_start + 0,
            step_3_start - step_2_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_18 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_jempl_args
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_jempl_name
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (8:2):  '#'^ •!'#':variant_expression '#'^  => state 26 (src/grammarlib/jemp.fpl:64)
    //
    void state_25() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT_INV__terminal_20(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_26);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (8:1):  '#'^ !'#':variant_expression •'#'^  => state 27 (src/grammarlib/jemp.fpl:64)
    //
    void state_26() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_19(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_27);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (8:0):  '#'^ !'#':variant_expression '#'^ • => (reduce) (src/grammarlib/jemp.fpl:64)
    //
    void state_27() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_19(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_20(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_19(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_19(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_20(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_19(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_3_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // variant_expression has base step num 1; canonical step is <8.1 = !'#':variant_expression>
            ReductionParameter<Terminal> arg_variant_expression(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_8 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_variant_expression
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _template_variant);
            lr_push(_template_variant, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // identifier (24:0):  /[a-zA-Z_][a-zA-Z_0-9]+/:name • => (reduce) (src/grammarlib/jemp.fpl:135)
    //
    void state_28() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_35(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_35(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // name has base step num 0; canonical step is <24.0 = /[a-zA-Z_][a-zA-Z_0-9]+/:name>
            ReductionParameter<Terminal> arg_name(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_24 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_name
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _identifier);
            lr_push(_identifier, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:6):     leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 31 (src/grammarlib/jemp.fpl:46)
    // subst_start (9:1):  leading_ws?^ •'@-':arg_1                                                                         => state 30 (src/grammarlib/jemp.fpl:66)
    // text (22:0):        leading_ws •                                                                                     => (reduce) (src/grammarlib/jemp.fpl:131)
    //
    void state_29() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_14(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_22(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__leading_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // leading_ws has base step num 0; canonical step is <22.0 = leading_ws>
            ReductionParameter<std::string> arg_leading_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_22 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_leading_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_start (9:0):  leading_ws?^ '@-':arg_1 • => (reduce) (src/grammarlib/jemp.fpl:66)
    //
    void state_30() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_22(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__leading_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_22(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_2_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_1 has base step num 1; canonical step is <9.1 = '@-':arg_1>
            ReductionParameter<Terminal> arg_arg_1(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_9 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_1
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_start);
            lr_push(_subst_start, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:5):     leading_ws? /@declare\\s+/^ •identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 32 (src/grammarlib/jemp.fpl:46)
    // identifier (24:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                   => state 28 (src/grammarlib/jemp.fpl:135)
    //
    void state_31() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__identifier(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_32);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_35(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_28);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:4):  leading_ws? /@declare\\s+/^ identifier:name_decl •':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 33 (src/grammarlib/jemp.fpl:46)
    //
    void state_32() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_16(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_33);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:3):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ •/(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 34 (src/grammarlib/jemp.fpl:46)
    //
    void state_33() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_17(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_34);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:2):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value •'@'^ /\\n\?/^  => state 35 (src/grammarlib/jemp.fpl:46)
    //
    void state_34() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_35);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:1):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ •/\\n\?/^  => state 36 (src/grammarlib/jemp.fpl:46)
    //
    void state_35() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_36);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:0):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:46)
    //
    void state_36() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_17(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_16(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_14(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__leading_ws(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_14(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__identifier(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_16(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_17(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_4_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_5_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_8(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_6_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_7_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // leading_ws has base step num 0; canonical step is <6.0 = leading_ws?>
            ReductionParameter<std::string> arg_leading_ws(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // name_decl has base step num 2; canonical step is <6.2 = identifier:name_decl>
            ReductionParameter<std::string> arg_name_decl(
            *this, step_2_start + 0,
            step_3_start - step_2_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // value has base step num 4; canonical step is <6.4 = /(\?:[^@]|(\?:@@))*/:value>
            ReductionParameter<Terminal> arg_value(
            *this, step_4_start + 0,
            step_5_start - step_4_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_6 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_leading_ws
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_name_decl
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_value
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // complete (0:1):      •fragment+:fragments                                                                                     => state 37 (src/grammarlib/jemp.fpl:12)
    // complete (0:0):      fragment+:fragments •                                                                                    => (reduce) (src/grammarlib/jemp.fpl:12)
    // fragment (1:1):      •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (3:4):      •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 46 (src/grammarlib/jemp.fpl:24)
    // fragment (4:4):      •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 38 (src/grammarlib/jemp.fpl:35)
    // fragment (5:4):      •'@include:'^ /[^@]+/:include_file '@'^ /\\n\?/^                                                         => state 42 (src/grammarlib/jemp.fpl:40)
    // fragment (6:7):      •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 29 (src/grammarlib/jemp.fpl:46)
    // fragment (6:6):      leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:46)
    // fragment (7:4):      •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 51 (src/grammarlib/jemp.fpl:59)
    // subst_start (9:2):   •leading_ws?^ '@-':arg_1                                                                                 => state 29 (src/grammarlib/jemp.fpl:66)
    // subst_start (9:1):   leading_ws?^ •'@-':arg_1                                                                                 => state 30 (src/grammarlib/jemp.fpl:66)
    // subst_start (10:1):  •'@':arg_0                                                                                               => state 50 (src/grammarlib/jemp.fpl:67)
    // leading_ws (14:1):   •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:77)
    // trailing_ws (15:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:91)
    // trailing_ws (16:1):  •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:95)
    // fragment (17:6):     •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:103)
    // fragment (18:5):     •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:106)
    // fragment (19:3):     •subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 9  (src/grammarlib/jemp.fpl:118)
    // fragment (20:3):     •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:123)
    // text (21:1):         •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:127)
    // text (22:1):         •leading_ws                                                                                              => state 29 (src/grammarlib/jemp.fpl:131)
    // text (23:1):         •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:132)
    //
    void state_37() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__fragment(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_37);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_start(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_9);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_5(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_46);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_9(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_38);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_12(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_42);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_14(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_18(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_51);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_22(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_50);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__fragment(
            lr_read_pos, true
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__fragment(
            argument_start, true
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // fragments has base step num 0; canonical step is <0.0 = fragment+:fragments>
            ReductionParameter<std::string> arg_fragments(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            1
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_0 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_fragments
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _complete);
            lr_push(_complete, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:3):  '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\n\?/^  => state 39 (src/grammarlib/jemp.fpl:35)
    //
    void state_38() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_10(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_39);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:2):  '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\n\?/^  => state 40 (src/grammarlib/jemp.fpl:35)
    //
    void state_39() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_40);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:1):  '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\n\?/^  => state 41 (src/grammarlib/jemp.fpl:35)
    //
    void state_40() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_41);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:0):  '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:35)
    //
    void state_41() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_10(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_9(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_9(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_10(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_8(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_4_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // param_decl has base step num 1; canonical step is <4.1 = /[^@]+/:param_decl>
            ReductionParameter<Terminal> arg_param_decl(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_4 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_param_decl
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:3):  '@include:'^ •/[^@]+/:include_file '@'^ /\\n\?/^  => state 43 (src/grammarlib/jemp.fpl:40)
    //
    void state_42() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_10(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_43);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:2):  '@include:'^ /[^@]+/:include_file •'@'^ /\\n\?/^  => state 44 (src/grammarlib/jemp.fpl:40)
    //
    void state_43() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_44);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:1):  '@include:'^ /[^@]+/:include_file '@'^ •/\\n\?/^  => state 45 (src/grammarlib/jemp.fpl:40)
    //
    void state_44() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_45);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:0):  '@include:'^ /[^@]+/:include_file '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:40)
    //
    void state_45() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_10(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_12(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_12(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_10(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_8(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_4_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // include_file has base step num 1; canonical step is <5.1 = /[^@]+/:include_file>
            ReductionParameter<Terminal> arg_include_file(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_5 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_include_file
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:3):  '@/*'^ •/(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^  => state 47 (src/grammarlib/jemp.fpl:24)
    //
    void state_46() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_6(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_47);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:2):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment •'*/@'^ /\\n\?/^  => state 48 (src/grammarlib/jemp.fpl:24)
    //
    void state_47() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_7(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_48);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:1):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ •/\\n\?/^  => state 49 (src/grammarlib/jemp.fpl:24)
    //
    void state_48() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_49);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:0):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:24)
    //
    void state_49() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_7(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_6(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_5(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_5(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_6(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_7(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_8(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_4_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // comment has base step num 1; canonical step is <3.1 = /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment>
            ReductionParameter<Terminal> arg_comment(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_3 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_comment
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_start (10:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:67)
    //
    void state_50() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_1_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // arg_0 has base step num 0; canonical step is <10.0 = '@':arg_0>
            ReductionParameter<Terminal> arg_arg_0(
            *this, step_0_start + 0,
            step_1_start - step_0_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_10 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_arg_0
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_start);
            lr_push(_subst_start, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (2:1):          •'@@':at_sign                                 => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (7:3):      /@realign:\\s*/^ •text:realign '@'^ /\\n\?/^  => state 52 (src/grammarlib/jemp.fpl:59)
    // leading_ws (14:1):   •/\\n*[ \\t]+/:ws                             => state 5  (src/grammarlib/jemp.fpl:77)
    // trailing_ws (15:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                => state 7  (src/grammarlib/jemp.fpl:91)
    // trailing_ws (16:1):  •/[ \\t]*\\n/:ws                              => state 8  (src/grammarlib/jemp.fpl:95)
    // text (21:1):         •/[^@\\n]+/:t                                 => state 6  (src/grammarlib/jemp.fpl:127)
    // text (22:1):         •leading_ws                                   => state 3  (src/grammarlib/jemp.fpl:131)
    // text (23:1):         •trailing_ws                                  => state 1  (src/grammarlib/jemp.fpl:132)
    //
    void state_51() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_52);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_3);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (7:2):  /@realign:\\s*/^ text:realign •'@'^ /\\n\?/^  => state 53 (src/grammarlib/jemp.fpl:59)
    //
    void state_52() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_53);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (7:1):  /@realign:\\s*/^ text:realign '@'^ •/\\n\?/^  => state 54 (src/grammarlib/jemp.fpl:59)
    //
    void state_53() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_54);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (7:0):  /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:59)
    //
    void state_54() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();


            #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__text(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_18(
            lr_read_pos, false
            );

            #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int argument_start = lr_read_pos;

            // the step size is in lr_stack units, and may be different from the
            // argument size because some (melded) arguments span multiple steps:
            int step_size;


            #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_18(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_0_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__text(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_1_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_11(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_2_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            step_size = lr_stack_size_of__terminal_8(
            argument_start, false
            );


            #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            int step_3_start = argument_start;

            argument_start += step_size;

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // and this just makes it easier to find the end of the last step:
            int step_4_start = argument_start;


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // realign has base step num 1; canonical step is <7.1 = text:realign>
            ReductionParameter<std::string> arg_realign(
            *this, step_1_start + 0,
            step_2_start - step_1_start,
            0
            );


            #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_7 (

            #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_realign
            #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );

            Product prod(result);

            #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // _fpl_goal (26:0):  complete • => (done) (src/fpl2cc/productions.h:4299)
    //
    void state_55() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 49 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            // matched a goal:
            terminate();

            #line 58 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 71 "src/fpl2cc/fpl_x_parser.h.jemp" 


    private:

    // If some poor hapless fpl author should happen to try
    // to use a non-copy-constructable type in some way that
    // it lands in the variant (below), they will be rewarded
    // by their c++ compiler with about 23k lines of "note:"
    // gibberish about every possible constructor in the
    // standard libraries.  To avoid this, and to give a non-0
    // chance at a useful error message, we do this lame hack
    // of creating a static function whose only reason for
    // existence is to give a scope to static_asserts:
    static void check_copy() {

        #line 85 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {

            #line 87 "src/fpl2cc/fpl_x_parser.h.jemp" 
            const bool copyable = std::is_copy_constructible<Terminal>::value;
            static_assert(copyable, "Terminal is not copy constructable");
        }

        #line 94 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {

            #line 87 "src/fpl2cc/fpl_x_parser.h.jemp" 
            const bool copyable = std::is_copy_constructible<std::string>::value;
            static_assert(copyable, "std::string is not copy constructable");
        }

        #line 94 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    public:
    using State = decltype(&jemplpl_parser::state_0);

    class Terminal {
        // the first string in "matches" is the entire terminal match
        // and will exist for exact matches as well as regex matches.
        // subsequent matches are used for capture groups in a regex
        // match.
        std::vector<std::string> matches;
        public:

        Terminal() { } // false valued terminal

        Terminal(const std::string &src) {
            matches.push_back(src);
        }

        // this prevents stuff like Terminal("foo") from matching
        // the Iterable one, below
        Terminal(const char *src) {
            matches.push_back(std::string(src));
        }

        // this is so that bool "just works" in return values from
        // custom scanners
        Terminal(bool matched) {
            if(matched) matches.push_back("");
        }

        template<typename Iter>
        Terminal(Iter begin, Iter end) : matches(begin, end) {
        }

        template<typename Iterable>
        Terminal(const Iterable &src) : matches(src.begin(), src.end()) {
        }

        std::string to_str() const {
            if(matches.size())
            return matches[0];
            return "";
        }

        // returns the length of the terminal match, in bytes
        size_t length() const {
            if(matches.size())
            return matches[0].size();
            return 0;
        }

        // returns a string containing the contents of the regex capture
        // group indicated by the index passed.
        // for example, if the regex /(.)y(.*)/ matched the string "dyad",
        // capgroup(0) would be "d" and capgroup(1) would be "ad".
        // default is the 0th capgroup.
        // returns the empty string for any non-existent capture groups.
        std::string capgroup(int capi = 0) const {
            if(capi + 1 < matches.size()) {
                return matches[capi + 1];
            }
            return "";
        }

        int num_capgroups() const {
            return matches.size() - 1;
        }

        operator bool() const {
            return matches.size() > 0;
        }

        operator std::string() const { return to_str(); }

        std::string operator+(const std::string & rhs) const {
            return to_str() + rhs;
        }

        friend bool operator==(const Terminal &lhs, const char *rhs) {
            return lhs.to_str() == rhs;
        }

        friend bool operator==(const char *lhs, const Terminal &rhs) {
            return lhs == rhs.to_str();
        }

    };


    #line 2 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"


    #line 4 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"




    class Product {
        struct false_product { };

        // this is the "product" we make everything produce for
        // the --check-only option.  It can be constructed from
        // anything, so that it can drop into any arbitrary rule.
        struct check_only {
            operator bool() const { return true; }
            std::string to_str() const {
                return "«dummy»";
            }

            // (construct from any set of arguments)
            template <typename... Args>
            check_only(Args&&... args) { }
        };

        // different fpl rules may or may not evaluate to different
        // types, so we use a std::variant:
        using Var = std::variant<
        false_product,
        Terminal,
        std::string
        >;

        Var red;

        public:
        // creates a false-valued Product:
        Product() : red(false_product()) { }

        // type-specific constructors:

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Product(Terminal result) : red(result) { }

        #line 219 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Product(std::string result) : red(result) { }

        #line 219 "src/fpl2cc/fpl_x_parser.h.jemp" 
        const Var &var() const { return red; }

        // Accessors for the different types are named as [element name]_val()
        // We start at type 1 instead of 0 because we don't need/want an
        // fpl_null accessor (it has no type anyway)

        #line 226 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _fragment_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _complete_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _text_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_4_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_5_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_6_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_7_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_8_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_9_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_10_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_11_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_12_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _leading_ws_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_14_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _identifier_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_16_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_17_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_18_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_19_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_20_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _template_variant_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_22_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _subst_start_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_24_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _trailing_ws_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _subst_end_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_27_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _rest_of_sub_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_29_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_30_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_31_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_32_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_33_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_34_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_35_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_36_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _sp_val() const { return std::get<std::string>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_38_val() const { return std::get<Terminal>(var()); }

        #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
        operator bool() const {
            return !std::holds_alternative<false_product>(red);
        }

        std::string type_name() const {
            if(std::holds_alternative<false_product>(red))
            return "<no type>";

            if(std::holds_alternative<Terminal>(red))
            return "Terminal";


            #line 244 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<Terminal>(red))
            return "Terminal";

            #line 247 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<std::string>(red))
            return "std::string";

            #line 247 "src/fpl2cc/fpl_x_parser.h.jemp" 
            // can't get here?
            jerror::error("Unknown type for product");
            return "unknown type";
        }

        std::string var_str() const {
            if(std::holds_alternative<false_product>(red))
            return "<null product>";

            if(std::holds_alternative<Terminal>(var()))
            return stringformat("{}", std::get<Terminal>(var()));


            #line 260 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<Terminal>(var())) {

                #line 262 "src/fpl2cc/fpl_x_parser.h.jemp" 
                return stringformat("{}", std::get<Terminal>(var()));
            }

            #line 266 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<std::string>(var())) {

                #line 262 "src/fpl2cc/fpl_x_parser.h.jemp" 
                return stringformat("{}", std::get<std::string>(var()));
            }

            #line 266 "src/fpl2cc/fpl_x_parser.h.jemp" 


            jerror::error("Unknown type for product");
            return "unknown type";
        }

        // this is for debug and similar:
        std::string to_str() const {
            std::string out;
            return stringformat("{} «{}»", type_name(), var_str());
        }

        // phase out if possible, because this only supports the
        // top output_type() and that's wacky.
        std::string val(const std::string &caller = CALLER()) const {
            if(!std::holds_alternative<std::string>(red)) {
                std::string dummy;
                return dummy;
            }
            return std::get<std::string>(red);
        }

        // if it's a (regex) terminal with capture groups, this returns
        // the contents of the nth capgroup.  otherwise, returns an
        // empty string.
        std::string capgroup(int capi) const {
            if(std::holds_alternative<Terminal>(red))
            return std::get<Terminal>(red).capgroup(capi);
            return "";
        }
    };

    // This is an lr stack entry (as opposed to a param stack entry).
    // In the new dual stack scheme, you would use one of these to
    // refer to the param stack, however.
    struct StackEntry {
        State          state;
        int            element_id;
        SourcePosition pos;        // start of match in source code
        int            param_ind;  // offset in param_stack
        bool           eject;
        bool           mismatch;

        StackEntry(State st, int el_id, SourcePosition p, int pind, bool ej) :
        state(st),
        element_id(el_id),
        pos(p),
        param_ind(pind),
        eject(ej),
        mismatch(false) {
        }

        // creates a "false" stack entry:
        StackEntry() :
        state(NULL),
        element_id(-1),
        param_ind(-1),
        eject(true),
        mismatch(false) {
        }

        StackEntry(const StackEntry &) = default;

        operator bool() const {
            return element_id > 0; // (null/invalid element id -> false)
        }

        int grammar_element_id() const {
            return element_id;
        }

        bool ejected() const {
            return eject;
        }

        SourcePosition position() const {
            return pos;
        }

        int line_number() const {
            return position().line_number();
        }

        std::string filename() const {
            return position().filename();
        }

        bool is_nonterminal() const {
            return jemplpl_parser::is_nonterminal(element_id);
        }

        // Returns the first Product corresponding to this
        // StackEntry, if there is one.  Otherwise, returns
        // a false Product.
        Product product(const jemplpl_parser &owner) const {
            if(param_ind >= 0 && param_ind < owner.param_stack.size()) {
                return owner.param_stack[param_ind];
            }
            return Product();
        }

        std::string to_str() const {
            return stringformat("{}{} {} param[{}] ({})",
            mismatch?"⏮ ":"",
            state_to_str(state),
            element_str(element_id),
            param_ind,  // need the owner to get the product
            position()
            );
        }
    };

    // Pushes an element to the lr and/or parameter stacks as appropriate.
    // "ejected" elements (those marked with a '^' in fpl source) are
    // not pushed to the param stack.  Redundant lr_stack entries may or
    // may not actually be pushed.  (in the current implementation, they
    // are pushed, but that might not pertain in the future)
    void lr_push(
    int element_id, bool eject, const SourcePosition &pos, Product pr
    ) {
        lr_stack.push_back(StackEntry(
        cur_state, element_id, pos, param_stack.size(), eject
        ));
        if(!eject) {
            param_stack.push_back(pr);
        }
    }

    private:
    fpl_reader_p            reader;      // (must be non-null)
    State                   cur_state;
    std::vector<StackEntry> lr_stack;
    int                     lr_read_pos;
    std::vector<Product>    param_stack;
    size_t                  bytes_eaten; // since last terminal
    bool                    stop_parsing;
    int                     max_errors;
    int                     num_errors;

    bool                    single_step; // debugging

    // this is called when something appears to have
    // gone wrong due to a bug in the parser itself:
    void internal_error(const std::string &msg) {
        error(stringformat(
        "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
        ));
        terminate();
    }

    public:
    // constructors:
    jemplpl_parser(const jemplpl_parser &rhs) = delete;

    jemplpl_parser(fpl_reader_p rdr) :
    reader(rdr),
    cur_state(&jemplpl_parser::state_0),
    lr_read_pos(0),
    bytes_eaten(0),
    stop_parsing(false),
    max_errors(1),
    num_errors(0),
    single_step(false) {


        #line 430 "src/fpl2cc/fpl_x_parser.h.jemp" 


        lr_stack.reserve(1000);
        param_stack.reserve(1000);
    }

    // debugging:
    void set_single_step(bool newval) { single_step = newval; }
    void debug_pause() {
        int inch;
        if(single_step)
        inch = getchar();
        if(inch == 'c')
        single_step = false;
    }

    template<typename... Args>
    void debug_print(const std::string_view &fmt, Args&&... args) {

        #line 450 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // --debug option is off

        #line 454 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    void set_max_errors(int newmax) { max_errors = newmax; }

    void error(size_t pos, const std::string &msg) {
        std::string full_msg = reader->format_error_message(pos, msg);
        fputs(full_msg.c_str(), stderr);
        if(++num_errors >= max_errors) {
            fputs("too many errors.  aborting\n", stderr);
            terminate();
        }
    }

    void error(const std::string &msg) {
        error(reader->current_position(), msg);
    }

    int error_count() const { return num_errors; }

    bool eof() const {
        return reader->eof();
    }

    public:

    std::string filename() const {
        return reader->filename();
    }

    int line_number() const {
        return reader->line_number();
    }

    int line_number(size_t pos) const {
        return reader->line_number(pos);
    }

    SourcePosition position() const {
        return SourcePosition(reader);
    }

    fpl_reader_p_c const_reader() const {
        return reader;
    }

    int param_stack_size() const {
        return param_stack.size();
    }

    int lr_stack_size() const {
        return lr_stack.size();
    }

    int lr_top_index() const {
        return lr_stack.size() - 1;
    }

    void lr_pop() {
        if(lr_stack.size() > 0) {
            auto popped = lr_stack.back();
            cur_state = popped.state;
            if(popped.param_ind >= 0) {
                param_stack.resize(popped.param_ind);
            }
            lr_stack.pop_back();
        }

        if(lr_stack.size() == 0) {
            // else there's nothing left to pop on the lr_stack,
            // and the param stack had better be clear, too, or
            // something is wrong:
            if(param_stack.size() > 0) {
                jerror::warning(stringformat(
                "popping from empty lr_stack, but there are {} params\n",
                param_stack.size()
                ));
            }
        }
    }

    // "pops" and discards down to the new maximum index
    // specified
    void lr_pop_to(int new_max) {
        while(lr_top_index() > new_max) {
            lr_pop();
        }
    }

    void clear_mismatches() {
        int num_cleared = 0;
        while(lr_top().mismatch) {
            lr_pop();
            num_cleared++;
        }

        if(lr_read_pos > lr_top_index()) {
            lr_read_pos = lr_top_index() + 1;
        }


        #line 554 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    StackEntry lr_stack_entry(int pos) const {
        // (as usual, negative positions are relative to the top of stack)
        if(pos < 0) pos += lr_stack_size();

        if((pos >= 0) && (pos < lr_stack_size())) {
            return lr_stack[pos];
        } else {
            return StackEntry();
        }
    }

    StackEntry lr_next() const {
        return lr_stack_entry(lr_read_pos);
    }

    StackEntry lr_prev() const {
        return lr_stack_entry(lr_read_pos - 1);
    }

    StackEntry lr_top() const {
        return lr_stack_entry(lr_top_index());
    }

    // Increments the lr read pointer and returns true if the element ID
    // passed matches the next item to read from the lr stack.  Otherwise,
    // returns false.
    bool lr_read(int element_id) {
        if(element_id == lr_next().element_id) {
            // we may be skipping a known mismatch, in which case
            // we'll return false since it's not a correct match.
            bool mismatch = lr_next().mismatch;
            if(mismatch) {

                #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

            }

            lr_read_pos++;
            return !mismatch;
        }
        return false;
    }

    // lr_position_before_xxx(pos, multiple):  Each returns the
    // first position before pos in the lr stack which does not
    // match the element ID in question. If pos is past the top
    // of the stack, starts at the top of the stack.
    // Pseudo-recurses on subexpressions.
    //
    // These are used to put together the arguments for reduce
    // actions.

    #line 618 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before___fpl_null(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // _fpl_null
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 0) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__fragment(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // fragment
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 1) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__complete(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // complete
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 2) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__text(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // text
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 3) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_4(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 4) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_5(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@/*'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 5) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_6(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 6) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_7(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '*/@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 7) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_8(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /\\n\?/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 8) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_9(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@parameter:'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 9) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_10(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[^@]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 10) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_11(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 11) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_12(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@include:'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 12) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__leading_ws(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // leading_ws
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 13) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_14(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /@declare\\s+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 14) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__identifier(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // identifier
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 15) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_16(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // ':'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 16) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_17(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^@]|(\?:@@))*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 17) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_18(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /@realign:\\s*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 18) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_19(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '#'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 19) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_20(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // !'#'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 20) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__template_variant(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // template_variant
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 21) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_22(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@-'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 22) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__subst_start(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // subst_start
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 23) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_24(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '-@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 24) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__trailing_ws(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // trailing_ws
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 25) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__subst_end(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // subst_end
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 26) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_27(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^-@]|-[^@])+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 27) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__rest_of_sub(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // rest_of_sub
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 28) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_29(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /\\n*[ \\t]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 29) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_30(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]*\\n+[ \\t]+(\?!@)/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 30) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_31(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]*\\n/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 31) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_32(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /#\\s*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 32) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_33(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 33) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_34(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[^@\\n]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 34) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_35(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[a-zA-Z_][a-zA-Z_0-9]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 35) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_36(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 36) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__sp(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // sp
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 37) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_38(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 627 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // ␄_fpl_goal
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 38) {
            --pos;
            if(!multiple)
            break;
        }

        #line 636 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 668 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // lr_stack_size_of_X(pos, multiple):  returns the number of
    // stack entries matching X going forward through the lr stack,
    // starting at the position passed.   If argument "multiple"
    // is false, only counts up to one X.
    // Note that while simple elements will be one stack entry
    // each, subexpressions can (and normally do) take up multiple
    // stack entries per X.

    #line 677 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of___fpl_null(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 0) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__fragment(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 1) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__complete(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 2) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__text(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 3) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_4(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 4) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_5(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 5) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_6(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 6) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_7(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 7) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_8(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 8) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_9(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 9) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_10(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 10) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_11(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 11) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_12(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 12) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__leading_ws(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 13) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_14(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 14) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__identifier(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 15) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_16(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 16) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_17(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 17) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_18(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 18) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_19(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 19) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_20(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 20) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__template_variant(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 21) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_22(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 22) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__subst_start(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 23) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_24(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 24) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__trailing_ws(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 25) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__subst_end(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 26) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_27(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 27) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__rest_of_sub(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 28) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_29(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 29) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_30(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 30) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_31(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 31) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_32(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 32) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_33(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 33) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_34(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 34) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_35(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 35) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_36(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 36) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__sp(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 37) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_stack_size_of__terminal_38(int pos, bool multiple) const {
        int size = 0;

        #line 683 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 38) {
            ++size;
            if(!multiple)
            break;
        }

        #line 690 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 726 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // A StackSlice here is a set of 0 or more consecutive lr_stack
    // entries. It's used to represent the match(es) which went into
    // 1 particular step (see ReductionParameter, below), or the set
    // of all steps which led to a current rule match (see
    // all_matched_steps(), below), or any other slice of the lr_stack.
    class StackSlice {
        int base_index; // in lr_stack
        int size;       // number of elements in lr_stack

        // owner here is annoying because we should be able to
        // infer it... jest feature?
        const jemplpl_parser &owner;

        public:
        // Returns the number of lr_stack entries in this slice:
        int count() const { return size; }

        int start() const { return base_index; }

        // Returns the number of parameter stack entries for this
        // entire slice.  This can be different from the number
        // of lr_stack entries due to ejectedness (in which case
        // there are 0 parameters) as well stuff like melding
        // (which is handled in ReductionParameter)
        int param_count() const {
            StackEntry sel = owner.lr_stack_entry(base_index);

            // no params if we're an empty slice.
            // without this check, we can end up returning a
            // negative size, and no one wants that.
            if(count() == 0) return 0;

            // this slice "contains" all arguments starting
            // at the position in the argument stack starting
            // at the argument from the base element and going
            // to just before the one for the base element of
            // the slice above us, or the top of the argument
            // stack if we're the topmost slice
            int cap_ind = base_index + size;
            if(cap_ind < owner.lr_stack_size()) {
                StackEntry eel = owner.lr_stack_entry(cap_ind);
                return eel.param_ind - sel.param_ind;
            } else {
                // goes to the end of the arg stack:
                return owner.param_stack_size() - sel.param_ind;
            }
        }

        // returns the corresponding base in the param stack
        // or -1 if there is no such thing.
        int param_base() const {
            return owner.lr_stack_entry(base_index).param_ind;
        }

        // construct a slice with a particular base and count.
        // if the count is -1 or unspecified, construct a slice
        // with the given base to the top of the stack
        StackSlice(const jemplpl_parser &o, int base, int count = -1) :
        base_index(base),
        size(count),
        owner(o)
        {
            if(size == -1) {
                size = owner.lr_stack.size() - base;
            }
        }

        // Negative indexes are offset from a hypothetical argument
        // just past the end of the slice (i.e. -1 means end-of-slice).
        // Accessing to entries outside the slice yields a "false"
        // stack entry.
        StackEntry operator [](int ind) const {
            if(ind < 0) ind += size; // allow negative indexes

            int off = ind + base_index;
            if((off < owner.lr_stack_size()) && (off >= 0)) {
                return owner.lr_stack[off];
            } else {
                return StackEntry();
            }
        }

        // Returns the nth "product" (from the param stack)
        // corresponding to this slice.
        // If the index passed is out of bounds, returns a 
        // default product.
        // Note that there may be 0 products for any slice,
        // so the 0th is not guaranteed to be anything real,
        // though if it's not it will still return a valid
        // (though false) Product.
        Product product(int ind, src_location caller = CALLER()) const {
            const int pbase = param_base();

            if(pbase < 0) {
                // this is probably an internal error:
                jerror::error(stringformat(
                "{} product({}) called on stack slice with no param base",
                caller, ind
                ));
                return Product();
            }

            const int num_args = param_count();
            if(ind < 0) {
                jerror::warning(stringformat(
                "{} wrapping is no longer supported on product({})",
                caller, ind
                ));
            }

            if((ind >= 0) && (ind < num_args)) {
                unsigned int sind = pbase + ind;
                return owner.param_stack_entry(sind, caller);
            } else {
                return Product();
            }
        }

        std::string to_str() const {
            std::string out = stringformat(
            "slice of {} entries at {}\n",
            size, base_index
            );
            for(int ind = 0; ind < size; ++ind) {
                out += stringformat("    {}\n", (*this)[ind]);
            }
            return out;
        }
    };

    // Call this within a reduce function to get a stack slice containing
    // all the steps (StackEntries) for the matched rule.
    // Don't call from outside a reduce function.
    StackSlice all_matched_steps() {
        return StackSlice(*this, lr_read_pos);
    }

    // call this like:  prod_type_name(typeid(...));
    static std::string prod_type_name(const std::type_info &tinf) {

        #line 867 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }

        #line 871 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(std::type_index(typeid(std::string)) == std::type_index(tinf)) {
            return "std::string";
        }

        #line 871 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }
        if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
            return "Product";
        }

        // if you can get here it's massive fail
        return stringformat("<unknown type {} in prod_type_name>", tinf);
    }


    // This represents the argument for a given step.  One "argument",
    // in this context, can contain 0 or more elements (for example,
    // in foo+ -> bar;, foo can have 1 or more elements).
    template<typename ReduceType>
    class ReductionParameter {
        // all access to param and lr stacks go through this:
        StackSlice lr_slice;

        // Number of param stack entries to go forward in the
        // param stack get to the next item in this parameter.
        int next_incr;

        public:
        ReductionParameter(
        jemplpl_parser &o, int lr_base, int lr_count, int lr_incr=1
        ) : lr_slice(o, lr_base, lr_count), next_incr(lr_incr) {
            // avoid divide by zero in count().  (perhaps we should
            // support an incr of 0 for single vars?)
            if(next_incr == 0) next_incr = 1;
        }

        // Returns the "span" size of this parameter in the
        // param stack.  This is the total number of entry
        // slots that the elements of this fpl-author-facing
        // parameter uses, and is potentially different from
        // the count() due to melding.
        int params_span_size() const {
            return lr_slice.param_count();
        }

        // Returns the position in the param stack for the start
        // of our params.
        int params_start() const {
            return lr_slice.param_base();
        }

        // returns the fpl-author-facing number of items
        // in this parameter:
        int count() const {
            int spsize = params_span_size();
            return spsize / next_incr + ((spsize % next_incr)?1:0);
        }

        // (syntactic sugar for optionals)
        bool exists() const { return count() !=  0; }

        SourcePosition position() const {
            return lr_slice[0].position();
        }

        SourcePosition end_position() const {
            return lr_slice[-1].position();
        }

        // this allows you to refer to the stack slice itself from within
        // reduce functions using the at sign (eg thing@self())
        ReductionParameter<ReduceType> self() { return *this; }

        // in reduce code, this is accessed via [] or (for the 0th element)
        // just the name of the variable itself.
        const ReduceType val(int ind = 0, src_location ca = CALLER()) const {
            const int num_args = count();
            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind < 0) || (ind >= num_args)) {
                jerror::warning(stringformat(
                "Index {} out of range ({} items at {} span {}) at {}",
                ind, num_args, params_start(), params_span_size(), ca
                ));

                // return a default item of the ReduceType so we can move on:
                return ReduceType();
            }

            try {
                return std::get<ReduceType>(
                lr_slice.product(ind * next_incr, ca).var()
                );
            }
            catch (const std::bad_variant_access& e) {
                // this is an internal error and needs to be taken seriously:
                jerror::error(stringformat(
                "{} bad variant access (expected {}) on val({}) in {}\n",
                ca, prod_type_name(typeid(ReduceType)), ind, lr_slice
                ));
            }
            // try to return a default anyway:
            return ReduceType();
        }

        static std::string type_name() {
            return prod_type_name(typeid(ReduceType));
        }

        std::string concatenate() const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
            }
            return out;
        }

        using ForeachFunc = std::function<void(const ReduceType &)>;
        void foreach(ForeachFunc func) const {
            for(int ind = 0; ind < count(); ++ind) {
                func(val(ind));
            }
        }

        std::string join(const std::string &fmt, const std::string &jv) const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                auto vfmt = stringformat(fmt, val(ind));
                if(ind < count() - 1)
                out += stringformat("{}{}", vfmt, jv);
                else // last element
                out += stringformat("{}", vfmt);
            }
            return out;
        }

        std::string join(const std::string &jv) const {
            return join("{}", jv);
        }

        // formats each according to the format passed and
        // then returns the concatenation of the results
        std::string catmap(const std::string &fmt) const {
            return join(fmt, "");
        }

        std::string to_str() const {
            return stringformat(
            "{} ({} items at {})",
            join("'{}'", ", "), count(), params_start()
            );
        }
    };

    void set_state(State st) {
        cur_state = st;
    }

    Product param_stack_entry(int pos, src_location caller = CALLER()) const {
        // this is very similar to lr_stack_entry.  generalize?
        if((pos >= 0) && (pos < param_stack.size())) {
            return param_stack[pos];
        } else {
            jerror::warning(stringformat(
            "param stack access out of range ({}/{}) at {}",
            pos, param_stack.size(), caller
            ));
            return Product();
        }
    }

    State current_state() const {
        return cur_state;
    }

    // this is more or less debugging
    std::string param_stack_string() const {
        std::string out;
        out += stringformat("param stack ({} items):\n", param_stack.size());
        for(int sind = param_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
            "    [{}] {::n}\n", sind, param_stack_entry(sind)
            );
        }
        return out;
    }

    std::string to_str() const {
        std::string out;

        out += stringformat(
        "next up (lr pos {}): {}\n", lr_read_pos, next_up_str()
        );
        out += stringformat(
        "{} bytes of separator since last terminal\n", bytes_eaten
        );
        out += stringformat("lr stack ({} items):\n", lr_stack.size());
        for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
            " {} [{}] {}\n",
            sind == lr_read_pos?"->":"  ", sind, lr_stack_entry(sind)
            );
        }
        out += param_stack_string();
        return out;
    }

    Product result() const {
        // (... possibly we should only consider it a result if there's
        // exactly one item on the stack.  could simplify callers)
        return lr_top().product(*this);
    }

    int result_product_id() const {
        return lr_top().element_id;
    }

    // mismatch() begins or continues the backtracking process when
    // a state hits unexpected input.
    void mismatch() {
        // move the lr read pointer to before the last bad push:
        while(lr_stack_entry(--lr_read_pos).mismatch)
        ;

        if(lr_read_pos < 0) {
            lr_read_pos = 0;
            // can't go back any more, so terminate:
            terminate();
        } else {
            // mark whatever was there as a mismatch, and try that
            // state again:
            StackEntry &bad_entry = lr_stack[lr_read_pos];
            bad_entry.mismatch = true;
            cur_state = bad_entry.state;
            reader->go_to(bad_entry.position());
        }
    }

    void terminate() {
        stop_parsing = true;
    }

    // Removes terminals from the top of the lr stack and sets
    // the source read position to the start of the removed
    // terminals.
    // This is used after termination to unwind such that the
    // read position is just after the last successfully parsed
    // thing instead of potentially being after some recognized
    // but unused terminals, thus setting the read pointer to
    // the start of any unrecognized input.
    void rewind_to_nonterm() {
        if(result())
        return; // already after last nonterminal

        size_t rewind_to = reader->current_position();
        while(lr_stack.size() > 0) {
            auto last = lr_stack.back();
            if(last.is_nonterminal()) {
                break;
            }
            rewind_to = last.position();
            lr_pop();
        }
        reader->go_to(rewind_to);
    }

    // Returns a string with either the next bit of text
    // (in French quotes) or the next production
    std::string next_up_str() const {
        if(StackEntry next = lr_next()) {
            return stringformat(
            "{} = {::n}",
            element_str(next.element_id), next.product(*this)
            );
        } else {
            return stringformat(
            "«{}» ({}:{::n})",
            reader->debug_peek(32),
            reader->filename(), reader->current_position()
            );
        }
    }

    // not passing by reference here - instead, crossing fingers
    // and hoping it really just gets inlined.
    inline void post_parse(std::string result) {

        #line 1016 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    bool more_to_parse() const {
        // there's more to parse if:
        //  - we haven't been told to stop (due to matching _fpl_goal,
        //    or errors, or whatever)
        //  - and there's more input -or- we're not at the goal
        return !stop_parsing
        && ((!eof() || lr_stack.size() > 1) || !result_is_goal());
    }

    // resets the state of the parser, discarding anything on
    // the stack.
    // does _not_ reset the input position, so as to allow
    // mixed-parser parses.
    void reset() {
        debug_print("resetting jemplpl_parser\n");

        lr_stack.clear();
        lr_read_pos      = 0;
        param_stack.clear();
        set_state(&jemplpl_parser::state_0);
        bytes_eaten      = 0;
        stop_parsing     = false;
        num_errors       = 0;
    }

    // In an fpl parser, we do not want to require that the whole
    // input has been consumed.  This allows piecewise parsing.
    // For example, a top down parser can invoke an fpl parser
    // to handle some class of expressions, receive the result,
    // and then continue parsing whatever it was parsing.  Or,
    // let's say you're parsing a stream of input, and you want
    // to parse it as it comes in instead of all at once after
    // getting the entire thing.
    //
    // So, this parses as much as it can, then leaves the parser
    // as intact as possible so that the caller can examine it
    // for errors or whatever and decide what to do.
    //
    void parse_partial() {
        do {
            State st = current_state();
            (this->*st)();
        } while(more_to_parse());
    }

    // Attempts to parse a goal from the current input.
    // If we didn't parse a goal, input remains at the
    // position from the start of parse.
    // Any additional input after the goal is left and may be
    // parsed with additional passes of this or another parser.
    // If it parsed a goal product, that product will be returned.
    // Otherwise, returns a false product.
    const Product parse_goal() {
        reset();
        parse_partial();
        rewind_to_nonterm();
        if(result_is_goal()) {
            return result();
        }
        return Product();
    }

    // Returns a string containing a list of possible terminals
    // when in the state passed.  Used for error messages.
    static std::string expected_terminals(State st) {

        #line 1086 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@parameter:', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@include:', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@/*', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@realign:\\\\s*/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/#\\\\s*/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[a-zA-Z_][a-zA-Z_0-9]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'#', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "!'#', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'#', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[a-zA-Z_][a-zA-Z_0-9]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "':', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^@]|(\\\?:@@))*/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@parameter:', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@include:', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@/*', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@realign:\\\\s*/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'*/@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_52 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_53 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1091 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_54 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_55 == st) {
            return 
            #line 1089 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1093 "src/fpl2cc/fpl_x_parser.h.jemp" 

        return "";
    }

    void report_parse_error(const std::string &errm) {
        // at this point, it looks clearest to just pass the
        // error through.  I'm keeping this function as a
        // place to hook counters or whatever, however.
        error(errm);
    }

    // returns a string telling why parse() failed, or
    // an empty string if it appears to have worked
    std::string why_bad_parse() const {
        Product got = result();
        int got_id  = result_product_id();

        // In this case, we're assuming we have the entire input.
        // So, we expect:
        //   - we're at eof (end of input)
        //   - only the result left on the stack
        //   - result is a goal
        if(!eof()) {
            // If we're not at end of input, we stopped when we
            // didn't recognize something.  If there's currently 
            // a "result", that's what was unexpected (i.e. it
            // recognized something, but that something didn't
            // fit the bigger picture).  Otherwise, it means we
            // got some generally unrecognized input:
            std::string prev_str;
            if(StackEntry prev = lr_prev()) {
                prev_str = stringformat(
                " after {} at {}",
                element_str(prev.grammar_element_id()),
                prev.position()
                );
            }
            if(got_id >= 0 && is_nonterminal(got_id)) {
                return stringformat(
                "unexpected element{}: {} ({}).\nso far we have:\n{}",
                prev_str,
                element_str(got_id), got,
                StackSlice(*this, 0)
                //next_up_str()
                );
            } else  {
                return stringformat(
                "unrecognised input{}.  expected one of: {}",
                prev_str,
                expected_terminals(current_state())
                );
            }
        } else if(lr_stack_size() > 1) {
            // If there's extra stuff on the stack after we rewound,
            // it means we recognized more than one component, but
            // nothing complete.
            return "incomplete input";
        } else if(!result_is_goal()) {
            return stringformat(
            "parsed a {} = {}, but that's not a goal ({})",
            element_str(got_id), got, "complete"
            );
        }
        return "";
    }

    // Parses the contents of the current reader.
    // Input contents are assumed to be complete.
    // Calls error() if any parse errors were detected.
    // Returns whatever it got, regardless of errors,
    // which might mean returning a default of whatever
    // the reduce type is.
    std::string parse() {
        // we're parsing from initial state...
        reset();
        parse_partial();

        // consume any additional "separators" (eg whitespace,
        // comments) before checking the parse, since it's
        // going to check eof()
        eat_separator();

        std::string errm = why_bad_parse();
        if(errm.length()) {
            report_parse_error(errm);
        } else {
            post_parse(result().val());
        }

        return result().val();
    }

    private:


    #line 1187 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 154 "src/jemplpl/jemplpl.fpl"


    static inline std::string quote(const std::string &str) {
        return "\"" + c_str_escape(str) + "\"";
    }

    // returns a string containing a c style "#line"
    // line and the code to update the current line number,
    // using the stack slice associated with the fpl
    // reduction code argument passed.
    template<typename SliceType>
    static inline std::string line_num(const SliceType &tokens) {
        auto end_pos = tokens.end_position();
        return stringformat(
        "\n#line {} \"{}\"\n"
        "source.ln = {};\n",
        end_pos.line_number(), end_pos.filename(),
        end_pos.line_number()
        );
    }

    public:

    struct _jempl {
        // for the function we'll create:
        std::list<std::string> params;

        std::string realign_fragment;

        Searchpath import_path;
        std::set<std::string> imports;
        std::set<std::filesystem::path> import_files;

        std::string fmt_params() {
            return join(params, ",");
        }

        std::string realign_frag() const {
            return realign_fragment;
        }

    } jempl;

    void init_import_path(const std::filesystem::path &src) {
        jempl.import_path.append(src.parent_path());
        jempl.import_path.append_from_env("JEMP_INCLUDE_PATH");
        jempl.import_path.append_from_env("CPLUS_INCLUDE_PATH");
        jempl.import_path.append_from_env("C_INCLUDE_PATH");
        jempl.import_path.append_from_env("CPATH");
    }

    void add_import(const std::filesystem::path &imp) {
        jempl.import_files.insert(imp);
    }

    std::filesystem::path source_filename() const {
        return reader->filename();
    }

    std::string output_header(
    const std::string prog_name, const std::string src_name
    ) {
        return stringformat(
        "// generated by {} v{}.{}\n"
        "//  source: {}\n",
        prog_name, VERSION_MAJ, VERSION_MIN, src_name
        );
    }

    static std::string function_name(std::filesystem::path src) {
        // remove directories above:
        src = src.filename();

        // remove _all_ extensions from the src path passed.
        // this means foo.h.jemp -> just foo
        while(src.has_extension())
        src = src.stem();

        return src;
    }

    std::string output_function_name() const {
        return function_name(source_filename());
    }

    void init(const std::filesystem::path &src) {
        init_import_path(src);
    }

    #line 11886 "src/jemplpl/jemplpl.cc"

    // return to "private" after each such block.
    // this way, authors can add public members
    // to the parser without turning other stuff public 
    private:

    #line 1193 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // custom scanners:

    #line 1196 "src/fpl2cc/fpl_x_parser.h.jemp" 



    #line 1203 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1206 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // _fpl_null
    bool shift_NONTERM_PRODUCTION___fpl_null(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == __fpl_null) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not __fpl_null)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(__fpl_null)) {
            debug_print("shifting nonterm __fpl_null\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // fragment
    bool shift_NONTERM_PRODUCTION__fragment(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _fragment) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _fragment)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_fragment)) {
            debug_print("shifting nonterm _fragment\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // complete
    bool shift_NONTERM_PRODUCTION__complete(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _complete) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _complete)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_complete)) {
            debug_print("shifting nonterm _complete\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // text
    bool shift_NONTERM_PRODUCTION__text(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _text) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _text)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_text)) {
            debug_print("shifting nonterm _text\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@@' 
    bool shift_TERM_EXACT__terminal_4(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_4) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_4);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@@' (@@)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@@'\n");

            lr_push(_terminal_4, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_4)) {
                internal_error(stringformat(
                "expected item with id _terminal_4 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@/*' 
    bool shift_TERM_EXACT__terminal_5(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_5) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_5);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@/*' (@/*)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@/*")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@/*");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@/*'\n");

            lr_push(_terminal_5, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_5)) {
                internal_error(stringformat(
                "expected item with id _terminal_5 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/ 
    bool shift_TERM_REGEX__terminal_6(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_6) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_6);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/ ((\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*)

            std::cmatch match = reader->read_re("(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/\n");

            lr_push(_terminal_6, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_6)) {
                internal_error(stringformat(
                "expected item with id _terminal_6 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '*/@' 
    bool shift_TERM_EXACT__terminal_7(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_7) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_7);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '*/@' (*/@)

            const SourcePosition pos = position();
            if(reader->read_exact_match("*/@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("*/@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '*/@'\n");

            lr_push(_terminal_7, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_7)) {
                internal_error(stringformat(
                "expected item with id _terminal_7 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /\\n\?/ 
    bool shift_TERM_REGEX__terminal_8(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_8) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_8);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /\\n\?/ (\\n\?)

            std::cmatch match = reader->read_re("\\n\?");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /\\\\n\\\?/\n");

            lr_push(_terminal_8, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_8)) {
                internal_error(stringformat(
                "expected item with id _terminal_8 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@parameter:' 
    bool shift_TERM_EXACT__terminal_9(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_9) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_9);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@parameter:' (@parameter:)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@parameter:")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@parameter:");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@parameter:'\n");

            lr_push(_terminal_9, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_9)) {
                internal_error(stringformat(
                "expected item with id _terminal_9 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[^@]+/ 
    bool shift_TERM_REGEX__terminal_10(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_10) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_10);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[^@]+/ ([^@]+)

            std::cmatch match = reader->read_re("[^@]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[^@]+/\n");

            lr_push(_terminal_10, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_10)) {
                internal_error(stringformat(
                "expected item with id _terminal_10 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@' 
    bool shift_TERM_EXACT__terminal_11(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_11) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_11);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@' (@)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@")) {
                if(
                reader->read_exact_match("@") ||
                reader->read_exact_match("/*") ||
                reader->read_exact_match("parameter:") ||
                reader->read_exact_match("include:") ||
                reader->read_exact_match("-") ||
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@'\n");

            lr_push(_terminal_11, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_11)) {
                internal_error(stringformat(
                "expected item with id _terminal_11 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@include:' 
    bool shift_TERM_EXACT__terminal_12(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_12) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_12);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@include:' (@include:)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@include:")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@include:");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@include:'\n");

            lr_push(_terminal_12, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_12)) {
                internal_error(stringformat(
                "expected item with id _terminal_12 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // leading_ws
    bool shift_NONTERM_PRODUCTION__leading_ws(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _leading_ws) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _leading_ws)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_leading_ws)) {
            debug_print("shifting nonterm _leading_ws\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /@declare\\s+/ 
    bool shift_TERM_REGEX__terminal_14(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_14) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_14);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /@declare\\s+/ (@declare\\s+)

            std::cmatch match = reader->read_re("@declare\\s+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /@declare\\\\s+/\n");

            lr_push(_terminal_14, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_14)) {
                internal_error(stringformat(
                "expected item with id _terminal_14 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // identifier
    bool shift_NONTERM_PRODUCTION__identifier(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _identifier) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _identifier)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_identifier)) {
            debug_print("shifting nonterm _identifier\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // ':' 
    bool shift_TERM_EXACT__terminal_16(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_16) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_16);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal ':' (:)

            const SourcePosition pos = position();
            if(reader->read_exact_match(":")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal(":");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting ':'\n");

            lr_push(_terminal_16, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_16)) {
                internal_error(stringformat(
                "expected item with id _terminal_16 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^@]|(\?:@@))*/ 
    bool shift_TERM_REGEX__terminal_17(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_17) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_17);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /(\?:[^@]|(\?:@@))*/ ((\?:[^@]|(\?:@@))*)

            std::cmatch match = reader->read_re("(\?:[^@]|(\?:@@))*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /(\\\?:[^@]|(\\\?:@@))*/\n");

            lr_push(_terminal_17, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_17)) {
                internal_error(stringformat(
                "expected item with id _terminal_17 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /@realign:\\s*/ 
    bool shift_TERM_REGEX__terminal_18(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_18) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_18);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /@realign:\\s*/ (@realign:\\s*)

            std::cmatch match = reader->read_re("@realign:\\s*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /@realign:\\\\s*/\n");

            lr_push(_terminal_18, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_18)) {
                internal_error(stringformat(
                "expected item with id _terminal_18 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '#' 
    bool shift_TERM_EXACT__terminal_19(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_19) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_19);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '#' (#)

            const SourcePosition pos = position();
            if(reader->read_exact_match("#")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("#");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '#'\n");

            lr_push(_terminal_19, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_19)) {
                internal_error(stringformat(
                "expected item with id _terminal_19 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // !'#' 
    bool shift_TERM_EXACT_INV__terminal_20(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_20) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_20);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal !'#' (#)

            std::string match = reader->read_to_exact_match("#");
            if(match.length())
            result = Terminal(match);


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting !'#'\n");

            lr_push(_terminal_20, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_20)) {
                internal_error(stringformat(
                "expected item with id _terminal_20 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // template_variant
    bool shift_NONTERM_PRODUCTION__template_variant(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _template_variant) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _template_variant)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_template_variant)) {
            debug_print("shifting nonterm _template_variant\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@-' 
    bool shift_TERM_EXACT__terminal_22(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_22) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_22);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '@-' (@-)

            const SourcePosition pos = position();
            if(reader->read_exact_match("@-")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@-");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '@-'\n");

            lr_push(_terminal_22, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_22)) {
                internal_error(stringformat(
                "expected item with id _terminal_22 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // subst_start
    bool shift_NONTERM_PRODUCTION__subst_start(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _subst_start) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _subst_start)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_subst_start)) {
            debug_print("shifting nonterm _subst_start\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '-@' 
    bool shift_TERM_EXACT__terminal_24(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_24) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_24);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal '-@' (-@)

            const SourcePosition pos = position();
            if(reader->read_exact_match("-@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("-@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting '-@'\n");

            lr_push(_terminal_24, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_24)) {
                internal_error(stringformat(
                "expected item with id _terminal_24 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // trailing_ws
    bool shift_NONTERM_PRODUCTION__trailing_ws(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _trailing_ws) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _trailing_ws)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_trailing_ws)) {
            debug_print("shifting nonterm _trailing_ws\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // subst_end
    bool shift_NONTERM_PRODUCTION__subst_end(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _subst_end) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _subst_end)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_subst_end)) {
            debug_print("shifting nonterm _subst_end\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^-@]|-[^@])+/ 
    bool shift_TERM_REGEX__terminal_27(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_27) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_27);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /(\?:[^-@]|-[^@])+/ ((\?:[^-@]|-[^@])+)

            std::cmatch match = reader->read_re("(\?:[^-@]|-[^@])+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /(\\\?:[^-@]|-[^@])+/\n");

            lr_push(_terminal_27, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_27)) {
                internal_error(stringformat(
                "expected item with id _terminal_27 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // rest_of_sub
    bool shift_NONTERM_PRODUCTION__rest_of_sub(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _rest_of_sub) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _rest_of_sub)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_rest_of_sub)) {
            debug_print("shifting nonterm _rest_of_sub\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /\\n*[ \\t]+/ 
    bool shift_TERM_REGEX__terminal_29(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_29) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_29);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /\\n*[ \\t]+/ (\\n*[ \\t]+)

            std::cmatch match = reader->read_re("\\n*[ \\t]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /\\\\n*[ \\\\t]+/\n");

            lr_push(_terminal_29, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_29)) {
                internal_error(stringformat(
                "expected item with id _terminal_29 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]*\\n+[ \\t]+(\?!@)/ 
    bool shift_TERM_REGEX__terminal_30(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_30) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_30);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[ \\t]*\\n+[ \\t]+(\?!@)/ ([ \\t]*\\n+[ \\t]+(\?!@))

            std::cmatch match = reader->read_re("[ \\t]*\\n+[ \\t]+(\?!@)");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/\n");

            lr_push(_terminal_30, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_30)) {
                internal_error(stringformat(
                "expected item with id _terminal_30 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]*\\n/ 
    bool shift_TERM_REGEX__terminal_31(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_31) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_31);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[ \\t]*\\n/ ([ \\t]*\\n)

            std::cmatch match = reader->read_re("[ \\t]*\\n");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[ \\\\t]*\\\\n/\n");

            lr_push(_terminal_31, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_31)) {
                internal_error(stringformat(
                "expected item with id _terminal_31 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /#\\s*/ 
    bool shift_TERM_REGEX__terminal_32(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_32) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_32);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /#\\s*/ (#\\s*)

            std::cmatch match = reader->read_re("#\\s*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /#\\\\s*/\n");

            lr_push(_terminal_32, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_32)) {
                internal_error(stringformat(
                "expected item with id _terminal_32 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/ 
    bool shift_TERM_REGEX__terminal_33(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_33) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_33);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/ ((\?:[^-{}@]|-[^@]|[{}][^-@])*[{}])

            std::cmatch match = reader->read_re("(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/\n");

            lr_push(_terminal_33, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_33)) {
                internal_error(stringformat(
                "expected item with id _terminal_33 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[^@\\n]+/ 
    bool shift_TERM_REGEX__terminal_34(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_34) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_34);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[^@\\n]+/ ([^@\\n]+)

            std::cmatch match = reader->read_re("[^@\\n]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[^@\\\\n]+/\n");

            lr_push(_terminal_34, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_34)) {
                internal_error(stringformat(
                "expected item with id _terminal_34 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[a-zA-Z_][a-zA-Z_0-9]+/ 
    bool shift_TERM_REGEX__terminal_35(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_35) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_35);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[a-zA-Z_][a-zA-Z_0-9]+/ ([a-zA-Z_][a-zA-Z_0-9]+)

            std::cmatch match = reader->read_re("[a-zA-Z_][a-zA-Z_0-9]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[a-zA-Z_][a-zA-Z_0-9]+/\n");

            lr_push(_terminal_35, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_35)) {
                internal_error(stringformat(
                "expected item with id _terminal_35 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]+/ 
    bool shift_TERM_REGEX__terminal_36(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_36) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_36);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal /[ \\t]+/ ([ \\t]+)

            std::cmatch match = reader->read_re("[ \\t]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting /[ \\\\t]+/\n");

            lr_push(_terminal_36, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_36)) {
                internal_error(stringformat(
                "expected item with id _terminal_36 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // sp
    bool shift_NONTERM_PRODUCTION__sp(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _sp) {
            debug_print(
            "not matching mismatched nonterm ('{}' is not _sp)\n",
            lr_next()
            );
            return false;
        }

        if(lr_read(_sp)) {
            debug_print("shifting nonterm _sp\n");
            return true;
        }

        return false;
    }



    #line 1209 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1207 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // ␄_fpl_goal 
    bool shift_END_OF_PARSE__terminal_38(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_38) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_38);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();
        Terminal result;

        {
            // "scan" a terminal by advancing the read pointer to just beyond
            // the terminal if the current input matches the element passed.
            // leaves the read pointer where it is if the current inout doesn't
            // match the element passed

            // scan terminal ␄_fpl_goal (_fpl_goal)

            // end of parse placeholder


        }



        if(result) {
            clear_mismatches();  // (we matched)

            debug_print("shifting ␄_fpl_goal\n");

            lr_push(_terminal_38, eject, pos, Product(result));


            #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
            bytes_eaten = 0;

            if(!lr_read(_terminal_38)) {
                internal_error(stringformat(
                "expected item with id _terminal_38 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1212 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1213 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // shift_NONE_xxx()
    bool shift_NONE___fpl_null(bool eject) {
        // this always matches. it's used to match at ends of rules.
        return true;
    }


    public:

    typedef enum {

        #line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 
        __fpl_null, // 0 _fpl_null

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _fragment, // 1 fragment

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _complete, // 2 complete

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _text, // 3 text

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_4, // 4 '@@'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_5, // 5 '@/*'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_6, // 6 /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_7, // 7 '*/@'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_8, // 8 /\\n\?/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_9, // 9 '@parameter:'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_10, // 10 /[^@]+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_11, // 11 '@'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_12, // 12 '@include:'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _leading_ws, // 13 leading_ws

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_14, // 14 /@declare\\s+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _identifier, // 15 identifier

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_16, // 16 ':'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_17, // 17 /(\?:[^@]|(\?:@@))*/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_18, // 18 /@realign:\\s*/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_19, // 19 '#'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_20, // 20 !'#'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _template_variant, // 21 template_variant

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_22, // 22 '@-'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _subst_start, // 23 subst_start

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_24, // 24 '-@'

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _trailing_ws, // 25 trailing_ws

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _subst_end, // 26 subst_end

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_27, // 27 /(\?:[^-@]|-[^@])+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _rest_of_sub, // 28 rest_of_sub

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_29, // 29 /\\n*[ \\t]+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_30, // 30 /[ \\t]*\\n+[ \\t]+(\?!@)/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_31, // 31 /[ \\t]*\\n/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_32, // 32 /#\\s*/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_33, // 33 /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_34, // 34 /[^@\\n]+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_35, // 35 /[a-zA-Z_][a-zA-Z_0-9]+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_36, // 36 /[ \\t]+/

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _sp, // 37 sp

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_38, // 38 ␄_fpl_goal

        #line 1222 "src/fpl2cc/fpl_x_parser.h.jemp" 
    } ElementID;

    // returns a string describing the element matching the ID
    // passed. this is for debugging.
    static std::string element_str(int id) {
        switch(id) {

            #line 1229 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 0: return "_fpl_null (0)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 1: return "fragment (1)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 2: return "complete (2)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 3: return "text (3)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 4: return "'@@' (4)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 5: return "'@/*' (5)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 6: return "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/ (6)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 7: return "'*/@' (7)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 8: return "/\\\\n\\\?/ (8)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 9: return "'@parameter:' (9)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 10: return "/[^@]+/ (10)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 11: return "'@' (11)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 12: return "'@include:' (12)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 13: return "leading_ws (13)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 14: return "/@declare\\\\s+/ (14)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 15: return "identifier (15)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 16: return "':' (16)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 17: return "/(\\\?:[^@]|(\\\?:@@))*/ (17)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 18: return "/@realign:\\\\s*/ (18)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 19: return "'#' (19)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 20: return "!'#' (20)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 21: return "template_variant (21)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 22: return "'@-' (22)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 23: return "subst_start (23)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 24: return "'-@' (24)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 25: return "trailing_ws (25)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 26: return "subst_end (26)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 27: return "/(\\\?:[^-@]|-[^@])+/ (27)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 28: return "rest_of_sub (28)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 29: return "/\\\\n*[ \\\\t]+/ (29)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 30: return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/ (30)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 31: return "/[ \\\\t]*\\\\n/ (31)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 32: return "/#\\\\s*/ (32)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 33: return "/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/ (33)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 34: return "/[^@\\\\n]+/ (34)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 35: return "/[a-zA-Z_][a-zA-Z_0-9]+/ (35)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 36: return "/[ \\\\t]+/ (36)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 37: return "sp (37)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 38: return "␄_fpl_goal (38)";

            #line 1232 "src/fpl2cc/fpl_x_parser.h.jemp" 
        }
        return stringformat("¡unknown element id {}!", id);
    }

    static bool is_nonterminal(int id, const std::string &caller = CALLER()) {
        switch(id) {

            #line 1239 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 0: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 1: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 2: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 3: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 4: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 5: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 6: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 7: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 8: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 9: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 10: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 11: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 12: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 13: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 14: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 15: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 16: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 17: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 18: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 19: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 20: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 21: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 22: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 23: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 24: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 25: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 26: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 27: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 28: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 29: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 30: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 31: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 32: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 33: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 34: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 35: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 36: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 37: return true;

            #line 1242 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1240 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 38: return false;

            #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 
        }
        jerror::error(stringformat(
        "internal error {}: invalid terminal id: {}\n", caller, id
        ));
        return false;
    }

    // returns the name of the state function for the state pointer passed
    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) return "state_0";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) return "state_1";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) return "state_2";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) return "state_3";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) return "state_4";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) return "state_5";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) return "state_6";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) return "state_7";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) return "state_8";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) return "state_9";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) return "state_10";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) return "state_11";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) return "state_12";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) return "state_13";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) return "state_14";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) return "state_15";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) return "state_16";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) return "state_17";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) return "state_18";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) return "state_19";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) return "state_20";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) return "state_21";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) return "state_22";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) return "state_23";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) return "state_24";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) return "state_25";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) return "state_26";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) return "state_27";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) return "state_28";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) return "state_29";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) return "state_30";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) return "state_31";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) return "state_32";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) return "state_33";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) return "state_34";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) return "state_35";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) return "state_36";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) return "state_37";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) return "state_38";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) return "state_39";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) return "state_40";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) return "state_41";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) return "state_42";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) return "state_43";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) return "state_44";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) return "state_45";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) return "state_46";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) return "state_47";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) return "state_48";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) return "state_49";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) return "state_50";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) return "state_51";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_52 == st) return "state_52";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_53 == st) return "state_53";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_54 == st) return "state_54";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_55 == st) return "state_55";

        #line 1259 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    // return a stack-trace style dump of the state passed.
    static const char *state_string(State st) {

        #line 1267 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {
            return "state_0:\n"
            "    complete (0:1):\t •fragment+:fragments \t=> state 37\t(src/grammarlib/jemp.fpl:12)\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 46\t(src/grammarlib/jemp.fpl:24)\n"
            "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 38\t(src/grammarlib/jemp.fpl:35)\n"
            "    fragment (5:4):\t •'@include:'^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:40)\n"
            "    fragment (6:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 29\t(src/grammarlib/jemp.fpl:46)\n"
            "    fragment (6:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:46)\n"
            "    fragment (7:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 51\t(src/grammarlib/jemp.fpl:59)\n"
            "    subst_start (9:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 29\t(src/grammarlib/jemp.fpl:66)\n"
            "    subst_start (9:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:66)\n"
            "    subst_start (10:1):\t •'@':arg_0 \t=> state 50\t(src/grammarlib/jemp.fpl:67)\n"
            "    leading_ws (14:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:77)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:91)\n"
            "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:95)\n"
            "    fragment (17:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:103)\n"
            "    fragment (18:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:106)\n"
            "    fragment (19:3):\t •subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:118)\n"
            "    fragment (20:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:123)\n"
            "    text (21:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:127)\n"
            "    text (22:1):\t •leading_ws \t=> state 29\t(src/grammarlib/jemp.fpl:131)\n"
            "    text (23:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:132)\n"
            "    _fpl_goal (26:1):\t •complete \t=> state 55\t(src/fpl2cc/productions.h:4299)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {
            return "state_1:\n"
            "    text (23:0):\t trailing_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:132)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {
            return "state_2:\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    fragment (1:0):\t text+:chunks •\t=> (reduce)\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    leading_ws (14:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:77)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:91)\n"
            "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:95)\n"
            "    text (21:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:127)\n"
            "    text (22:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:131)\n"
            "    text (23:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:132)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {
            return "state_3:\n"
            "    text (22:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:131)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {
            return "state_4:\n"
            "    text (2:0):\t '@@':at_sign •\t=> (reduce)\t(src/grammarlib/jemp.fpl:20)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {
            return "state_5:\n"
            "    leading_ws (14:0):\t /\\\\n*[ \\\\t]+/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:77)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {
            return "state_6:\n"
            "    text (21:0):\t /[^@\\\\n]+/:t •\t=> (reduce)\t(src/grammarlib/jemp.fpl:127)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {
            return "state_7:\n"
            "    trailing_ws (15:0):\t /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:91)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {
            return "state_8:\n"
            "    trailing_ws (16:0):\t /[ \\\\t]*\\\\n/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:95)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {
            return "state_9:\n"
            "    fragment (17:5):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 17\t(src/grammarlib/jemp.fpl:103)\n"
            "    fragment (18:4):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 17\t(src/grammarlib/jemp.fpl:106)\n"
            "    fragment (19:2):\t subst_start^ •/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 10\t(src/grammarlib/jemp.fpl:118)\n"
            "    fragment (20:2):\t subst_start^ •/(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 15\t(src/grammarlib/jemp.fpl:123)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {
            return "state_10:\n"
            "    subst_end (11:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:69)\n"
            "    subst_end (12:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:70)\n"
            "    fragment (19:1):\t subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement •subst_end^ \t=> state 11\t(src/grammarlib/jemp.fpl:118)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {
            return "state_11:\n"
            "    fragment (19:0):\t subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:118)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {
            return "state_12:\n"
            "    subst_end (12:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:70)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {
            return "state_13:\n"
            "    subst_end (11:1):\t '-@':arg_0 •trailing_ws\?^ \t=> state 14\t(src/grammarlib/jemp.fpl:69)\n"
            "    subst_end (11:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:69)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:91)\n"
            "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:95)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {
            return "state_14:\n"
            "    subst_end (11:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:69)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {
            return "state_15:\n"
            "    subst_end (11:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:69)\n"
            "    subst_end (12:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:70)\n"
            "    fragment (20:1):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable •subst_end^ \t=> state 16\t(src/grammarlib/jemp.fpl:123)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {
            return "state_16:\n"
            "    fragment (20:0):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:123)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {
            return "state_17:\n"
            "    fragment (17:4):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 18\t(src/grammarlib/jemp.fpl:103)\n"
            "    fragment (18:3):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 18\t(src/grammarlib/jemp.fpl:106)\n"
            "    identifier (24:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 28\t(src/grammarlib/jemp.fpl:135)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {
            return "state_18:\n"
            "    template_variant (8:3):\t •'#'^ !'#':variant_expression '#'^ \t=> state 25\t(src/grammarlib/jemp.fpl:64)\n"
            "    rest_of_sub (13:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 22\t(src/grammarlib/jemp.fpl:71)\n"
            "    fragment (17:3):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 19\t(src/grammarlib/jemp.fpl:103)\n"
            "    fragment (18:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^ \t=> state 23\t(src/grammarlib/jemp.fpl:106)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {
            return "state_19:\n"
            "    rest_of_sub (13:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 22\t(src/grammarlib/jemp.fpl:71)\n"
            "    fragment (17:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^ \t=> state 20\t(src/grammarlib/jemp.fpl:103)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {
            return "state_20:\n"
            "    subst_end (11:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:69)\n"
            "    subst_end (12:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:70)\n"
            "    fragment (17:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^ \t=> state 21\t(src/grammarlib/jemp.fpl:103)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {
            return "state_21:\n"
            "    fragment (17:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:103)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {
            return "state_22:\n"
            "    rest_of_sub (13:0):\t /(\\\?:[^-@]|-[^@])+/:arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:71)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {
            return "state_23:\n"
            "    subst_end (11:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:69)\n"
            "    subst_end (12:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:70)\n"
            "    fragment (18:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^ \t=> state 24\t(src/grammarlib/jemp.fpl:106)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {
            return "state_24:\n"
            "    fragment (18:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:106)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {
            return "state_25:\n"
            "    template_variant (8:2):\t '#'^ •!'#':variant_expression '#'^ \t=> state 26\t(src/grammarlib/jemp.fpl:64)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {
            return "state_26:\n"
            "    template_variant (8:1):\t '#'^ !'#':variant_expression •'#'^ \t=> state 27\t(src/grammarlib/jemp.fpl:64)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {
            return "state_27:\n"
            "    template_variant (8:0):\t '#'^ !'#':variant_expression '#'^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:64)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {
            return "state_28:\n"
            "    identifier (24:0):\t /[a-zA-Z_][a-zA-Z_0-9]+/:name •\t=> (reduce)\t(src/grammarlib/jemp.fpl:135)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {
            return "state_29:\n"
            "    fragment (6:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:46)\n"
            "    subst_start (9:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:66)\n"
            "    text (22:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:131)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {
            return "state_30:\n"
            "    subst_start (9:0):\t leading_ws\?^ '@-':arg_1 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:66)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {
            return "state_31:\n"
            "    fragment (6:5):\t leading_ws\? /@declare\\\\s+/^ •identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 32\t(src/grammarlib/jemp.fpl:46)\n"
            "    identifier (24:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 28\t(src/grammarlib/jemp.fpl:135)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {
            return "state_32:\n"
            "    fragment (6:4):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl •':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 33\t(src/grammarlib/jemp.fpl:46)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {
            return "state_33:\n"
            "    fragment (6:3):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ •/(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 34\t(src/grammarlib/jemp.fpl:46)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {
            return "state_34:\n"
            "    fragment (6:2):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value •'@'^ /\\\\n\\\?/^ \t=> state 35\t(src/grammarlib/jemp.fpl:46)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {
            return "state_35:\n"
            "    fragment (6:1):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ •/\\\\n\\\?/^ \t=> state 36\t(src/grammarlib/jemp.fpl:46)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {
            return "state_36:\n"
            "    fragment (6:0):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:46)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {
            return "state_37:\n"
            "    complete (0:1):\t •fragment+:fragments \t=> state 37\t(src/grammarlib/jemp.fpl:12)\n"
            "    complete (0:0):\t fragment+:fragments •\t=> (reduce)\t(src/grammarlib/jemp.fpl:12)\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 46\t(src/grammarlib/jemp.fpl:24)\n"
            "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 38\t(src/grammarlib/jemp.fpl:35)\n"
            "    fragment (5:4):\t •'@include:'^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:40)\n"
            "    fragment (6:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 29\t(src/grammarlib/jemp.fpl:46)\n"
            "    fragment (6:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:46)\n"
            "    fragment (7:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 51\t(src/grammarlib/jemp.fpl:59)\n"
            "    subst_start (9:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 29\t(src/grammarlib/jemp.fpl:66)\n"
            "    subst_start (9:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:66)\n"
            "    subst_start (10:1):\t •'@':arg_0 \t=> state 50\t(src/grammarlib/jemp.fpl:67)\n"
            "    leading_ws (14:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:77)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:91)\n"
            "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:95)\n"
            "    fragment (17:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:103)\n"
            "    fragment (18:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:106)\n"
            "    fragment (19:3):\t •subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:118)\n"
            "    fragment (20:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:123)\n"
            "    text (21:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:127)\n"
            "    text (22:1):\t •leading_ws \t=> state 29\t(src/grammarlib/jemp.fpl:131)\n"
            "    text (23:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:132)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {
            return "state_38:\n"
            "    fragment (4:3):\t '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 39\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {
            return "state_39:\n"
            "    fragment (4:2):\t '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\\\n\\\?/^ \t=> state 40\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {
            return "state_40:\n"
            "    fragment (4:1):\t '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\\\n\\\?/^ \t=> state 41\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {
            return "state_41:\n"
            "    fragment (4:0):\t '@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {
            return "state_42:\n"
            "    fragment (5:3):\t '@include:'^ •/[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 43\t(src/grammarlib/jemp.fpl:40)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {
            return "state_43:\n"
            "    fragment (5:2):\t '@include:'^ /[^@]+/:include_file •'@'^ /\\\\n\\\?/^ \t=> state 44\t(src/grammarlib/jemp.fpl:40)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {
            return "state_44:\n"
            "    fragment (5:1):\t '@include:'^ /[^@]+/:include_file '@'^ •/\\\\n\\\?/^ \t=> state 45\t(src/grammarlib/jemp.fpl:40)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {
            return "state_45:\n"
            "    fragment (5:0):\t '@include:'^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:40)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {
            return "state_46:\n"
            "    fragment (3:3):\t '@/*'^ •/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 47\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {
            return "state_47:\n"
            "    fragment (3:2):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment •'*/@'^ /\\\\n\\\?/^ \t=> state 48\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {
            return "state_48:\n"
            "    fragment (3:1):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ •/\\\\n\\\?/^ \t=> state 49\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {
            return "state_49:\n"
            "    fragment (3:0):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {
            return "state_50:\n"
            "    subst_start (10:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:67)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {
            return "state_51:\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (7:3):\t /@realign:\\\\s*/^ •text:realign '@'^ /\\\\n\\\?/^ \t=> state 52\t(src/grammarlib/jemp.fpl:59)\n"
            "    leading_ws (14:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:77)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:91)\n"
            "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:95)\n"
            "    text (21:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:127)\n"
            "    text (22:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:131)\n"
            "    text (23:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:132)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_52 == st) {
            return "state_52:\n"
            "    fragment (7:2):\t /@realign:\\\\s*/^ text:realign •'@'^ /\\\\n\\\?/^ \t=> state 53\t(src/grammarlib/jemp.fpl:59)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_53 == st) {
            return "state_53:\n"
            "    fragment (7:1):\t /@realign:\\\\s*/^ text:realign '@'^ •/\\\\n\\\?/^ \t=> state 54\t(src/grammarlib/jemp.fpl:59)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_54 == st) {
            return "state_54:\n"
            "    fragment (7:0):\t /@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:59)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_55 == st) {
            return "state_55:\n"
            "    _fpl_goal (26:0):\t complete •\t=> (done)\t(src/fpl2cc/productions.h:4299)\n"
            ;
        }

        #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 

        return "<invalid state>";
    }

    // Returns true if elements matching the element id passed
    // are ejected in the context of the given state, or false
    // otherwise.
    // XXX actually this can all be determined when compiling the fpl.
    // needs no runtime check.  nicht war?
    static bool state_ejects(State st, int element_id) {

        #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_start == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_9 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_12 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_5 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_18 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_14 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_32 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_trailing_ws == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_19 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_19 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_14 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_16 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_start == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_9 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_12 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_5 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_18 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_14 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_7 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_52 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_53 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_54 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_55 == st) {

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1291 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
        {
            return false;
        }
    }

    static bool is_goal(int el_id) {
        switch(el_id) {

            #line 1304 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case ElementID::_complete: return true;

            #line 1306 "src/fpl2cc/fpl_x_parser.h.jemp" 

            default: return false;
        }
        return false;
    }

    bool result_is_goal() const {
        return is_goal(result_product_id());
    }

    static size_t separator_length(const utf8_byte *inp) {

        #line 1317 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1322 "src/fpl2cc/fpl_x_parser.h.jemp" 
        {

            #line 1324 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 


            #line 1 "src/grammarlib/none.inc"
            // separator "none" means 0 bytes of separator:
            return 0;

            #line 16642 "src/jemplpl/jemplpl.cc"


            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

        }

        #line 1333 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1335 "src/fpl2cc/fpl_x_parser.h.jemp" 
        return 0;
    }

    size_t eat_separator() {
        bytes_eaten += reader->eat_separator(separator_length);
        return bytes_eaten;
    }

    // reduction rules:

    #line 1345 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_0(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> fragments,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_0";
            }
            static const char *product() {
                return "complete";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 12;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:12";
            }
            static const char *to_str() {
                return "fragment+:fragments -> complete";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "fragments"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:12";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:12"
                    );
                }
            }
        } this_rule;



        // fragment+:fragments -> complete

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 34 "src/jemplpl/jemplpl.fpl"

        std::string guts;

        fragments.foreach(
        [&guts] (const std::string &frag) { guts += frag; }
        );


        std::string function_name = output_function_name();

        #define _CLUDGE_TO_STR(x) #x
        #define _CLUDGE_STR(x) _CLUDGE_TO_STR(x)
        return stringformat(
        "#ifndef {}_H\n"
        "#define {}_H\n"
        "#line " _CLUDGE_STR(__LINE__) " \"" __FILE__ "\"\n\n"
        "#include <string>\n"
        "#include \"util/stringformat.h\"\n"  // XXX hey these should be embedded, maybe? inception
        "#include \"util/utf8_buffer.h\"\n"
        "inline std::string {}({}) {{\n"
        "    struct _jemp_srcinfo {{\n"
        "        int ln;\n"
        "        std::string filename() const {{ return \"{}\"; }};\n"
        "        int line_number() const {{ return ln; }}\n"
        "    }} source;\n"
        "    source.ln = 1;\n"
        "    std::string out;\n"
        "    {}\n"
        "    return out;\n"
        "}\n"
        "#endif // {}_H\n",
        function_name,  // #ifndef .. 
        function_name,  // #define ..
        function_name, jempl.fmt_params(), // func decl
        filename(),           // source info
        guts,                 // the real stuff
        function_name   // #endif
        );


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_1(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> chunks,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_1";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 15;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:15";
            }
            static const char *to_str() {
                return "text+:chunks -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "chunks"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:15";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:15"
                    );
                }
            }
        } this_rule;



        // text+:chunks -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 74 "src/jemplpl/jemplpl.fpl"

        std::string frag = "out += ";
        chunks.foreach(
        [&frag] (const std::string &chunk) { frag += quote(chunk) + "\n"; }
        );
        return frag + ";\n";


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_2(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> at_sign,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_2";
            }
            static const char *product() {
                return "text";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 20;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:20";
            }
            static const char *to_str() {
                return "'@@':at_sign -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "at_sign"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:20";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:20"
                    );
                }
            }
        } this_rule;



        // '@@':at_sign -> text

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 20 "src/grammarlib/jemp.fpl"
        return "@"; 

        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_3(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> comment,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_3";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 24;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:24";
            }
            static const char *to_str() {
                return "'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "comment"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:24";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:24"
                    );
                }
            }
        } this_rule;



        // '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 83 "src/jemplpl/jemplpl.fpl"

        return line_num(comment.self()) + jempl.realign_frag();


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_4(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> param_decl,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_4";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 35;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:35";
            }
            static const char *to_str() {
                return "'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "param_decl"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:35";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:35"
                    );
                }
            }
        } this_rule;



        // '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 87 "src/jemplpl/jemplpl.fpl"

        jempl.params.push_back(param_decl.val());
        return "";


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_5(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> include_file,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_5";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 40;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:40";
            }
            static const char *to_str() {
                return "'@include:'^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "include_file"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:40";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:40"
                    );
                }
            }
        } this_rule;



        // '@include:'^ /[^@]+/:include_file '@'^ /\\n\?/^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 92 "src/jemplpl/jemplpl.fpl"

        return stringformat(
        "out += std::string((const char *)utf8_buffer({}).data());\n",
        include_file.val()
        ) + line_num(include_file.self()) + jempl.realign_frag();


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_6(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> leading_ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> name_decl,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> value,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_6";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 7;
            }
            static int num_params() {
                return 3;
            }
            static int line_number() {
                return 46;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:46";
            }
            static const char *to_str() {
                return "leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "leading_ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "name_decl"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "value"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:46";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:46"
                    );
                }
            }
        } this_rule;



        // leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 99 "src/jemplpl/jemplpl.fpl"

        return line_num(value.self())
        + stringformat("const auto {} = {};\n", name_decl.val(), value.val());


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_7(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> realign,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_7";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 59;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:59";
            }
            static const char *to_str() {
                return "/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "realign"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:59";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:59"
                    );
                }
            }
        } this_rule;



        // /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 104 "src/jemplpl/jemplpl.fpl"

        jempl.realign_fragment = 
        "\nout += stringformat(" +
        quote("\n" + realign.val() + "\n") +
        ", source.line_number(), source.filename());\n";

        return line_num(realign.self()) + jempl.realign_frag();


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_8(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> variant_expression,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_8";
            }
            static const char *product() {
                return "template_variant";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 64;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:64";
            }
            static const char *to_str() {
                return "'#'^ !'#':variant_expression '#'^ -> template_variant";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variant_expression"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:64";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:64"
                    );
                }
            }
        } this_rule;



        // '#'^ !'#':variant_expression '#'^ -> template_variant

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:64 (default action for '#'^ !'#':variant_expression '#'^ -> template_variant)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        variant_expression.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_9(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_1,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_9";
            }
            static const char *product() {
                return "subst_start";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 2;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 66;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:66";
            }
            static const char *to_str() {
                return "leading_ws\?^ '@-':arg_1 -> subst_start";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_1"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:66";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:66"
                    );
                }
            }
        } this_rule;



        // leading_ws?^ '@-':arg_1 -> subst_start

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:66 (default action for leading_ws\?^ '@-':arg_1 -> subst_start)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_1.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_10(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_10";
            }
            static const char *product() {
                return "subst_start";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 67;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:67";
            }
            static const char *to_str() {
                return "'@':arg_0 -> subst_start";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:67";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:67"
                    );
                }
            }
        } this_rule;



        // '@':arg_0 -> subst_start

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:67 (default action for '@':arg_0 -> subst_start)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_11(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_11";
            }
            static const char *product() {
                return "subst_end";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 2;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 69;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:69";
            }
            static const char *to_str() {
                return "'-@':arg_0 trailing_ws\?^ -> subst_end";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:69";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:69"
                    );
                }
            }
        } this_rule;



        // '-@':arg_0 trailing_ws?^ -> subst_end

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:69 (default action for '-@':arg_0 trailing_ws\?^ -> subst_end)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_12(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_12";
            }
            static const char *product() {
                return "subst_end";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 70;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:70";
            }
            static const char *to_str() {
                return "'@':arg_0 -> subst_end";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:70";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:70"
                    );
                }
            }
        } this_rule;



        // '@':arg_0 -> subst_end

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:70 (default action for '@':arg_0 -> subst_end)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_13(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_13";
            }
            static const char *product() {
                return "rest_of_sub";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 71;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:71";
            }
            static const char *to_str() {
                return "/(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:71";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:71"
                    );
                }
            }
        } this_rule;



        // /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:71 (default action for /(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_14(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_14";
            }
            static const char *product() {
                return "leading_ws";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 77;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:77";
            }
            static const char *to_str() {
                return "/\\\\n*[ \\\\t]+/:ws -> leading_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:77";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:77"
                    );
                }
            }
        } this_rule;



        // /\\n*[ \\t]+/:ws -> leading_ws

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:77 (default action for /\\\\n*[ \\\\t]+/:ws -> leading_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_15(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_15";
            }
            static const char *product() {
                return "trailing_ws";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 91;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:91";
            }
            static const char *to_str() {
                return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:91";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:91"
                    );
                }
            }
        } this_rule;



        // /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:91 (default action for /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_16(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_16";
            }
            static const char *product() {
                return "trailing_ws";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 95;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:95";
            }
            static const char *to_str() {
                return "/[ \\\\t]*\\\\n/:ws -> trailing_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:95";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:95"
                    );
                }
            }
        } this_rule;



        // /[ \\t]*\\n/:ws -> trailing_ws

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:95 (default action for /[ \\\\t]*\\\\n/:ws -> trailing_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_17(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_args,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_name,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> variant,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_17";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 6;
            }
            static int num_params() {
                return 3;
            }
            static int line_number() {
                return 103;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:103";
            }
            static const char *to_str() {
                return "subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_args"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_name"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variant"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:103";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:103"
                    );
                }
            }
        } this_rule;



        // subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 118 "src/jemplpl/jemplpl.fpl"

        std::list<std::string> cases;
        std::string search_re = stringformat("{}.*\\.h\\.jemp$", jempl_name.val());
        for(auto templ : jempl.import_path.find_re(search_re)) {
            add_import(templ);

            cases.push_back(stringformat(
            "if(fruitbat == \"{}\") {{\n    out += {}{};\n}",
            function_name(templ), function_name(templ), jempl_args.val()
            ));
        }

        return stringformat(
        "{{\n"
        "    std::string fruitbat = stringformat(\"{}{}\", {});\n"
        "    {}\n"
        "}\n",
        jempl_name.val(),
        "{}",    // format for the variant.val() when expanding template
        variant.val(), // code for the variant.val()
        join(cases, " else ")
        );


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_18(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_args,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_name,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_18";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 5;
            }
            static int num_params() {
                return 2;
            }
            static int line_number() {
                return 106;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:106";
            }
            static const char *to_str() {
                return "subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_args"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_name"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 2) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:106";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 2) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:106"
                    );
                }
            }
        } this_rule;



        // subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 113 "src/jemplpl/jemplpl.fpl"

        add_import(jempl.import_path.find(jempl_name.val() + ".h.jemp"));
        return stringformat("\nout += {}{};\n", jempl_name.val(), jempl_args.val());


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_19(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> control_statement,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_19";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 118;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:118";
            }
            static const char *to_str() {
                return "subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "control_statement"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:118";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:118"
                    );
                }
            }
        } this_rule;



        // subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 142 "src/jemplpl/jemplpl.fpl"

        return line_num(control_statement.self())
        + jempl.realign_frag()
        + control_statement.val().to_str();


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_20(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> variable,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_20";
            }
            static const char *product() {
                return "fragment";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 123;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:123";
            }
            static const char *to_str() {
                return "subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variable"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:123";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:123"
                    );
                }
            }
        } this_rule;



        // subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 149 "src/jemplpl/jemplpl.fpl"

        return line_num(variable.self())
        + "out += stringformat(\"{}\"," + variable.val().to_str() + ");\n";


        #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_21(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> t,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_21";
            }
            static const char *product() {
                return "text";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 127;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:127";
            }
            static const char *to_str() {
                return "/[^@\\\\n]+/:t -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "t"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:127";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:127"
                    );
                }
            }
        } this_rule;



        // /[^@\\n]+/:t -> text

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:127 (default action for /[^@\\\\n]+/:t -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        t.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_22(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> leading_ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_22";
            }
            static const char *product() {
                return "text";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 131;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:131";
            }
            static const char *to_str() {
                return "leading_ws -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "leading_ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:131";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:131"
                    );
                }
            }
        } this_rule;



        // leading_ws -> text

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:131 (default action for leading_ws -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        leading_ws.val()

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_23(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> trailing_ws,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_23";
            }
            static const char *product() {
                return "text";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 132;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:132";
            }
            static const char *to_str() {
                return "trailing_ws -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "trailing_ws"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:132";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:132"
                    );
                }
            }
        } this_rule;



        // trailing_ws -> text

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:132 (default action for trailing_ws -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        trailing_ws.val()

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_24(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> name,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_24";
            }
            static const char *product() {
                return "identifier";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 135;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:135";
            }
            static const char *to_str() {
                return "/[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "name"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:135";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:135"
                    );
                }
            }
        } this_rule;



        // /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:135 (default action for /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        name.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_25(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> space,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_25";
            }
            static const char *product() {
                return "sp";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 138;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:138";
            }
            static const char *to_str() {
                return "/[ \\\\t]+/:space -> sp";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "space"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:138";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    ""

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/grammarlib/jemp.fpl:138"
                    );
                }
            }
        } this_rule;



        // /[ \\t]+/:space -> sp

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:138 (default action for /[ \\\\t]+/:space -> sp)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        space.val().to_str()

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_26(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> complete,

    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    bool dummy = true // hack for comma
    ) {

        #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_26";
            }
            static const char *product() {
                return "_fpl_goal";
            }
            static const char *product_type() {
                return "std::string";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 4299;
            }
            static const char *filename() {
                return "src/fpl2cc/productions.h";
            }
            static const char *location() {
                return "src/fpl2cc/productions.h:4299";
            }
            static const char *to_str() {
                return "complete -> _fpl_goal";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "complete"

                    #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/fpl2cc/productions.h:4299";
                }
            }
            static const char *param_type(unsigned int ind) {
                static const char *ptype[] = {

                    #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "std::string"

                    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return ptype[ind];
                } else {
                    return (
                    "param_type index out of bounds at "
                    "src/fpl2cc/productions.h:4299"
                    );
                }
            }
        } this_rule;



        // complete -> _fpl_goal

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/fpl2cc/productions.h:4299 (default action for complete -> _fpl_goal)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
        return std::string(

        #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        complete.val()

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1350 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1351 "src/fpl2cc/fpl_x_parser.h.jemp" 



};

#endif // header guard


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 

int main(int argc, const char **argv) {

    #line 244 "src/jemplpl/jemplpl.fpl"

    if(argc < 2) {
        jerror::error("Please provide a source file name.\n");
    }

    std::list<std::filesystem::path> templates_to_expand;
    for(int argi = 1; argi < argc; argi++) {
        templates_to_expand.push_back(argv[1]);
    }

    std::list<std::string> generated_code;
    std::set<std::filesystem::path> already_expanded;
    int total_errors = 0;
    for(auto template_fn : templates_to_expand) {
        if(already_expanded.count(template_fn)) {
            continue;
        }
        already_expanded.insert(template_fn);
        fpl_reader_p inp = std::make_shared<fpl_reader>(template_fn);
        if(!inp) {
            jerror::warning(stringformat(
            "failed to create reader for {}",
            std::filesystem::absolute(template_fn).string()
            ));
            total_errors++;
        } else {
            jemplpl_parser parser(inp);
            parser.init(template_fn);
            std::string output = parser.parse();
            if(!output.length()) {
                jerror::warning(stringformat(
                "no output generated for '{}'\n", template_fn
                ));
                total_errors++;
            } else {
                // prepend the generated code so that function definitions
                // from imported jemps come before where they are used:
                generated_code.push_front(output);
                std::cout << parser.output_header(argv[0], template_fn);

                // now, if that imported anything, we'll want to try
                // to pull in the import...
                for(auto imp: parser.jempl.import_files) {
                    templates_to_expand.push_back(imp);
                }
            }
            total_errors += parser.error_count();
        }
    }

    std::cout << join(generated_code, "\n\n");

    return total_errors?1:0;

    #line 19961 "src/jemplpl/jemplpl.cc"

}

#line 1364 "src/fpl2cc/fpl_x_parser.h.jemp" 



