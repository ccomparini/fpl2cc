
#line 4 "src/fpl2cc/fpl_x_parser.h.jemp" 

#ifndef jemplpl_parser_H
#define jemplpl_parser_H

/*
  generated by fpl2cc v1.2 from src/fpl2cc/fpl_x_parser.h.jemp

  options:
        src_fpl: src/jemplpl/jemplpl.fpl
    src_path: /Users/chris/projects/jest2/src/grammarlib
    out: 
    output_fn: src/jemplpl/jemplpl.cc
    check_only: false
    debug: false
    debug_types: false
    entry_points: (missing arg 0)
    generate_code: true
    generate_main: false
    help: false
    single_step: false
    depfile: 
    statedump: src/jemplpl/jemplpl.states
    dump_dependencies: false
    lr_stack_reserve: 1000
    param_stack_reserve: 1000
    new_parser: false


  calculated goal(s):
    { complete }

 */

//  elements:
//    _fpl_null
//    fragment
//    complete
//    text
//    '@@'
//    '@/*'
//    /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
//    '*/@'
//    /\\n\?/
//    '@parameter:'
//    /[^@]+/
//    '@'
//    leading_ws
//    /@declare\\s+/
//    identifier
//    ':'
//    /(\?:[^@]|(\?:@@))*/
//    /@realign:\\s*/
//    '#'
//    !'#'
//    template_variant
//    '@-'
//    subst_start
//    '-@'
//    trailing_ws
//    subst_end
//    /(\?:[^-@]|-[^@])+/
//    rest_of_sub
//    /\\n*[ \\t]+/
//    /[ \\t]*\\n+[ \\t]+(\?!@)/
//    /[ \\t]*\\n/
//    /#\\s*/
//    /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/
//    /[^@\\n]+/
//    /[a-zA-Z_][a-zA-Z_0-9]+/
//    /[ \\t]+/
//    sp
//    ␄_fpl_goal

//  rules:
//     fragment+:fragments -> complete
//    text+:chunks -> fragment
//    '@@':at_sign -> text
//    '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment
//    '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment
//    leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment
//    /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment
//    '#'^ !'#':variant_expression '#'^ -> template_variant
//    leading_ws?^ '@-':arg_1 -> subst_start
//    '@':arg_0 -> subst_start
//    '-@':arg_0 trailing_ws?^ -> subst_end
//    '@':arg_0 -> subst_end
//    /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub
//    /\\n*[ \\t]+/:ws -> leading_ws
//    /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws
//    /[ \\t]*\\n/:ws -> trailing_ws
//    subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment
//    subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment
//    /[^@\\n]+/:t -> text
//    leading_ws -> text
//    trailing_ws -> text
//    /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier
//    /[ \\t]+/:space -> sp
//    complete -> _fpl_goal


#line 26 "src/fpl2cc/fpl_x_parser.h.jemp" 


#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>

#include "fpl2cc/fpl_reader.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"


#line 46 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 47 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1 "src/jemplpl/jemplpl.fpl"

/*

 jemplpl - .jemp to c++ converter.

 Given one or more template files, creates corresponding c++ functions
 white return strings containing filled-in copies of said templates,
 and writes them to stdout.

 */

#include <filesystem>
#include <iostream>
#include <list>
#include <set>
#include <string>

#include "fpl2cc/fpl_reader.h"
#include "util/c_str_escape.h"
#include "util/jerror.h"
#include "util/join.h"
#include "util/searchpath.h"
#include "util/stringformat.h"

#define VERSION_MAJ 0
#define VERSION_MIN 8


#line 160 "src/jemplpl/jemplpl.cc"


#line 49 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 50 "src/fpl2cc/fpl_x_parser.h.jemp" 


class jemplpl_parser {

    public:

    #line 55 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser.h.jemp" 

    private:

    // If some poor hapless fpl author should happen to try
    // to use a non-copy-constructable type in some way that
    // it lands in the variant (below), they will be rewarded
    // by their c++ compiler with about 23k lines of "note:"
    // gibberish about every possible constructor in the
    // standard libraries.  To avoid this, and to give a non-0
    // chance at a useful error message, we do this lame hack
    // of creating a static function whose only reason for
    // existence is to give a scope to static_asserts:
    static void check_copy() {

        #line 72 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {

            #line 74 "src/fpl2cc/fpl_x_parser.h.jemp" 
            const bool copyable = std::is_copy_constructible<std::string>::value;
            static_assert(copyable, "std::string is not copy constructable");
        }

        #line 81 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    public:
    void state(); // this just facilitates the "using State"
    using State = decltype(&jemplpl_parser::state);

    class Terminal {
        // the first string in "matches" is the entire terminal match
        // and will exist for exact matches as well as regex matches.
        // subsequent matches are used for capture groups in a regex
        // match.
        std::vector<std::string> matches;
        public:

        Terminal() { } // false valued terminal

        Terminal(const std::string &src) {
            matches.push_back(src);
        }

        // this prevents stuff like Terminal("foo") from matching
        // the Iterable one, below
        Terminal(const char *src) {
            matches.push_back(std::string(src));
        }

        // this is so that bool "just works" in return values from
        // custom scanners
        Terminal(bool matched) {
            if(matched) matches.push_back("");
        }

        template<typename Iter>
        Terminal(Iter begin, Iter end) : matches(begin, end) {
        }

        template<typename Iterable>
        Terminal(const Iterable &src) : matches(src.begin(), src.end()) {
        }

        std::string to_str() const {
            if(matches.size())
            return matches[0];
            return "";
        }

        // returns a string containing the contents of the regex capture
        // group indicated by the index passed.
        // for example, if the regex /(.)y(.*)/ matched the string "dyad",
        // capgroup(0) would be "d" and capgroup(1) would be "ad".
        // default is the 0th capgroup.
        // returns the empty string for any non-existent capture groups.
        std::string capgroup(int capi = 0) const {
            if(capi + 1 < matches.size()) {
                return matches[capi + 1];
            }
            return "";
        }

        int num_capgroups() const {
            return matches.size() - 1;
        }

        operator bool() const {
            return matches.size() > 0;
        }

        operator std::string() const { return to_str(); }

        std::string operator+(const std::string & rhs) const {
            return to_str() + rhs;
        }

        friend bool operator==(const Terminal &lhs, const char *rhs) {
            return lhs.to_str() == rhs;
        }

        friend bool operator==(const char *lhs, const Terminal &rhs) {
            return lhs == rhs.to_str();
        }

    };


    #line 2 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"


    #line 4 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"




    class Product {
        struct false_product { };

        // this is the "product" we make everything produce for
        // the --check-only option.  It can be constructed from
        // anything, so that it can drop into any arbitrary rule.
        struct check_only {
            operator bool() const { return true; }
            std::string to_str() const {
                return "«dummy»";
            }

            // (construct from any set of arguments)
            template <typename... Args>
            check_only(Args&&... args) { }
        };

        // different fpl rules may or may not evaluate to different
        // types, so we use a std::variant:
        using Var = std::variant<
        false_product,

        #line 188 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string,

        #line 190 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal
        >;

        Var red;

        public:
        // creates a false-valued Product:
        Product() : red(false_product()) { }

        Product(Terminal tm) : red(tm) { }

        // type-specific constructors:

        #line 203 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Product(std::string result) : red(result) { }

        #line 205 "src/fpl2cc/fpl_x_parser.h.jemp" 
        const Var &var() const { return red; }

        // Accessors for the different types are named as [element name]_val()
        // We start at type 1 instead of 0 because we don't need/want an
        // fpl_null accessor (it has no type anyway)

        #line 212 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _fragment_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _complete_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _text_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_4_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_5_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_6_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_7_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_8_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_9_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_10_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_11_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _leading_ws_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_13_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _identifier_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_15_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_16_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_17_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_18_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_19_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _template_variant_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_21_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _subst_start_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_23_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _trailing_ws_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _subst_end_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_26_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _rest_of_sub_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_28_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_29_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_30_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_31_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_32_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_33_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_34_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_35_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        std::string _sp_val() const { return std::get<std::string>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        Terminal _terminal_37_val() const { return std::get<Terminal>(var()); }

        #line 217 "src/fpl2cc/fpl_x_parser.h.jemp" 
        operator bool() const {
            return !std::holds_alternative<false_product>(red);
        }

        std::string type_name() const {
            if(std::holds_alternative<false_product>(red))
            return "<no type>";

            if(std::holds_alternative<Terminal>(red))
            return "Terminal";


            #line 230 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<std::string>(red))
            return "std::string";

            #line 233 "src/fpl2cc/fpl_x_parser.h.jemp" 
            // can't get here?
            jerror::error("Unknown type for product");
            return "unknown type";
        }

        std::string var_str() const {
            if(std::holds_alternative<false_product>(red))
            return "<null product>";

            if(std::holds_alternative<Terminal>(var()))
            return stringformat("{}", std::get<Terminal>(var()));


            #line 246 "src/fpl2cc/fpl_x_parser.h.jemp" 
            if(std::holds_alternative<std::string>(var())) {

                #line 248 "src/fpl2cc/fpl_x_parser.h.jemp" 
                return stringformat("{}", std::get<std::string>(var()));
            }

            #line 252 "src/fpl2cc/fpl_x_parser.h.jemp" 


            jerror::error("Unknown type for product");
            return "unknown type";
        }

        // this is for debug and similar:
        std::string to_str() const {
            std::string out;
            return stringformat("{} «{}»", type_name(), var_str());
        }

        // phase out if possible, because this only supports the
        // top output_type() and that's wacky.
        std::string val(const std::string &caller = CALLER()) const {
            if(!std::holds_alternative<std::string>(red)) {
                std::string dummy;
                return dummy;
            }
            return std::get<std::string>(red);
        }

        // if it's a (regex) terminal with capture groups, this returns
        // the contents of the nth capgroup.  otherwise, returns an
        // empty string.
        std::string capgroup(int capi) const {
            if(std::holds_alternative<Terminal>(red))
            return std::get<Terminal>(red).capgroup(capi);
            return "";
        }
    };

    // This is an lr stack entry (as opposed to a param stack entry).
    // In the new dual stack scheme, you would use one of these to
    // refer to the param stack, however.
    struct StackEntry {
        State          state;
        int            element_id;
        SourcePosition pos;        // start of match in source code
        int            param_ind;  // offset in param_stack
        bool           eject;
        bool           mismatch;

        StackEntry(State st, int el_id, SourcePosition p, int pind, bool ej) :
        state(st),
        element_id(el_id),
        pos(p),
        param_ind(pind),
        eject(ej),
        mismatch(false) {
        }

        // creates a "false" stack entry:
        StackEntry() :
        state(NULL),
        element_id(-1),
        param_ind(-1),
        eject(true),
        mismatch(false) {
        }

        StackEntry(const StackEntry &) = default;

        operator bool() const {
            return element_id > 0; // (null/invalid element id -> false)
        }

        int grammar_element_id() const {
            return element_id;
        }

        bool ejected() const {
            return eject;
        }

        SourcePosition position() const {
            return pos;
        }

        int line_number() const {
            return position().line_number();
        }

        std::string filename() const {
            return position().filename();
        }

        bool is_nonterminal() const {
            return jemplpl_parser::is_nonterminal(element_id);
        }

        // Returns the first Product corresponding to this
        // StackEntry, if there is one.  Otherwise, returns
        // a false Product.
        Product product(const jemplpl_parser &owner) const {
            if(param_ind >= 0 && param_ind < owner.param_stack.size()) {
                return owner.param_stack[param_ind];
            }
            return Product();
        }

        std::string to_str() const {
            return stringformat("{}{} {} param[{}] ({})",
            mismatch?"⏮ ":"",
            state_to_str(state),
            element_str(element_id),
            param_ind,  // need the owner to get the product
            position()
            );
        }
    };

    // Pushes an element to the lr and/or parameter stacks as appropriate.
    // "ejected" elements (those marked with a '^' in fpl source) are
    // not pushed to the param stack.  Redundant lr_stack entries may or
    // may not actually be pushed.  (in the current implementation, they
    // are pushed, but that might not pertain in the future)
    void lr_push(
    int element_id, bool eject, const SourcePosition &pos, Product pr
    ) {
        lr_stack.push_back(StackEntry(
        cur_state, element_id, pos, param_stack.size(), eject
        ));

        if(!eject) {
            param_stack.push_back(pr);
        }
    }

    private:
    fpl_reader_p            reader;      // (must be non-null)
    State                   cur_state;
    std::vector<StackEntry> lr_stack;
    int                     lr_read_pos;
    std::vector<Product>    param_stack;
    size_t                  bytes_eaten; // since last terminal
    bool                    stop_parsing;
    int                     max_errors;
    int                     num_errors;

    bool                    single_step; // debugging

    // this is called when something appears to have
    // gone wrong due to a bug in the parser itself:
    void internal_error(const std::string &msg) {
        error(stringformat(
        "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
        ));
        terminate();
    }

    public:
    // constructors:
    jemplpl_parser(const jemplpl_parser &rhs) = delete;

    jemplpl_parser(fpl_reader_p rdr) :
    reader(rdr),
    cur_state(&jemplpl_parser::state_0),
    lr_read_pos(0),
    bytes_eaten(0),
    stop_parsing(false),
    max_errors(1),
    num_errors(0),
    single_step(false) {


        #line 417 "src/fpl2cc/fpl_x_parser.h.jemp" 


        lr_stack.reserve(1000);
        param_stack.reserve(1000);
    }

    // debugging:
    void set_single_step(bool newval) { single_step = newval; }
    void debug_pause() {
        int inch;
        if(single_step)
        inch = getchar();
        if(inch == 'c')
        single_step = false;
    }

    void set_max_errors(int newmax) { max_errors = newmax; }

    void error(size_t pos, const std::string &msg) {
        std::string full_msg = reader->format_error_message(pos, msg);
        fputs(full_msg.c_str(), stderr);
        if(++num_errors >= max_errors) {
            fputs("too many errors.  aborting\n", stderr);
            terminate();
        }
    }

    void error(const std::string &msg) {
        error(reader->current_position(), msg);
    }

    int error_count() const { return num_errors; }

    bool eof() const {
        return reader->eof();
    }

    public:

    std::string filename() const {
        return reader->filename();
    }

    int line_number() const {
        return reader->line_number();
    }

    int line_number(size_t pos) const {
        return reader->line_number(pos);
    }

    SourcePosition position() const {
        return SourcePosition(reader);
    }

    fpl_reader_p_c const_reader() const {
        return reader;
    }

    int param_stack_size() const {
        return param_stack.size();
    }

    int lr_stack_size() const {
        return lr_stack.size();
    }

    int lr_top_index() const {
        return lr_stack.size() - 1;
    }

    void lr_pop() {
        if(lr_stack.size() > 0) {
            auto popped = lr_stack.back();
            cur_state = popped.state;
            if(popped.param_ind >= 0) {
                param_stack.resize(popped.param_ind);
            }
            lr_stack.pop_back();
        }

        if(lr_stack.size() == 0) {
            // else there's nothing left to pop on the lr_stack,
            // and the param stack had better be clear, too, or
            // something is wrong:
            if(param_stack.size() > 0) {
                jerror::warning(stringformat(
                "popping from empty lr_stack, but there are {} params\n",
                param_stack.size()
                ));
            }
        }
    }

    // "pops" and discards down to the new maximum index
    // specified
    void lr_pop_to(int new_max) {
        while(lr_top_index() > new_max) {
            lr_pop();
        }
    }

    void clear_mismatches() {
        int num_cleared = 0;
        while(lr_top().mismatch) {
            lr_pop();
            num_cleared++;
        }

        if(lr_read_pos > lr_top_index()) {
            lr_read_pos -= num_cleared;
        }
    }

    StackEntry lr_stack_entry(int pos) const {
        // (as usual, negative positions are relative to the top of stack)
        if(pos < 0) pos += lr_stack_size();

        if((pos >= 0) && (pos < lr_stack_size())) {
            return lr_stack[pos];
        } else {
            return StackEntry();
        }
    }

    StackEntry lr_next() const {
        return lr_stack_entry(lr_read_pos);
    }

    StackEntry lr_prev() const {
        return lr_stack_entry(lr_read_pos - 1);
    }

    StackEntry lr_top() const {
        return lr_stack_entry(lr_top_index());
    }

    // Increments the lr read pointer and returns true if the element ID
    // passed matches the next item to read from the lr stack.  Otherwise,
    // returns false.
    bool lr_read(int element_id) {
        if(element_id == lr_next().element_id) {
            // we may be skipping a known mismatch, in which case
            // we'll return false since it's not a correct match.
            bool mismatch = lr_next().mismatch;
            if(mismatch) {

                #line 565 "src/fpl2cc/fpl_x_parser.h.jemp" 

            }

            lr_read_pos++;
            return !mismatch;
        }
        return false;
    }

    // lr_position_before_xxx(pos, multiple):  Each returns the
    // first position before pos in the lr stack which does not
    // match the element ID in question. If pos is past the top
    // of the stack, starts at the top of the stack.
    // Recurses on subexpressions.  Always skips mismatches.
    //
    // These are used to put together the arguments for reduce
    // actions.

    #line 587 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before___fpl_null(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // _fpl_null
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 0) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__fragment(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // fragment
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 1) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__complete(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // complete
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 2) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__text(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // text
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 3) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_4(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 4) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_5(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@/*'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 5) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_6(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 6) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_7(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '*/@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 7) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_8(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /\\n\?/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 8) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_9(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@parameter:'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 9) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_10(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[^@]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 10) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_11(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 11) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__leading_ws(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // leading_ws
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 12) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_13(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /@declare\\s+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 13) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__identifier(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // identifier
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 14) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_15(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // ':'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 15) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_16(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^@]|(\?:@@))*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 16) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_17(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /@realign:\\s*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 17) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_18(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '#'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 18) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_19(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // !'#'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 19) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__template_variant(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // template_variant
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 20) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_21(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '@-'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 21) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__subst_start(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // subst_start
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 22) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_23(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // '-@'
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 23) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__trailing_ws(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // trailing_ws
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 24) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__subst_end(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // subst_end
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 25) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_26(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^-@]|-[^@])+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 26) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__rest_of_sub(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // rest_of_sub
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 27) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_28(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /\\n*[ \\t]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 28) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_29(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]*\\n+[ \\t]+(\?!@)/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 29) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_30(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]*\\n/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 30) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_31(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /#\\s*/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 31) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_32(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 32) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_33(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[^@\\n]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 33) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_34(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[a-zA-Z_][a-zA-Z_0-9]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 34) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_35(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // /[ \\t]+/
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 35) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__sp(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // sp
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 36) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_position_before__terminal_37(int pos, bool multiple) const {

        if(pos > lr_top_index())
        pos = lr_top_index();


        #line 596 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // ␄_fpl_goal
        // (checking pos >= 0 because negative indexes are relative
        // to end of stack)
        while(pos >= 0 && lr_stack_entry(pos).element_id == 37) {
            --pos;
            if(!multiple)
            break;
        }

        #line 605 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return pos;
    }

    #line 633 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // lr_count_of_X(pos, multiple):  returns the number of
    // stack entries matching X going forward through the lr stack,
    // starting at the position passed.   If argument "multiple"
    // is false, only counts up to one entry.

    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of___fpl_null(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 0) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__fragment(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 1) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__complete(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 2) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__text(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 3) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_4(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 4) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_5(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 5) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_6(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 6) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_7(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 7) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_8(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 8) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_9(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 9) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_10(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 10) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_11(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 11) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__leading_ws(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 12) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_13(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 13) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__identifier(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 14) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_15(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 15) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_16(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 16) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_17(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 17) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_18(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 18) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_19(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 19) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__template_variant(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 20) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_21(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 21) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__subst_start(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 22) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_23(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 23) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__trailing_ws(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 24) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__subst_end(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 25) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_26(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 26) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__rest_of_sub(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 27) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_28(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 28) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_29(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 29) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_30(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 30) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_31(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 31) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_32(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 32) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_33(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 33) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_34(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 34) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_35(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 35) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__sp(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 36) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 
    int lr_count_of__terminal_37(int pos, bool multiple) const {
        int size = 0;

        #line 645 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // normal case - not a subexpression
        while(lr_stack_entry(pos + size).element_id == 37) {
            ++size;
            if(!multiple)
            break;
        }

        #line 652 "src/fpl2cc/fpl_x_parser.h.jemp" 


        return size;
    }

    #line 688 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // A StackSlice here is a set of 0 or more consecutive lr_stack
    // entries. It's used to represent the match(es) which went into
    // 1 particular step (see ReductionParameter, below), or the set
    // of all steps which led to a current rule match (see
    // all_matched_steps(), below), or any other slice of the lr_stack.
    class StackSlice {
        int base_index; // in lr_stack
        int size;       // number of elements in lr_stack

        // owner here is annoying because we should be able to
        // infer it... jest feature?
        const jemplpl_parser &owner;

        public:
        // Returns the number of lr_stack entries in this slice:
        int count() const { return size; }

        // Returns the number of parameter stack entries for this
        // entire slice.  This can be different from the number of
        // lr_stack entries due to ejectedness (in which case
        // there are 0 parameters) as well stuff like repetition.
        int param_count() const {
            StackEntry sel = owner.lr_stack_entry(base_index);

            // no params if we're an empty slice.
            // without this check, we can end up returning a
            // negative size, and no one wants that.
            if(count() == 0) return 0;


            // this slice "contains" all arguments starting
            // at the position in the argument stack starting
            // at the argument from the base element and going
            // to just before the one for the base element of
            // the slice above us, or the top of the argument
            // stack if we're the topmost slice
            int cap_ind = base_index + size;
            if(cap_ind < owner.lr_stack_size()) {
                StackEntry eel = owner.lr_stack_entry(cap_ind);
                return eel.param_ind - sel.param_ind;
            } else {
                // goes to the end of the arg stack:
                return owner.param_stack_size() - sel.param_ind;
            }
        }

        // returns the corresponding base in the param stack
        // or -1 if there is no such thing.
        int param_base() const {
            return owner.lr_stack_entry(base_index).param_ind;
        }

        // construct a slice with a particular base and count.
        // if the count is -1 or unspecified, construct a slice
        // with the given base to the top of the stack
        StackSlice(const jemplpl_parser &o, int base, int count = -1) :
        base_index(base),
        size(count),
        owner(o)
        {
            if(size == -1) {
                size = owner.lr_stack.size() - base;
            }
        }

        // Negative indexes are offset from a hypothetical argument
        // just past the end of the slice (i.e. -1 means end-of-slice).
        // Accessing to entries outside the slice yields a "false"
        // stack entry.
        StackEntry operator [](int ind) const {
            if(ind < 0) ind += size; // allow negative indexes

            int off = ind + base_index;
            if((off < owner.lr_stack_size()) && (off >= 0)) {
                return owner.lr_stack[off];
            } else {
                return StackEntry();
            }
        }

        // Returns the nth "product" (from the argument stack)
        // corresponding to this slice.
        // If the index passed is out of bounds, returns a 
        // default product.
        // Note that there may be 0 products for any slice,
        // so the 0th is not guaranteed to be anything real,
        // though if it's not it will still return a valid
        // (though false) Product,
        Product product(int ind = 0, src_location caller = CALLER()) const {
            const int pbase = param_base();
            const int num_args = param_count();
            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind >= 0) && (ind < num_args)) {
                unsigned int sind = pbase + ind;
                return owner.param_stack_entry(sind, caller);
            } else {
                return Product();
            }
        }

        std::string to_str() const {
            std::string out;
            for(int ind = 0; ind < size; ++ind) {
                out += stringformat("    {}\n", owner.lr_stack[ind]);
            }
            return out;
        }
    };

    // Call this within a reduce function to get a stack slice containing
    // all the steps (StackEntries) for the matched rule.
    // Don't call from outside a reduce function.
    //  hey..... uhh... is this misnamed?  I think it doesn't include
    //  -actually- ejected steps.  errf.  but it's not all params either
    //  because if there's an eject/keep conflict we'll keep the param
    //  here, whether or not this action considers it a parameter.
    StackSlice all_matched_steps() {
        return StackSlice(*this, lr_read_pos);
    }

    // call this like:  prod_type_name(typeid(...));
    static std::string prod_type_name(const std::type_info &tinf) {

        #line 813 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(std::type_index(typeid(std::string)) == std::type_index(tinf)) {
            return "std::string";
        }

        #line 817 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }
        if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
            return "Product";
        }
        return "unknown type in prod_type_name";
    }

    // This represents the argument for a given step, which should be one
    // lr stack entry plus a (possibly 0-sized) slice of the param stack
    template<typename ReduceType>
    class ReductionParameter {
        // all access to param and lr stacks go through this:
        StackSlice lr_slice;

        public:
        ReductionParameter(jemplpl_parser &o, int lr_base, int lr_count) :
        lr_slice(o, lr_base, lr_count) { }

        // returns the number of param_stack entries in this:
        int count() const { return lr_slice.param_count(); }

        // (syntactic sugar for optionals)
        bool exists() const { return count() !=  0; }

        SourcePosition position() const {
            return lr_slice[0].position();
        }

        SourcePosition end_position() const {
            return lr_slice[-1].position();
        }

        // this allows you to refer to the stack slice itself from within
        // reduce functions using the at sign (eg thing@self())
        ReductionParameter<ReduceType> self() { return *this; }

        // in reduce code, this is accessed via [] or (for the 0th element)
        // just the name of the variable itself.
        const ReduceType val(int ind = 0, src_location ca = CALLER()) const {
            const int num_args = count();

            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind < 0) || (ind >= num_args)) {
                jerror::warning(stringformat(
                "Index {} out of range ({} items) at {}",
                ind, num_args, ca
                ));

                // try to return a default item of the ReduceType.
                // this may or may not be possible, depending on the
                // type, but it's better than crashing.
                // ACTUALLY let's just say it's a requirement that
                // the reduce type must be default constructible. shipit.
                // move on.
                return ReduceType();
            }

            return std::get<ReduceType>(
            lr_slice.product(ind, ca).var()
            );
        }

        static std::string type_name() {
            return prod_type_name(typeid(ReduceType));
        }

        std::string concatenate() const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
            }
            return out;
        }


        #line 895 "src/fpl2cc/fpl_x_parser.h.jemp" 
        using ForeachFunc = std::function<void(const ReduceType &)>;
        void foreach(ForeachFunc func) const {
            for(int ind = 0; ind < count(); ++ind) {
                func(val(ind));
            }
        }

        std::string join(const std::string &jv) const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                if(ind < count() - 1)
                out += stringformat("{}{}", val(ind), jv);
                else // last element
                out += stringformat("{}", val(ind));
            }
            return out;
        }

        inline std::string to_str() const {
            // XXX do something smarter here
            return lr_slice.to_str();
        }
    };

    void set_state(State st) {
        cur_state = st;
    }

    Product param_stack_entry(int pos, src_location caller = CALLER()) const {
        // this is very similar to lr_stack_entry.  generalize?
        if((pos >= 0) && (pos < param_stack.size())) {
            return param_stack[pos];
        } else {
            jerror::warning(stringformat(
            "param stack access out of range ({}/{}) at {}",
            pos, param_stack.size(), caller
            ));
            return Product();
        }
    }

    State current_state() const {
        return cur_state;
    }

    // this is more or less debugging
    std::string to_str() const {
        std::string out;

        out += stringformat(
        "next up (lr pos {}): {}\n", lr_read_pos, next_up_str()
        );
        out += stringformat(
        "{} bytes of separator since last terminal\n", bytes_eaten
        );
        out += stringformat("lr stack ({} items):\n", lr_stack.size());
        for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
            " {} [{}] {}\n",
            sind == lr_read_pos?"->":"  ", sind, lr_stack_entry(sind)
            );
        }
        out += stringformat("param stack ({} items):\n", param_stack.size());
        for(int sind = param_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
            "    [{}] {::n}\n", sind, param_stack_entry(sind)
            );
        }
        return out;
    }

    Product result() const {
        // (... possibly we should only consider it a result if there's
        // exactly one item on the stack.  could simplify callers)
        return lr_top().product(*this);
    }

    int result_product_id() const {
        return lr_top().element_id;
    }

    // mismatch() begins or continues the backtracking process when
    // a state hits unexpected input.
    void mismatch() {
        // move the lr read pointer to before the last bad push:
        while(lr_stack_entry(--lr_read_pos).mismatch)
        ;

        if(lr_read_pos < 0) {
            lr_read_pos = 0;
            // can't go back any more, so terminate:
            terminate();
        } else {
            // mark whatever was there as a mismatch, and try that
            // state again:
            StackEntry &bad_entry = lr_stack[lr_read_pos];
            bad_entry.mismatch = true;
            cur_state = bad_entry.state;
            reader->go_to(bad_entry.position());
        }
    }

    void terminate() {
        stop_parsing = true;
    }

    // Removes terminals from the top of the lr stack and sets
    // the source read position to the start of the removed
    // terminals.
    // This is used after termination to unwind such that the
    // read position is just after the last successfully parsed
    // thing instead of potentially being after some recognized
    // but unused terminals, thus setting the read pointer to
    // the start of any unrecognized input.
    void rewind_to_nonterm() {
        if(result())
        return; // already after last nonterminal

        size_t rewind_to = reader->current_position();
        while(lr_stack.size() > 0) {
            auto last = lr_stack.back();
            if(last.is_nonterminal()) {
                break;
            }
            rewind_to = last.position();
            lr_pop();
        }
        reader->go_to(rewind_to);
    }

    // Returns a string with either the next bit of text
    // (in French quotes) or the next production
    std::string next_up_str() const {
        if(StackEntry next = lr_next()) {
            return stringformat(
            "{} = {::n}",
            element_str(next.element_id), next.product(*this)
            );
        } else {
            return stringformat(
            "«{}» ({}:{::n})",
            reader->debug_peek(32),
            reader->filename(), reader->current_position()
            );
        }
    }

    // not passing by reference here - instead, crossing fingers
    // and hoping it really just gets inlined.
    inline void post_parse(std::string result) {

        #line 1057 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    bool more_to_parse() const {
        // there's more to parse if:
        //  - we haven't been told to stop (due to matching _fpl_goal,
        //    or errors, or whatever)
        //  - and there's more input -or- we're not at the goal
        return !stop_parsing
        && ((!eof() || lr_stack.size() > 1) || !result_is_goal());
    }

    // resets the state of the parser, discarding anything on
    // the stack.
    // does _not_ reset the input position, so as to allow
    // mixed-parser parses.
    void reset() {

        #line 1076 "src/fpl2cc/fpl_x_parser.h.jemp" 

        lr_stack.clear();
        lr_read_pos      = 0;
        param_stack.clear();
        set_state(&jemplpl_parser::state_0);
        bytes_eaten      = 0;
        stop_parsing     = false;
        num_errors       = 0;
    }

    // In an fpl parser, we do not want to require that the whole
    // input has been consumed.  This allows piecewise parsing.
    // For example, a top down parser can invoke an fpl parser
    // to handle some class of expressions, receive the result,
    // and then continue parsing whatever it was parsing.  Or,
    // let's say you're parsing a stream of input, and you want
    // to parse it as it comes in instead of all at once after
    // getting the entire thing.
    //
    // So, this parses as much as it can, then leaves the parser
    // as intact as possible so that the caller can examine it
    // for errors or whatever and decide what to do.
    //
    void parse_partial() {
        do {
            State st = current_state();
            (this->*st)();
        } while(more_to_parse());
    }

    // Attempts to parse a goal from the current input.
    // If we didn't parse a goal, input remains at the
    // position from the start of parse.
    // Any additional input after the goal is left and may be
    // parsed with additional passes of this or another parser.
    // If it parsed a goal product, that product will be returned.
    // Otherwise, returns a false product.
    const Product parse_goal() {
        reset();
        parse_partial();
        rewind_to_nonterm();
        if(result_is_goal()) {
            return result();
        }
        return Product();
    }

    // Returns a string containing a list of possible terminals
    // when in the state passed.  Used for error messages.
    static std::string expected_terminals(State st) {

        #line 1128 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@parameter:', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@/*', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@realign:\\\\s*/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/#\\\\s*/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[a-zA-Z_][a-zA-Z_0-9]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'#', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^-@]|-[^@])+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'-@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "!'#', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'#', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[a-zA-Z_][a-zA-Z_0-9]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "':', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^@]|(\\\?:@@))*/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@parameter:', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@/*', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@-', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@realign:\\\\s*/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/@declare\\\\s+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'*/@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n*[ \\\\t]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[^@\\\\n]+/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/[ \\\\t]*\\\\n/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "'@', "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "/\\\\n\\\?/, "

            #line 1133 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {
            return 
            #line 1131 "src/fpl2cc/fpl_x_parser.h.jemp" 
            "";
        }

        #line 1135 "src/fpl2cc/fpl_x_parser.h.jemp" 

        return "";
    }

    void report_parse_error(const std::string &errm) {
        // at this point, it looks clearest to just pass the
        // error through.  I'm keeping this function as a
        // place to hook counters or whatever, however.
        error(errm);
    }

    // returns a string telling why parse() failed, or
    // an empty string if it appears to have worked
    std::string why_bad_parse() const {
        Product got = result();
        int got_id  = result_product_id();

        // In this case, we're assuming we have the entire input.
        // So, we expect:
        //   - we're at eof (end of input)
        //   - only the result left on the stack
        //   - result is a goal
        if(!eof()) {
            // If we're not at end of input, we stopped when we
            // didn't recognize something.  If there's currently 
            // a "result", that's what was unexpected (i.e. it
            // recognized something, but that something didn't
            // fit the bigger picture).  Otherwise, it means we
            // got some generally unrecognized input:
            std::string prev_str;
            if(StackEntry prev = lr_prev()) {
                prev_str = stringformat(
                " after {} at {}",
                element_str(prev.grammar_element_id()),
                prev.position()
                );
            }
            if(got_id >= 0 && is_nonterminal(got_id)) {
                return stringformat(
                "unexpected element{}: {} ({}).\nso far we have:\n{}",
                prev_str,
                element_str(got_id), got,
                StackSlice(*this, 0)
                //next_up_str()
                );
            } else  {
                return stringformat(
                "unrecognised input{}.  expected one of: {}",
                prev_str,
                expected_terminals(current_state())
                );
            }
        } else if(lr_stack_size() > 1) {
            // If there's extra stuff on the stack after we rewound,
            // it means we recognized more than one component, but
            // nothing complete.
            return "incomplete input";
        } else if(!result_is_goal()) {
            return stringformat(
            "parsed a {} = {}, but that's not a goal ({})",
            element_str(got_id), got, "complete"
            );
        }
        return "";
    }

    // Parses the contents of the current reader.
    // Input contents are assumed to be complete.
    // Calls error() if any parse errors were detected.
    // Returns whatever it got, regardless of errors,
    // which might mean returning a default of whatever
    // the reduce type is.
    std::string parse() {
        // we're parsing from initial state...
        reset();
        parse_partial();

        // consume any additional "separators" (eg whitespace,
        // comments) before checking the parse, since it's
        // going to check eof()
        eat_separator();

        std::string errm = why_bad_parse();
        if(errm.length()) {
            report_parse_error(errm);
        } else {
            post_parse(result().val());
        }

        return result().val();
    }

    private:


    #line 1229 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 145 "src/jemplpl/jemplpl.fpl"


    static inline std::string quote(const std::string &str) {
        return "\"" + c_str_escape(str) + "\"";
    }

    // returns a string containing a c style "#line"
    // line and the code to update the current line number,
    // using the stack slice associated with the fpl
    // reduction code argument passed.
    template<typename SliceType>
    static inline std::string line_num(const SliceType &tokens) {
        auto end_pos = tokens.end_position();
        return stringformat(
        "\n#line {} \"{}\"\n"
        "source.ln = {};\n",
        end_pos.line_number(), end_pos.filename(),
        end_pos.line_number()
        );
    }

    public:

    struct _jempl {
        // for the function we'll create:
        //std::string            function_name;
        std::list<std::string> params;

        std::string realign_fragment;

        Searchpath import_path;
        std::set<std::string> imports;
        std::set<std::filesystem::path> import_files;

        std::string fmt_params() {
            return join(params, ",");
        }

        std::string realign_frag() const {
            return realign_fragment;
        }

    } jempl;

    void init_import_path(const std::filesystem::path &src) {
        jempl.import_path.append(src.parent_path());
        jempl.import_path.append_from_env("JEMP_INCLUDE_PATH");
        jempl.import_path.append_from_env("CPLUS_INCLUDE_PATH");
        jempl.import_path.append_from_env("C_INCLUDE_PATH");
        jempl.import_path.append_from_env("CPATH");
    }


    void add_import(const std::filesystem::path &imp) {
        jempl.import_files.insert(imp);
    }

    std::filesystem::path source_filename() const {
        return reader->filename();
    }

    std::string output_header(
    const std::string prog_name, const std::string src_name
    ) {
        return stringformat(
        "// generated by {} v{}.{}\n"
        "//  source: {}\n",
        prog_name, VERSION_MAJ, VERSION_MIN, src_name
        );
    }

    static std::string function_name(std::filesystem::path src) {
        // remove directories above:
        src = src.filename();

        // remove _all_ extensions from the src path passed.
        // this means foo.h.jemp -> just foo
        while(src.has_extension())
        src = src.stem();

        return src;
    }

    std::string output_function_name() const {
        return function_name(source_filename());
    }

    // XXX wtb way to hav this called from constructor or similar
    void init(const std::filesystem::path &src) {
        init_import_path(src);
        //jempl.function_name = output_function_name(); // XXX just kill function_name
    }

    #line 3658 "src/jemplpl/jemplpl.cc"

    // return to "private" after each such block.
    // this way, authors can add public members
    // to the parser without turning other stuff public 
    private:

    #line 1235 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // custom scanners:

    #line 1238 "src/fpl2cc/fpl_x_parser.h.jemp" 



    #line 1245 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1248 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // _fpl_null
    bool shift_NONTERM_PRODUCTION___fpl_null(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == __fpl_null) {

            return false;
        }

        if(lr_read(__fpl_null)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // fragment
    bool shift_NONTERM_PRODUCTION__fragment(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _fragment) {

            return false;
        }

        if(lr_read(_fragment)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // complete
    bool shift_NONTERM_PRODUCTION__complete(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _complete) {

            return false;
        }

        if(lr_read(_complete)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // text
    bool shift_NONTERM_PRODUCTION__text(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _text) {

            return false;
        }

        if(lr_read(_text)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@@' 
    bool shift_TERM_EXACT__terminal_4(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_4) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_4);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("@@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_4, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_4)) {
                internal_error(stringformat(
                "expected item with id _terminal_4 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@/*' 
    bool shift_TERM_EXACT__terminal_5(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_5) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_5);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("@/*")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@/*");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_5, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_5)) {
                internal_error(stringformat(
                "expected item with id _terminal_5 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/ 
    bool shift_TERM_REGEX__terminal_6(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_6) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_6);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_6, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_6)) {
                internal_error(stringformat(
                "expected item with id _terminal_6 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '*/@' 
    bool shift_TERM_EXACT__terminal_7(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_7) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_7);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("*/@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("*/@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_7, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_7)) {
                internal_error(stringformat(
                "expected item with id _terminal_7 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /\\n\?/ 
    bool shift_TERM_REGEX__terminal_8(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_8) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_8);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("\\n\?");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_8, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_8)) {
                internal_error(stringformat(
                "expected item with id _terminal_8 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@parameter:' 
    bool shift_TERM_EXACT__terminal_9(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_9) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_9);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("@parameter:")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@parameter:");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_9, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_9)) {
                internal_error(stringformat(
                "expected item with id _terminal_9 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[^@]+/ 
    bool shift_TERM_REGEX__terminal_10(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_10) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_10);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[^@]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_10, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_10)) {
                internal_error(stringformat(
                "expected item with id _terminal_10 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@' 
    bool shift_TERM_EXACT__terminal_11(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_11) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_11);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("@")) {
                if(
                reader->read_exact_match("@") ||
                reader->read_exact_match("/*") ||
                reader->read_exact_match("parameter:") ||
                reader->read_exact_match("-") ||
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_11, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_11)) {
                internal_error(stringformat(
                "expected item with id _terminal_11 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // leading_ws
    bool shift_NONTERM_PRODUCTION__leading_ws(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _leading_ws) {

            return false;
        }

        if(lr_read(_leading_ws)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /@declare\\s+/ 
    bool shift_TERM_REGEX__terminal_13(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_13) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_13);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("@declare\\s+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_13, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_13)) {
                internal_error(stringformat(
                "expected item with id _terminal_13 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // identifier
    bool shift_NONTERM_PRODUCTION__identifier(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _identifier) {

            return false;
        }

        if(lr_read(_identifier)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // ':' 
    bool shift_TERM_EXACT__terminal_15(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_15) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_15);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match(":")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal(":");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_15, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_15)) {
                internal_error(stringformat(
                "expected item with id _terminal_15 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^@]|(\?:@@))*/ 
    bool shift_TERM_REGEX__terminal_16(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_16) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_16);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("(\?:[^@]|(\?:@@))*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_16, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_16)) {
                internal_error(stringformat(
                "expected item with id _terminal_16 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /@realign:\\s*/ 
    bool shift_TERM_REGEX__terminal_17(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_17) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_17);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("@realign:\\s*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_17, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_17)) {
                internal_error(stringformat(
                "expected item with id _terminal_17 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '#' 
    bool shift_TERM_EXACT__terminal_18(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_18) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_18);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("#")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("#");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_18, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_18)) {
                internal_error(stringformat(
                "expected item with id _terminal_18 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // !'#' 
    bool shift_TERM_EXACT_INV__terminal_19(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_19) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_19);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            std::string match = reader->read_to_exact_match("#");
            if(match.length())
            result = Terminal(match);


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_19, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_19)) {
                internal_error(stringformat(
                "expected item with id _terminal_19 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // template_variant
    bool shift_NONTERM_PRODUCTION__template_variant(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _template_variant) {

            return false;
        }

        if(lr_read(_template_variant)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '@-' 
    bool shift_TERM_EXACT__terminal_21(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_21) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_21);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("@-")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("@-");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_21, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_21)) {
                internal_error(stringformat(
                "expected item with id _terminal_21 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // subst_start
    bool shift_NONTERM_PRODUCTION__subst_start(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _subst_start) {

            return false;
        }

        if(lr_read(_subst_start)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // '-@' 
    bool shift_TERM_EXACT__terminal_23(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_23) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_23);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            const SourcePosition pos = position();
            if(reader->read_exact_match("-@")) {
                if(
                false
                ) {
                    // though we matched the terminal, it's part of a
                    // longer terminal.  so, cancel the match/rewind:
                    reader->go_to(pos);
                } else {
                    result = Terminal("-@");
                }
            }


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_23, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_23)) {
                internal_error(stringformat(
                "expected item with id _terminal_23 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // trailing_ws
    bool shift_NONTERM_PRODUCTION__trailing_ws(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _trailing_ws) {

            return false;
        }

        if(lr_read(_trailing_ws)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // subst_end
    bool shift_NONTERM_PRODUCTION__subst_end(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _subst_end) {

            return false;
        }

        if(lr_read(_subst_end)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^-@]|-[^@])+/ 
    bool shift_TERM_REGEX__terminal_26(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_26) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_26);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("(\?:[^-@]|-[^@])+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_26, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_26)) {
                internal_error(stringformat(
                "expected item with id _terminal_26 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // rest_of_sub
    bool shift_NONTERM_PRODUCTION__rest_of_sub(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _rest_of_sub) {

            return false;
        }

        if(lr_read(_rest_of_sub)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /\\n*[ \\t]+/ 
    bool shift_TERM_REGEX__terminal_28(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_28) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_28);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("\\n*[ \\t]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_28, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_28)) {
                internal_error(stringformat(
                "expected item with id _terminal_28 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]*\\n+[ \\t]+(\?!@)/ 
    bool shift_TERM_REGEX__terminal_29(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_29) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_29);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[ \\t]*\\n+[ \\t]+(\?!@)");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_29, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_29)) {
                internal_error(stringformat(
                "expected item with id _terminal_29 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]*\\n/ 
    bool shift_TERM_REGEX__terminal_30(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_30) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_30);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[ \\t]*\\n");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_30, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_30)) {
                internal_error(stringformat(
                "expected item with id _terminal_30 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /#\\s*/ 
    bool shift_TERM_REGEX__terminal_31(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_31) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_31);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("#\\s*");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_31, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_31)) {
                internal_error(stringformat(
                "expected item with id _terminal_31 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/ 
    bool shift_TERM_REGEX__terminal_32(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_32) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_32);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_32, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_32)) {
                internal_error(stringformat(
                "expected item with id _terminal_32 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[^@\\n]+/ 
    bool shift_TERM_REGEX__terminal_33(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_33) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_33);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[^@\\n]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_33, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_33)) {
                internal_error(stringformat(
                "expected item with id _terminal_33 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[a-zA-Z_][a-zA-Z_0-9]+/ 
    bool shift_TERM_REGEX__terminal_34(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_34) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_34);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[a-zA-Z_][a-zA-Z_0-9]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_34, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_34)) {
                internal_error(stringformat(
                "expected item with id _terminal_34 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // /[ \\t]+/ 
    bool shift_TERM_REGEX__terminal_35(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_35) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_35);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {



            std::cmatch match = reader->read_re("[ \\t]+");
            if(!match.empty()) {
                if(match.length() || (lr_top().position() != position())) {
                    result = Terminal(match.begin(), match.end());
                }
            }




        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_35, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_35)) {
                internal_error(stringformat(
                "expected item with id _terminal_35 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // sp
    bool shift_NONTERM_PRODUCTION__sp(bool eject) {
        if(lr_next().mismatch && lr_next().element_id == _sp) {

            return false;
        }

        if(lr_read(_sp)) {


            return true;
        }

        return false;
    }



    #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1249 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // (terminals and assertions - everything else)

    #line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


    #line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
    // ␄_fpl_goal 
    bool shift_END_OF_PARSE__terminal_37(bool eject) {
        if(auto next_up = lr_next()) {
            if(next_up.mismatch && next_up.element_id == _terminal_37) {
                // parser has already determined that this element isn't
                // leading to any legitimate production in this context
                // (it's a "mismatch"), so "read" it and return false so
                // that other states/shifts can try to match something
                // else:
                lr_read(_terminal_37);
            }
            // Would this ever be a match?  
            return false;
        }

        const SourcePosition pos = position();

        Terminal result;
        {


            // end of parse placeholder.  can't get here.


        }



        if(result) {
            clear_mismatches();  // (we matched)


            #line 37 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


            lr_push(_terminal_37, eject, pos, Product(result));
            // assertions count as terminals.  therefore, clearing
            // bytes_eaten is (strictly speaking) correct, here.
            // but actually I think it's wrong in cases where
            // there may be more than one consecutive lack-of-separator.
            // also, we really have no idea if a TERM_CUSTOM moved
            // the input pointer or what.
            // possibly a better implementation would be to track
            // the position of the end of the last non-0-length
            // separator.
            bytes_eaten = 0;

            if(!lr_read(_terminal_37)) {
                internal_error(stringformat(
                "expected item with id _terminal_37 but this was next up (at lr {}): {}\n"
                "stack:\n{}\n",
                lr_read_pos, lr_next(),
                lr_stack
                ));
            }

            return true;
        }

        return false;
    }



    #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1255 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // shift_NONE_xxx()
    bool shift_NONE___fpl_null(bool eject) {
        // this always matches. it's used to match at ends of rules.
        return true;
    }


    public:

    typedef enum {

        #line 1261 "src/fpl2cc/fpl_x_parser.h.jemp" 
        __fpl_null, // 0 _fpl_null

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _fragment, // 1 fragment

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _complete, // 2 complete

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _text, // 3 text

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_4, // 4 '@@'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_5, // 5 '@/*'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_6, // 6 /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_7, // 7 '*/@'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_8, // 8 /\\n\?/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_9, // 9 '@parameter:'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_10, // 10 /[^@]+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_11, // 11 '@'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _leading_ws, // 12 leading_ws

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_13, // 13 /@declare\\s+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _identifier, // 14 identifier

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_15, // 15 ':'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_16, // 16 /(\?:[^@]|(\?:@@))*/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_17, // 17 /@realign:\\s*/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_18, // 18 '#'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_19, // 19 !'#'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _template_variant, // 20 template_variant

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_21, // 21 '@-'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _subst_start, // 22 subst_start

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_23, // 23 '-@'

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _trailing_ws, // 24 trailing_ws

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _subst_end, // 25 subst_end

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_26, // 26 /(\?:[^-@]|-[^@])+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _rest_of_sub, // 27 rest_of_sub

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_28, // 28 /\\n*[ \\t]+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_29, // 29 /[ \\t]*\\n+[ \\t]+(\?!@)/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_30, // 30 /[ \\t]*\\n/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_31, // 31 /#\\s*/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_32, // 32 /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_33, // 33 /[^@\\n]+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_34, // 34 /[a-zA-Z_][a-zA-Z_0-9]+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_35, // 35 /[ \\t]+/

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _sp, // 36 sp

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
        _terminal_37, // 37 ␄_fpl_goal

        #line 1264 "src/fpl2cc/fpl_x_parser.h.jemp" 
    } ElementID;

    // returns a string describing the element matching the ID
    // passed. this is for debugging.
    static std::string element_str(int id) {
        switch(id) {

            #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 0: return "_fpl_null (0)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 1: return "fragment (1)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 2: return "complete (2)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 3: return "text (3)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 4: return "'@@' (4)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 5: return "'@/*' (5)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 6: return "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/ (6)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 7: return "'*/@' (7)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 8: return "/\\\\n\\\?/ (8)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 9: return "'@parameter:' (9)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 10: return "/[^@]+/ (10)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 11: return "'@' (11)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 12: return "leading_ws (12)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 13: return "/@declare\\\\s+/ (13)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 14: return "identifier (14)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 15: return "':' (15)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 16: return "/(\\\?:[^@]|(\\\?:@@))*/ (16)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 17: return "/@realign:\\\\s*/ (17)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 18: return "'#' (18)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 19: return "!'#' (19)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 20: return "template_variant (20)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 21: return "'@-' (21)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 22: return "subst_start (22)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 23: return "'-@' (23)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 24: return "trailing_ws (24)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 25: return "subst_end (25)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 26: return "/(\\\?:[^-@]|-[^@])+/ (26)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 27: return "rest_of_sub (27)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 28: return "/\\\\n*[ \\\\t]+/ (28)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 29: return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/ (29)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 30: return "/[ \\\\t]*\\\\n/ (30)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 31: return "/#\\\\s*/ (31)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 32: return "/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/ (32)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 33: return "/[^@\\\\n]+/ (33)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 34: return "/[a-zA-Z_][a-zA-Z_0-9]+/ (34)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 35: return "/[ \\\\t]+/ (35)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 36: return "sp (36)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 37: return "␄_fpl_goal (37)";

            #line 1274 "src/fpl2cc/fpl_x_parser.h.jemp" 
        }
        return stringformat("¡unknown element id {}!", id);
    }

    static bool is_nonterminal(int id, const std::string &caller = CALLER()) {
        switch(id) {

            #line 1281 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 0: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 1: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 2: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 3: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 4: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 5: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 6: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 7: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 8: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 9: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 10: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 11: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 12: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 13: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 14: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 15: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 16: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 17: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 18: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 19: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 20: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 21: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 22: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 23: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 24: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 25: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 26: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 27: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 28: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 29: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 30: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 31: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 32: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 33: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 34: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 35: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 36: return true;

            #line 1284 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1282 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case 37: return false;

            #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1287 "src/fpl2cc/fpl_x_parser.h.jemp" 
        }
        jerror::error(stringformat(
        "internal error {}: invalid terminal id: {}\n", caller, id
        ));
        return false;
    }

    // returns the name of the state function for the state pointer passed
    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) return "state_0";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) return "state_1";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) return "state_2";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) return "state_3";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) return "state_4";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) return "state_5";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) return "state_6";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) return "state_7";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) return "state_8";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) return "state_9";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) return "state_10";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) return "state_11";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) return "state_12";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) return "state_13";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) return "state_14";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) return "state_15";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) return "state_16";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) return "state_17";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) return "state_18";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) return "state_19";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) return "state_20";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) return "state_21";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) return "state_22";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) return "state_23";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) return "state_24";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) return "state_25";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) return "state_26";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) return "state_27";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) return "state_28";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) return "state_29";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) return "state_30";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) return "state_31";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) return "state_32";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) return "state_33";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) return "state_34";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) return "state_35";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) return "state_36";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) return "state_37";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) return "state_38";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) return "state_39";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) return "state_40";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) return "state_41";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) return "state_42";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) return "state_43";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) return "state_44";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) return "state_45";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) return "state_46";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) return "state_47";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) return "state_48";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) return "state_49";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) return "state_50";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) return "state_51";

        #line 1301 "src/fpl2cc/fpl_x_parser.h.jemp" 

        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    // return a stack-trace style dump of the state passed.
    static const char *state_string(State st) {

        #line 1309 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {
            return "state_0:\n"
            "    complete (0:1):\t •fragment+:fragments \t=> state 37\t(src/grammarlib/jemp.fpl:12)\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:24)\n"
            "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 38\t(src/grammarlib/jemp.fpl:35)\n"
            "    fragment (5:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 29\t(src/grammarlib/jemp.fpl:41)\n"
            "    fragment (5:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:41)\n"
            "    fragment (6:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 47\t(src/grammarlib/jemp.fpl:54)\n"
            "    subst_start (8:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 29\t(src/grammarlib/jemp.fpl:60)\n"
            "    subst_start (8:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:60)\n"
            "    subst_start (9:1):\t •'@':arg_0 \t=> state 46\t(src/grammarlib/jemp.fpl:61)\n"
            "    leading_ws (13:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:71)\n"
            "    trailing_ws (14:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:85)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:89)\n"
            "    fragment (16:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:99)\n"
            "    fragment (17:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:102)\n"
            "    fragment (18:3):\t •subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:114)\n"
            "    fragment (19:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:117)\n"
            "    text (20:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:121)\n"
            "    text (21:1):\t •leading_ws \t=> state 29\t(src/grammarlib/jemp.fpl:125)\n"
            "    text (22:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:126)\n"
            "    _fpl_goal (25:1):\t •complete \t=> state 51\t(src/fpl2cc/productions.h:3454)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {
            return "state_1:\n"
            "    text (22:0):\t trailing_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:126)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {
            return "state_2:\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    fragment (1:0):\t text+:chunks •\t=> (reduce)\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    leading_ws (13:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:71)\n"
            "    trailing_ws (14:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:85)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:89)\n"
            "    text (20:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:121)\n"
            "    text (21:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:125)\n"
            "    text (22:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:126)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {
            return "state_3:\n"
            "    text (21:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:125)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {
            return "state_4:\n"
            "    text (2:0):\t '@@':at_sign •\t=> (reduce)\t(src/grammarlib/jemp.fpl:20)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {
            return "state_5:\n"
            "    leading_ws (13:0):\t /\\\\n*[ \\\\t]+/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:71)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {
            return "state_6:\n"
            "    text (20:0):\t /[^@\\\\n]+/:t •\t=> (reduce)\t(src/grammarlib/jemp.fpl:121)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {
            return "state_7:\n"
            "    trailing_ws (14:0):\t /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:85)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {
            return "state_8:\n"
            "    trailing_ws (15:0):\t /[ \\\\t]*\\\\n/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:89)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {
            return "state_9:\n"
            "    fragment (16:5):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 17\t(src/grammarlib/jemp.fpl:99)\n"
            "    fragment (17:4):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 17\t(src/grammarlib/jemp.fpl:102)\n"
            "    fragment (18:2):\t subst_start^ •/(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 10\t(src/grammarlib/jemp.fpl:114)\n"
            "    fragment (19:2):\t subst_start^ •/(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 15\t(src/grammarlib/jemp.fpl:117)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {
            return "state_10:\n"
            "    subst_end (10:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:63)\n"
            "    subst_end (11:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:64)\n"
            "    fragment (18:1):\t subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement •subst_end^ \t=> state 11\t(src/grammarlib/jemp.fpl:114)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {
            return "state_11:\n"
            "    fragment (18:0):\t subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:114)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {
            return "state_12:\n"
            "    subst_end (11:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:64)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {
            return "state_13:\n"
            "    subst_end (10:1):\t '-@':arg_0 •trailing_ws\?^ \t=> state 14\t(src/grammarlib/jemp.fpl:63)\n"
            "    subst_end (10:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:63)\n"
            "    trailing_ws (14:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:85)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:89)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {
            return "state_14:\n"
            "    subst_end (10:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:63)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {
            return "state_15:\n"
            "    subst_end (10:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:63)\n"
            "    subst_end (11:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:64)\n"
            "    fragment (19:1):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable •subst_end^ \t=> state 16\t(src/grammarlib/jemp.fpl:117)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {
            return "state_16:\n"
            "    fragment (19:0):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:117)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {
            return "state_17:\n"
            "    fragment (16:4):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 18\t(src/grammarlib/jemp.fpl:99)\n"
            "    fragment (17:3):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 18\t(src/grammarlib/jemp.fpl:102)\n"
            "    identifier (23:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 28\t(src/grammarlib/jemp.fpl:129)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {
            return "state_18:\n"
            "    template_variant (7:3):\t •'#'^ !'#':variant_expression '#'^ \t=> state 25\t(src/grammarlib/jemp.fpl:58)\n"
            "    rest_of_sub (12:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 22\t(src/grammarlib/jemp.fpl:65)\n"
            "    fragment (16:3):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 19\t(src/grammarlib/jemp.fpl:99)\n"
            "    fragment (17:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^ \t=> state 23\t(src/grammarlib/jemp.fpl:102)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {
            return "state_19:\n"
            "    rest_of_sub (12:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 22\t(src/grammarlib/jemp.fpl:65)\n"
            "    fragment (16:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^ \t=> state 20\t(src/grammarlib/jemp.fpl:99)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {
            return "state_20:\n"
            "    subst_end (10:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:63)\n"
            "    subst_end (11:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:64)\n"
            "    fragment (16:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^ \t=> state 21\t(src/grammarlib/jemp.fpl:99)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {
            return "state_21:\n"
            "    fragment (16:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:99)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {
            return "state_22:\n"
            "    rest_of_sub (12:0):\t /(\\\?:[^-@]|-[^@])+/:arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:65)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {
            return "state_23:\n"
            "    subst_end (10:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:63)\n"
            "    subst_end (11:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:64)\n"
            "    fragment (17:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^ \t=> state 24\t(src/grammarlib/jemp.fpl:102)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {
            return "state_24:\n"
            "    fragment (17:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:102)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {
            return "state_25:\n"
            "    template_variant (7:2):\t '#'^ •!'#':variant_expression '#'^ \t=> state 26\t(src/grammarlib/jemp.fpl:58)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {
            return "state_26:\n"
            "    template_variant (7:1):\t '#'^ !'#':variant_expression •'#'^ \t=> state 27\t(src/grammarlib/jemp.fpl:58)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {
            return "state_27:\n"
            "    template_variant (7:0):\t '#'^ !'#':variant_expression '#'^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:58)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {
            return "state_28:\n"
            "    identifier (23:0):\t /[a-zA-Z_][a-zA-Z_0-9]+/:name •\t=> (reduce)\t(src/grammarlib/jemp.fpl:129)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {
            return "state_29:\n"
            "    fragment (5:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:41)\n"
            "    subst_start (8:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:60)\n"
            "    text (21:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:125)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {
            return "state_30:\n"
            "    subst_start (8:0):\t leading_ws\?^ '@-':arg_1 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:60)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {
            return "state_31:\n"
            "    fragment (5:5):\t leading_ws\? /@declare\\\\s+/^ •identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 32\t(src/grammarlib/jemp.fpl:41)\n"
            "    identifier (23:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 28\t(src/grammarlib/jemp.fpl:129)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {
            return "state_32:\n"
            "    fragment (5:4):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl •':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 33\t(src/grammarlib/jemp.fpl:41)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {
            return "state_33:\n"
            "    fragment (5:3):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ •/(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 34\t(src/grammarlib/jemp.fpl:41)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {
            return "state_34:\n"
            "    fragment (5:2):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value •'@'^ /\\\\n\\\?/^ \t=> state 35\t(src/grammarlib/jemp.fpl:41)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {
            return "state_35:\n"
            "    fragment (5:1):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ •/\\\\n\\\?/^ \t=> state 36\t(src/grammarlib/jemp.fpl:41)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {
            return "state_36:\n"
            "    fragment (5:0):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:41)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {
            return "state_37:\n"
            "    complete (0:1):\t •fragment+:fragments \t=> state 37\t(src/grammarlib/jemp.fpl:12)\n"
            "    complete (0:0):\t fragment+:fragments •\t=> (reduce)\t(src/grammarlib/jemp.fpl:12)\n"
            "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:24)\n"
            "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 38\t(src/grammarlib/jemp.fpl:35)\n"
            "    fragment (5:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 29\t(src/grammarlib/jemp.fpl:41)\n"
            "    fragment (5:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:41)\n"
            "    fragment (6:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 47\t(src/grammarlib/jemp.fpl:54)\n"
            "    subst_start (8:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 29\t(src/grammarlib/jemp.fpl:60)\n"
            "    subst_start (8:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 30\t(src/grammarlib/jemp.fpl:60)\n"
            "    subst_start (9:1):\t •'@':arg_0 \t=> state 46\t(src/grammarlib/jemp.fpl:61)\n"
            "    leading_ws (13:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:71)\n"
            "    trailing_ws (14:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:85)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:89)\n"
            "    fragment (16:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:99)\n"
            "    fragment (17:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:102)\n"
            "    fragment (18:3):\t •subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:114)\n"
            "    fragment (19:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:117)\n"
            "    text (20:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:121)\n"
            "    text (21:1):\t •leading_ws \t=> state 29\t(src/grammarlib/jemp.fpl:125)\n"
            "    text (22:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:126)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {
            return "state_38:\n"
            "    fragment (4:3):\t '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 39\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {
            return "state_39:\n"
            "    fragment (4:2):\t '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\\\n\\\?/^ \t=> state 40\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {
            return "state_40:\n"
            "    fragment (4:1):\t '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\\\n\\\?/^ \t=> state 41\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {
            return "state_41:\n"
            "    fragment (4:0):\t '@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:35)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {
            return "state_42:\n"
            "    fragment (3:3):\t '@/*'^ •/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 43\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {
            return "state_43:\n"
            "    fragment (3:2):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment •'*/@'^ /\\\\n\\\?/^ \t=> state 44\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {
            return "state_44:\n"
            "    fragment (3:1):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ •/\\\\n\\\?/^ \t=> state 45\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {
            return "state_45:\n"
            "    fragment (3:0):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:24)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {
            return "state_46:\n"
            "    subst_start (9:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:61)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {
            return "state_47:\n"
            "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
            "    fragment (6:3):\t /@realign:\\\\s*/^ •text:realign '@'^ /\\\\n\\\?/^ \t=> state 48\t(src/grammarlib/jemp.fpl:54)\n"
            "    leading_ws (13:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:71)\n"
            "    trailing_ws (14:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:85)\n"
            "    trailing_ws (15:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:89)\n"
            "    text (20:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:121)\n"
            "    text (21:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:125)\n"
            "    text (22:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:126)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {
            return "state_48:\n"
            "    fragment (6:2):\t /@realign:\\\\s*/^ text:realign •'@'^ /\\\\n\\\?/^ \t=> state 49\t(src/grammarlib/jemp.fpl:54)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {
            return "state_49:\n"
            "    fragment (6:1):\t /@realign:\\\\s*/^ text:realign '@'^ •/\\\\n\\\?/^ \t=> state 50\t(src/grammarlib/jemp.fpl:54)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {
            return "state_50:\n"
            "    fragment (6:0):\t /@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:54)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {
            return "state_51:\n"
            "    _fpl_goal (25:0):\t complete •\t=> (done)\t(src/fpl2cc/productions.h:3454)\n"
            ;
        }

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 

        return "<invalid state>";
    }

    // Returns true if elements matching the element id passed
    // are ejected in the context of the given state, or false
    // otherwise.
    static bool state_ejects(State st, int element_id) {

        #line 1324 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_0 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_start == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_9 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_5 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_17 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_13 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_1 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_2 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_3 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_4 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_5 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_6 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_7 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_8 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_9 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_31 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_10 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_11 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_12 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_13 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_trailing_ws == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_14 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_15 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_16 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_17 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_18 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_18 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_19 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_20 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_21 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_22 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_23 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_end == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_24 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_25 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_26 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_18 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_27 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_28 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_29 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_13 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_30 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_31 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_32 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_15 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_33 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_34 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_35 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_36 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_37 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_subst_start == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_9 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_5 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_17 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_13 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_38 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_39 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_40 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_41 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_42 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_43 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_7 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_44 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_45 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_46 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_47 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_48 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_11 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_49 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::_terminal_8 == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_50 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(&jemplpl_parser::state_51 == st) {

            #line 1327 "src/fpl2cc/fpl_x_parser.h.jemp" 

            if(ElementID::__fpl_null == element_id) {
                return true;
            } else

            #line 1331 "src/fpl2cc/fpl_x_parser.h.jemp" 

            {
                return false;
            }
        } else

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 
        {
            return false;
        }
    }

    static bool is_goal(int el_id) {
        switch(el_id) {

            #line 1344 "src/fpl2cc/fpl_x_parser.h.jemp" 
            case ElementID::_complete: return true;

            #line 1346 "src/fpl2cc/fpl_x_parser.h.jemp" 

            default: return false;
        }
        return false;
    }

    bool result_is_goal() const {
        return is_goal(result_product_id());
    }

    static size_t separator_length(const utf8_byte *inp) {

        #line 1357 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 
        {

            #line 1364 "src/fpl2cc/fpl_x_parser.h.jemp" 

            #line 1367 "src/fpl2cc/fpl_x_parser.h.jemp" 


            #line 1 "src/grammarlib/none.inc"
            // separator "none" means 0 bytes of separator:
            return 0;

            #line 8299 "src/jemplpl/jemplpl.cc"


            #line 1371 "src/fpl2cc/fpl_x_parser.h.jemp" 

        }

        #line 1373 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1375 "src/fpl2cc/fpl_x_parser.h.jemp" 
        return 0;
    }

    size_t eat_separator() {
        bytes_eaten += reader->eat_separator(separator_length);
        return bytes_eaten;
    }

    // reduction rules:

    #line 1385 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_0(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> fragments
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_0";
            }
            static const char *product() {
                return "complete";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 12;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:12";
            }
            static const char *to_str() {
                return "fragment+:fragments -> complete";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "fragments"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:12";
                }
            }
        } this_rule;



        // fragment+:fragments -> complete

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 33 "src/jemplpl/jemplpl.fpl"

        std::string guts;

        fragments.foreach(
        [&guts] (const std::string &frag) { guts += frag; }
        );


        std::string function_name = output_function_name();

        #define _CLUDGE_TO_STR(x) #x
        #define _CLUDGE_STR(x) _CLUDGE_TO_STR(x)
        return stringformat(
        "#ifndef {}_H\n"
        "#define {}_H\n"
        "#line " _CLUDGE_STR(__LINE__) " \"" __FILE__ "\"\n\n"
        "#include <string>\n"
        "#include \"util/stringformat.h\"\n"
        "inline std::string {}({}) {{\n"
        "    struct _jemp_srcinfo {{\n"
        "        int ln;\n"
        "        std::string filename() const {{ return \"{}\"; }};\n"
        "        int line_number() const {{ return ln; }}\n"
        "    }} source;\n"
        "    source.ln = 1;\n"
        "    std::string out;\n"
        "    {}\n"
        "    return out;\n"
        "}\n"
        "#endif // {}_H\n",
        function_name,  // #ifndef .. 
        function_name,  // #define ..
        function_name, jempl.fmt_params(), // func decl
        filename(),           // source info
        guts,                 // the real stuff
        function_name   // #endif
        );


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_1(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> chunks
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_1";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 15;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:15";
            }
            static const char *to_str() {
                return "text+:chunks -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "chunks"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:15";
                }
            }
        } this_rule;



        // text+:chunks -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 72 "src/jemplpl/jemplpl.fpl"

        std::string frag = "out += ";
        chunks.foreach(
        [&frag] (const std::string &chunk) { frag += quote(chunk) + "\n"; }
        );
        return frag + ";\n";


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_2(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> at_sign
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_2";
            }
            static const char *product() {
                return "text";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 20;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:20";
            }
            static const char *to_str() {
                return "'@@':at_sign -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "at_sign"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:20";
                }
            }
        } this_rule;



        // '@@':at_sign -> text

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 20 "src/grammarlib/jemp.fpl"
        return "@"; 

        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_3(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> comment
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_3";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 24;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:24";
            }
            static const char *to_str() {
                return "'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "comment"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:24";
                }
            }
        } this_rule;



        // '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 81 "src/jemplpl/jemplpl.fpl"

        return line_num(comment.self()) + jempl.realign_frag();


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_4(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> param_decl
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_4";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 35;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:35";
            }
            static const char *to_str() {
                return "'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "param_decl"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:35";
                }
            }
        } this_rule;



        // '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 85 "src/jemplpl/jemplpl.fpl"

        jempl.params.push_back(param_decl.val());
        return "";


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_5(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> leading_ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ,  ReductionParameter<std::string> name_decl
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ,  ReductionParameter<Terminal> value
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_5";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 7;
            }
            static int num_params() {
                return 3;
            }
            static int line_number() {
                return 41;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:41";
            }
            static const char *to_str() {
                return "leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "leading_ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "name_decl"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "value"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:41";
                }
            }
        } this_rule;



        // leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 90 "src/jemplpl/jemplpl.fpl"

        return line_num(value.self())
        + stringformat("const auto {} = {};\n", name_decl.val(), value.val());


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_6(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> realign
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_6";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 4;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 54;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:54";
            }
            static const char *to_str() {
                return "/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "realign"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:54";
                }
            }
        } this_rule;



        // /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 95 "src/jemplpl/jemplpl.fpl"

        jempl.realign_fragment = 
        "\nout += stringformat(" +
        quote("\n" + realign.val() + "\n") +
        ", source.line_number(), source.filename());\n";

        return line_num(realign.self()) + jempl.realign_frag();


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_7(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> variant_expression
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_7";
            }
            static const char *product() {
                return "template_variant";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 58;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:58";
            }
            static const char *to_str() {
                return "'#'^ !'#':variant_expression '#'^ -> template_variant";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variant_expression"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:58";
                }
            }
        } this_rule;



        // '#'^ !'#':variant_expression '#'^ -> template_variant

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:58 (default action for '#'^ !'#':variant_expression '#'^ -> template_variant)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        variant_expression.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_8(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_1
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_8";
            }
            static const char *product() {
                return "subst_start";
            }
            static int num_steps() {
                return 2;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 60;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:60";
            }
            static const char *to_str() {
                return "leading_ws\?^ '@-':arg_1 -> subst_start";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_1"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:60";
                }
            }
        } this_rule;



        // leading_ws?^ '@-':arg_1 -> subst_start

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:60 (default action for leading_ws\?^ '@-':arg_1 -> subst_start)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_1.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_9(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_9";
            }
            static const char *product() {
                return "subst_start";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 61;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:61";
            }
            static const char *to_str() {
                return "'@':arg_0 -> subst_start";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:61";
                }
            }
        } this_rule;



        // '@':arg_0 -> subst_start

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:61 (default action for '@':arg_0 -> subst_start)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_10(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_10";
            }
            static const char *product() {
                return "subst_end";
            }
            static int num_steps() {
                return 2;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 63;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:63";
            }
            static const char *to_str() {
                return "'-@':arg_0 trailing_ws\?^ -> subst_end";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:63";
                }
            }
        } this_rule;



        // '-@':arg_0 trailing_ws?^ -> subst_end

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:63 (default action for '-@':arg_0 trailing_ws\?^ -> subst_end)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_11(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_11";
            }
            static const char *product() {
                return "subst_end";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 64;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:64";
            }
            static const char *to_str() {
                return "'@':arg_0 -> subst_end";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:64";
                }
            }
        } this_rule;



        // '@':arg_0 -> subst_end

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:64 (default action for '@':arg_0 -> subst_end)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_12(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> arg_0
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_12";
            }
            static const char *product() {
                return "rest_of_sub";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 65;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:65";
            }
            static const char *to_str() {
                return "/(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "arg_0"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:65";
                }
            }
        } this_rule;



        // /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:65 (default action for /(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        arg_0.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_13(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_13";
            }
            static const char *product() {
                return "leading_ws";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 71;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:71";
            }
            static const char *to_str() {
                return "/\\\\n*[ \\\\t]+/:ws -> leading_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:71";
                }
            }
        } this_rule;



        // /\\n*[ \\t]+/:ws -> leading_ws

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:71 (default action for /\\\\n*[ \\\\t]+/:ws -> leading_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_14(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_14";
            }
            static const char *product() {
                return "trailing_ws";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 85;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:85";
            }
            static const char *to_str() {
                return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:85";
                }
            }
        } this_rule;



        // /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:85 (default action for /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_15(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_15";
            }
            static const char *product() {
                return "trailing_ws";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 89;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:89";
            }
            static const char *to_str() {
                return "/[ \\\\t]*\\\\n/:ws -> trailing_ws";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:89";
                }
            }
        } this_rule;



        // /[ \\t]*\\n/:ws -> trailing_ws

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:89 (default action for /[ \\\\t]*\\\\n/:ws -> trailing_ws)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        ws.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_16(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_args
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ,  ReductionParameter<std::string> jempl_name
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ,  ReductionParameter<std::string> variant
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_16";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 6;
            }
            static int num_params() {
                return 3;
            }
            static int line_number() {
                return 99;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:99";
            }
            static const char *to_str() {
                return "subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_args"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_name"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variant"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 3) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:99";
                }
            }
        } this_rule;



        // subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 109 "src/jemplpl/jemplpl.fpl"

        std::list<std::string> cases;
        std::string search_re = stringformat("{}.*\\.h\\.jemp$", jempl_name.val());
        for(auto templ : jempl.import_path.find_re(search_re)) {
            add_import(templ);

            cases.push_back(stringformat(
            "if(fruitbat == \"{}\") {{\n    out += {}{};\n}",
            function_name(templ), function_name(templ), jempl_args.val()
            ));
        }

        return stringformat(
        "{{\n"
        "    std::string fruitbat = stringformat(\"{}{}\", {});\n"
        "    {}\n"
        "}\n",
        jempl_name.val(),
        "{}",    // format for the variant.val() when expanding template
        variant.val(), // code for the variant.val()
        join(cases, " else ")
        );


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_17(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> jempl_args
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ,  ReductionParameter<std::string> jempl_name
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_17";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 5;
            }
            static int num_params() {
                return 2;
            }
            static int line_number() {
                return 102;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:102";
            }
            static const char *to_str() {
                return "subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_args"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "jempl_name"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 2) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:102";
                }
            }
        } this_rule;



        // subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 104 "src/jemplpl/jemplpl.fpl"

        add_import(jempl.import_path.find(jempl_name.val() + ".h.jemp"));
        return stringformat("\nout += {}{};\n", jempl_name.val(), jempl_args.val());


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_18(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> control_statement
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_18";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 114;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:114";
            }
            static const char *to_str() {
                return "subst_start^ /(\\\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "control_statement"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:114";
                }
            }
        } this_rule;



        // subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 133 "src/jemplpl/jemplpl.fpl"

        return line_num(control_statement.self())
        + jempl.realign_frag()
        + control_statement.val().to_str();


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_19(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> variable
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_19";
            }
            static const char *product() {
                return "fragment";
            }
            static int num_steps() {
                return 3;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 117;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:117";
            }
            static const char *to_str() {
                return "subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "variable"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:117";
                }
            }
        } this_rule;



        // subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 140 "src/jemplpl/jemplpl.fpl"

        return line_num(variable.self())
        + "out += stringformat(\"{}\"," + variable.val().to_str() + ");\n";


        #line 19 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_20(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> t
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_20";
            }
            static const char *product() {
                return "text";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 121;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:121";
            }
            static const char *to_str() {
                return "/[^@\\\\n]+/:t -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "t"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:121";
                }
            }
        } this_rule;



        // /[^@\\n]+/:t -> text

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:121 (default action for /[^@\\\\n]+/:t -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        t.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_21(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> leading_ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_21";
            }
            static const char *product() {
                return "text";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 125;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:125";
            }
            static const char *to_str() {
                return "leading_ws -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "leading_ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:125";
                }
            }
        } this_rule;



        // leading_ws -> text

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:125 (default action for leading_ws -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        leading_ws.val()

        #line 50 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_22(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> trailing_ws
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_22";
            }
            static const char *product() {
                return "text";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 126;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:126";
            }
            static const char *to_str() {
                return "trailing_ws -> text";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "trailing_ws"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:126";
                }
            }
        } this_rule;



        // trailing_ws -> text

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:126 (default action for trailing_ws -> text)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        trailing_ws.val()

        #line 50 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_23(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> name
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_23";
            }
            static const char *product() {
                return "identifier";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 129;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:129";
            }
            static const char *to_str() {
                return "/[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "name"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:129";
                }
            }
        } this_rule;



        // /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:129 (default action for /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        name.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_24(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<Terminal> space
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_24";
            }
            static const char *product() {
                return "sp";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 132;
            }
            static const char *filename() {
                return "src/grammarlib/jemp.fpl";
            }
            static const char *location() {
                return "src/grammarlib/jemp.fpl:132";
            }
            static const char *to_str() {
                return "/[ \\\\t]+/:space -> sp";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "space"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/grammarlib/jemp.fpl:132";
                }
            }
        } this_rule;



        // /[ \\t]+/:space -> sp

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/grammarlib/jemp.fpl:132 (default action for /[ \\\\t]+/:space -> sp)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        space.val().to_str()

        #line 53 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1386 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    std::string rule_25(

    #line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ReductionParameter<std::string> complete
    #line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ) {

        #line 2 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


        #line 4 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

        struct {
            static const char *name() {
                return "rule_25";
            }
            static const char *product() {
                return "_fpl_goal";
            }
            static int num_steps() {
                return 1;
            }
            static int num_params() {
                return 1;
            }
            static int line_number() {
                return 3454;
            }
            static const char *filename() {
                return "src/fpl2cc/productions.h";
            }
            static const char *location() {
                return "src/fpl2cc/productions.h:3454";
            }
            static const char *to_str() {
                return "complete -> _fpl_goal";
            }
            static const char *param_name(unsigned int ind) {
                static const char *pname[] = {

                    #line 36 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                    "complete"

                    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                };
                if(ind < 1) {
                    return pname[ind];
                } else {
                    return "param_name index out of bounds at "
                    "src/fpl2cc/productions.h:3454";
                }
            }
        } this_rule;



        // complete -> _fpl_goal

        #line 16 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


        #line 33 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        #line 1 "src/fpl2cc/productions.h:3454 (default action for complete -> _fpl_goal)"
        // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:35
        return std::string(

        #line 37 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 47 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        complete.val()

        #line 50 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

        #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
        );

        #line 57 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    }



    #line 1388 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 1389 "src/fpl2cc/fpl_x_parser.h.jemp" 


    // parser states:

    #line 1392 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // complete (0:1):      •fragment+:fragments                                                                                     => state 37 (src/grammarlib/jemp.fpl:12)
    // fragment (1:1):      •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (3:4):      •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 42 (src/grammarlib/jemp.fpl:24)
    // fragment (4:4):      •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 38 (src/grammarlib/jemp.fpl:35)
    // fragment (5:7):      •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 29 (src/grammarlib/jemp.fpl:41)
    // fragment (5:6):      leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:41)
    // fragment (6:4):      •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 47 (src/grammarlib/jemp.fpl:54)
    // subst_start (8:2):   •leading_ws?^ '@-':arg_1                                                                                 => state 29 (src/grammarlib/jemp.fpl:60)
    // subst_start (8:1):   leading_ws?^ •'@-':arg_1                                                                                 => state 30 (src/grammarlib/jemp.fpl:60)
    // subst_start (9:1):   •'@':arg_0                                                                                               => state 46 (src/grammarlib/jemp.fpl:61)
    // leading_ws (13:1):   •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:71)
    // trailing_ws (14:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:85)
    // trailing_ws (15:1):  •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:89)
    // fragment (16:6):     •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:99)
    // fragment (17:5):     •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:102)
    // fragment (18:3):     •subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 9  (src/grammarlib/jemp.fpl:114)
    // fragment (19:3):     •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:117)
    // text (20:1):         •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:121)
    // text (21:1):         •leading_ws                                                                                              => state 29 (src/grammarlib/jemp.fpl:125)
    // text (22:1):         •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:126)
    // _fpl_goal (25:1):    •complete                                                                                                => state 51 (src/fpl2cc/productions.h:3454)
    //
    void state_0() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__fragment(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_37);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_start(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_9);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__complete(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_51);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_5(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_42);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_9(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_38);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_13(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_17(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_47);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_21(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_46);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_28(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_33(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (22:0):  trailing_ws • => (reduce) (src/grammarlib/jemp.fpl:126)
    //
    void state_1() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__trailing_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_22 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (1:1):      •text+:chunks                   => state 2  (src/grammarlib/jemp.fpl:15)
    // fragment (1:0):      text+:chunks •                  => (reduce) (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                   => state 4  (src/grammarlib/jemp.fpl:20)
    // leading_ws (13:1):   •/\\n*[ \\t]+/:ws               => state 5  (src/grammarlib/jemp.fpl:71)
    // trailing_ws (14:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:85)
    // trailing_ws (15:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:89)
    // text (20:1):         •/[^@\\n]+/:t                   => state 6  (src/grammarlib/jemp.fpl:121)
    // text (21:1):         •leading_ws                     => state 3  (src/grammarlib/jemp.fpl:125)
    // text (22:1):         •trailing_ws                    => state 1  (src/grammarlib/jemp.fpl:126)
    //
    void state_2() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_3);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_28(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_33(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__text(
            lr_read_pos, true
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__text(arg_start, true);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_1 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (21:0):  leading_ws • => (reduce) (src/grammarlib/jemp.fpl:125)
    //
    void state_3() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__leading_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_21 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (2:0):  '@@':at_sign • => (reduce) (src/grammarlib/jemp.fpl:20)
    //
    void state_4() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_4(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_4(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_2 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // leading_ws (13:0):  /\\n*[ \\t]+/:ws • => (reduce) (src/grammarlib/jemp.fpl:71)
    //
    void state_5() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_28(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_28(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_13 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _leading_ws);
            lr_push(_leading_ws, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (20:0):  /[^@\\n]+/:t • => (reduce) (src/grammarlib/jemp.fpl:121)
    //
    void state_6() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_33(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_33(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_20 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // trailing_ws (14:0):  /[ \\t]*\\n+[ \\t]+(\?!@)/:ws • => (reduce) (src/grammarlib/jemp.fpl:85)
    //
    void state_7() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_29(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_29(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_14 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _trailing_ws);
            lr_push(_trailing_ws, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // trailing_ws (15:0):  /[ \\t]*\\n/:ws • => (reduce) (src/grammarlib/jemp.fpl:89)
    //
    void state_8() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_30(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_30(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_15 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _trailing_ws);
            lr_push(_trailing_ws, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (16:5):  subst_start^ •/#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 17 (src/grammarlib/jemp.fpl:99)
    // fragment (17:4):  subst_start^ •/#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 17 (src/grammarlib/jemp.fpl:102)
    // fragment (18:2):  subst_start^ •/(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 10 (src/grammarlib/jemp.fpl:114)
    // fragment (19:2):  subst_start^ •/(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 15 (src/grammarlib/jemp.fpl:117)
    //
    void state_9() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_31(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_17);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_32(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_10);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_26(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_15);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:2):  •'-@':arg_0 trailing_ws?^                                                       => state 13 (src/grammarlib/jemp.fpl:63)
    // subst_end (11:1):  •'@':arg_0                                                                      => state 12 (src/grammarlib/jemp.fpl:64)
    // fragment (18:1):   subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement •subst_end^  => state 11 (src/grammarlib/jemp.fpl:114)
    //
    void state_10() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_11);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_23(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (18:0):  subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:114)
    //
    void state_11() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_32(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_start(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_32(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_end(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_18 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (11:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:64)
    //
    void state_12() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_11(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_11 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:1):    '-@':arg_0 •trailing_ws?^       => state 14 (src/grammarlib/jemp.fpl:63)
    // subst_end (10:0):    '-@':arg_0 trailing_ws?^ •      => (reduce) (src/grammarlib/jemp.fpl:63)
    // trailing_ws (14:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:85)
    // trailing_ws (15:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:89)
    //
    void state_13() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_14);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_23(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_23(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__trailing_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_10 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:0):  '-@':arg_0 trailing_ws?^ • => (reduce) (src/grammarlib/jemp.fpl:63)
    //
    void state_14() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__trailing_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_23(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_23(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__trailing_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_10 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_end);
            lr_push(_subst_end, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:2):  •'-@':arg_0 trailing_ws?^                              => state 13 (src/grammarlib/jemp.fpl:63)
    // subst_end (11:1):  •'@':arg_0                                             => state 12 (src/grammarlib/jemp.fpl:64)
    // fragment (19:1):   subst_start^ /(\?:[^-@]|-[^@])+/:variable •subst_end^  => state 16 (src/grammarlib/jemp.fpl:117)
    //
    void state_15() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_16);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_23(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (19:0):  subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:117)
    //
    void state_16() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_26(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_start(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_26(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_end(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_19 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (16:4):    subst_start^ /#\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 18 (src/grammarlib/jemp.fpl:99)
    // fragment (17:3):    subst_start^ /#\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 18 (src/grammarlib/jemp.fpl:102)
    // identifier (23:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                           => state 28 (src/grammarlib/jemp.fpl:129)
    //
    void state_17() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__identifier(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_18);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_28);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (7:3):  •'#'^ !'#':variant_expression '#'^                                                                       => state 25 (src/grammarlib/jemp.fpl:58)
    // rest_of_sub (12:1):      •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 22 (src/grammarlib/jemp.fpl:65)
    // fragment (16:3):         subst_start^ /#\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^  => state 19 (src/grammarlib/jemp.fpl:99)
    // fragment (17:2):         subst_start^ /#\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^                           => state 23 (src/grammarlib/jemp.fpl:102)
    //
    void state_18() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__template_variant(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_19);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_23);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_18(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_25);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_26(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_22);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // rest_of_sub (12:1):  •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 22 (src/grammarlib/jemp.fpl:65)
    // fragment (16:2):     subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^  => state 20 (src/grammarlib/jemp.fpl:99)
    //
    void state_19() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_20);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_26(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_22);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:2):  •'-@':arg_0 trailing_ws?^                                                                                => state 13 (src/grammarlib/jemp.fpl:63)
    // subst_end (11:1):  •'@':arg_0                                                                                               => state 12 (src/grammarlib/jemp.fpl:64)
    // fragment (16:1):   subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^  => state 21 (src/grammarlib/jemp.fpl:99)
    //
    void state_20() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_21);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_23(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (16:0):  subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:99)
    //
    void state_21() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__rest_of_sub(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__template_variant(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_31(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_start(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_31(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__identifier(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_2(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__template_variant(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_3(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__rest_of_sub(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_4(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_end(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_16 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_4
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_2
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_3
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // rest_of_sub (12:0):  /(\?:[^-@]|-[^@])+/:arg_0 • => (reduce) (src/grammarlib/jemp.fpl:65)
    //
    void state_22() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_26(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_26(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_12 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _rest_of_sub);
            lr_push(_rest_of_sub, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_end (10:2):  •'-@':arg_0 trailing_ws?^                                                       => state 13 (src/grammarlib/jemp.fpl:63)
    // subst_end (11:1):  •'@':arg_0                                                                      => state 12 (src/grammarlib/jemp.fpl:64)
    // fragment (17:1):   subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^  => state 24 (src/grammarlib/jemp.fpl:102)
    //
    void state_23() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_end(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_24);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_23(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_13);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_12);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (17:0):  subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:102)
    //
    void state_24() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_end(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__rest_of_sub(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_31(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__subst_start(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_start(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_31(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__identifier(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_2(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__rest_of_sub(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_3(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__subst_end(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_17 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_3
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_2
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (7:2):  '#'^ •!'#':variant_expression '#'^  => state 26 (src/grammarlib/jemp.fpl:58)
    //
    void state_25() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT_INV__terminal_19(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_26);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (7:1):  '#'^ !'#':variant_expression •'#'^  => state 27 (src/grammarlib/jemp.fpl:58)
    //
    void state_26() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_18(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_27);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // template_variant (7:0):  '#'^ !'#':variant_expression '#'^ • => (reduce) (src/grammarlib/jemp.fpl:58)
    //
    void state_27() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_18(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_19(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_18(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_18(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_19(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_18(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_7 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _template_variant);
            lr_push(_template_variant, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // identifier (23:0):  /[a-zA-Z_][a-zA-Z_0-9]+/:name • => (reduce) (src/grammarlib/jemp.fpl:129)
    //
    void state_28() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_34(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_34(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_23 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _identifier);
            lr_push(_identifier, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:6):     leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 31 (src/grammarlib/jemp.fpl:41)
    // subst_start (8:1):  leading_ws?^ •'@-':arg_1                                                                         => state 30 (src/grammarlib/jemp.fpl:60)
    // text (21:0):        leading_ws •                                                                                     => (reduce) (src/grammarlib/jemp.fpl:125)
    //
    void state_29() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_13(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_21(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__leading_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_21 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _text);
            lr_push(_text, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_start (8:0):  leading_ws?^ '@-':arg_1 • => (reduce) (src/grammarlib/jemp.fpl:60)
    //
    void state_30() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_21(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__leading_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_21(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_8 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_start);
            lr_push(_subst_start, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:5):     leading_ws? /@declare\\s+/^ •identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 32 (src/grammarlib/jemp.fpl:41)
    // identifier (23:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                   => state 28 (src/grammarlib/jemp.fpl:129)
    //
    void state_31() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__identifier(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_32);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_34(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_28);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:4):  leading_ws? /@declare\\s+/^ identifier:name_decl •':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 33 (src/grammarlib/jemp.fpl:41)
    //
    void state_32() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_15(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_33);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:3):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ •/(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 34 (src/grammarlib/jemp.fpl:41)
    //
    void state_33() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_16(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_34);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:2):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value •'@'^ /\\n\?/^  => state 35 (src/grammarlib/jemp.fpl:41)
    //
    void state_34() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_35);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:1):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ •/\\n\?/^  => state 36 (src/grammarlib/jemp.fpl:41)
    //
    void state_35() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_36);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (5:0):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:41)
    //
    void state_36() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_16(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_15(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__identifier(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_13(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__leading_ws(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__leading_ws(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_13(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__identifier(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_2(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_15(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_16(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_4(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_11(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_8(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_5 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_2
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            , arg_4
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // complete (0:1):      •fragment+:fragments                                                                                     => state 37 (src/grammarlib/jemp.fpl:12)
    // complete (0:0):      fragment+:fragments •                                                                                    => (reduce) (src/grammarlib/jemp.fpl:12)
    // fragment (1:1):      •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
    // text (2:1):          •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (3:4):      •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 42 (src/grammarlib/jemp.fpl:24)
    // fragment (4:4):      •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 38 (src/grammarlib/jemp.fpl:35)
    // fragment (5:7):      •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 29 (src/grammarlib/jemp.fpl:41)
    // fragment (5:6):      leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:41)
    // fragment (6:4):      •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 47 (src/grammarlib/jemp.fpl:54)
    // subst_start (8:2):   •leading_ws?^ '@-':arg_1                                                                                 => state 29 (src/grammarlib/jemp.fpl:60)
    // subst_start (8:1):   leading_ws?^ •'@-':arg_1                                                                                 => state 30 (src/grammarlib/jemp.fpl:60)
    // subst_start (9:1):   •'@':arg_0                                                                                               => state 46 (src/grammarlib/jemp.fpl:61)
    // leading_ws (13:1):   •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:71)
    // trailing_ws (14:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:85)
    // trailing_ws (15:1):  •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:89)
    // fragment (16:6):     •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:99)
    // fragment (17:5):     •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:102)
    // fragment (18:3):     •subst_start^ /(\?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^                           => state 9  (src/grammarlib/jemp.fpl:114)
    // fragment (19:3):     •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:117)
    // text (20:1):         •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:121)
    // text (21:1):         •leading_ws                                                                                              => state 29 (src/grammarlib/jemp.fpl:125)
    // text (22:1):         •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:126)
    //
    void state_37() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__fragment(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_37);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_2);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__subst_start(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_9);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_29);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_5(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_42);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_9(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_38);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_13(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_31);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_17(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_47);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_21(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_30);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_46);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_28(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_33(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__fragment(
            lr_read_pos, true
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__fragment(arg_start, true);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_0 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _complete);
            lr_push(_complete, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:3):  '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\n\?/^  => state 39 (src/grammarlib/jemp.fpl:35)
    //
    void state_38() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_10(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_39);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:2):  '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\n\?/^  => state 40 (src/grammarlib/jemp.fpl:35)
    //
    void state_39() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_40);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:1):  '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\n\?/^  => state 41 (src/grammarlib/jemp.fpl:35)
    //
    void state_40() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_41);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (4:0):  '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:35)
    //
    void state_41() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_10(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_9(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_9(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_10(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_11(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_8(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_4 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:3):  '@/*'^ •/(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^  => state 43 (src/grammarlib/jemp.fpl:24)
    //
    void state_42() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_6(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_43);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:2):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment •'*/@'^ /\\n\?/^  => state 44 (src/grammarlib/jemp.fpl:24)
    //
    void state_43() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_7(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_44);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:1):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ •/\\n\?/^  => state 45 (src/grammarlib/jemp.fpl:24)
    //
    void state_44() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_45);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (3:0):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:24)
    //
    void state_45() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_7(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_6(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_5(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_5(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_6(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_7(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_8(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_3 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // subst_start (9:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:61)
    //
    void state_46() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_11(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<Terminal>
            arg_0(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_9 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_0
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _subst_start);
            lr_push(_subst_start, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // text (2:1):          •'@@':at_sign                                 => state 4  (src/grammarlib/jemp.fpl:20)
    // fragment (6:3):      /@realign:\\s*/^ •text:realign '@'^ /\\n\?/^  => state 48 (src/grammarlib/jemp.fpl:54)
    // leading_ws (13:1):   •/\\n*[ \\t]+/:ws                             => state 5  (src/grammarlib/jemp.fpl:71)
    // trailing_ws (14:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                => state 7  (src/grammarlib/jemp.fpl:85)
    // trailing_ws (15:1):  •/[ \\t]*\\n/:ws                              => state 8  (src/grammarlib/jemp.fpl:89)
    // text (20:1):         •/[^@\\n]+/:t                                 => state 6  (src/grammarlib/jemp.fpl:121)
    // text (21:1):         •leading_ws                                   => state 3  (src/grammarlib/jemp.fpl:125)
    // text (22:1):         •trailing_ws                                  => state 1  (src/grammarlib/jemp.fpl:126)
    //
    void state_47() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__text(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_48);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_3);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_1);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_4(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_4);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_28(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_5);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_29(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_7);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_30(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_8);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_33(false)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_6);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:2):  /@realign:\\s*/^ text:realign •'@'^ /\\n\?/^  => state 49 (src/grammarlib/jemp.fpl:54)
    //
    void state_48() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_EXACT__terminal_11(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_49);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:1):  /@realign:\\s*/^ text:realign '@'^ •/\\n\?/^  => state 50 (src/grammarlib/jemp.fpl:54)
    //
    void state_49() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_TERM_REGEX__terminal_8(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            set_state(&jemplpl_parser::state_50);

            #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 41 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // fragment (6:0):  /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:54)
    //
    void state_50() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 43 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            // we've matched something, and we're going to generate and
            // push a result, so first we need to clear any mismatches
            // from the top of the stack:
            clear_mismatches();

            // INTERESTING... now that we're tracking per-step reserves, we
            // -could- come up with the params in one (backward) pass, as
            // long as we change the reserve counts to go backward instead
            // of forward through the rule...


            #line 20 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 26 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_8(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_11(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__text(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 28 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos = lr_position_before__terminal_17(
            lr_read_pos, false
            );

            #line 38 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 39 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            lr_read_pos++;  // (we went until just before the real frame start)


            #line 42 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            // Now that we know where the frame starts, we can go forward through
            // the stack to find the appropriate slices for our arguments.  We do
            // need to do this back-and-forth thing to get the arguments correct
            // for rules like: 
            //    foo:first foo*:rest -> bar ;
            int arg_start = lr_read_pos;
            int slice_size;

            #line 60 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_17(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__text(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 83 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            ReductionParameter<std::string>
            arg_1(*this, arg_start, slice_size);

            #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


            #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_11(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 62 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            slice_size = lr_count_of__terminal_8(arg_start, false);


            #line 71 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 82 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            arg_start += slice_size;

            #line 94 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 95 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

            #line 97 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            std::string result = rule_6 (

            #line 101 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            arg_1
            #line 103 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            );


            #line 106 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            Product prod(result);

            #line 112 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 118 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            auto src_pos = lr_stack_entry(lr_read_pos).position();


            #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            lr_pop_to(lr_read_pos - 1);


            #line 129 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
            bool eject = state_ejects(cur_state, _fragment);
            lr_push(_fragment, eject, src_pos, prod);


            #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



            #line 48 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    //
    // _fpl_goal (25:0):  complete • => (done) (src/fpl2cc/productions.h:3454)
    //
    void state_51() {

        #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        eat_separator();


        #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



        #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        if(shift_NONE___fpl_null(true)) {

            #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


            #line 49 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
            // matched a goal:
            terminate();

            #line 58 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        } else

        #line 62 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        {

            #line 64 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

            mismatch();
        }


        #line 70 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    }


    #line 1394 "src/fpl2cc/fpl_x_parser.h.jemp" 


};

#endif // header guard


#line 1400 "src/fpl2cc/fpl_x_parser.h.jemp" 

int main(int argc, const char **argv) {

    #line 239 "src/jemplpl/jemplpl.fpl"

    if(argc < 2) {
        jerror::error("Please provide a source file name.\n");
    }

    std::list<std::filesystem::path> templates_to_expand;
    for(int argi = 1; argi < argc; argi++) {
        templates_to_expand.push_back(argv[1]);
    }

    std::list<std::string> generated_code;
    std::set<std::filesystem::path> already_expanded;
    int total_errors = 0;
    for(auto template_fn : templates_to_expand) {
        if(already_expanded.count(template_fn)) {
            continue;
        }
        already_expanded.insert(template_fn);
        fpl_reader_p inp = std::make_shared<fpl_reader>(template_fn);
        if(!inp) {
            jerror::warning(stringformat(
            "failed to create reader for {}",
            std::filesystem::absolute(template_fn).string()
            ));
            total_errors++;
        } else {
            jemplpl_parser parser(inp);
            parser.init(template_fn); // XXX clunky.  figure out better way OHHH duh inp has template_fn
            std::string output = parser.parse();
            if(!output.length()) {
                jerror::warning(stringformat(
                "no output generated for '{}'\n", template_fn
                ));
                total_errors++;
            } else {
                // prepend the generated code so that function definitions
                // from imported jemps come before where they are used:
                generated_code.push_front(output);
                std::cout << parser.output_header(argv[0], template_fn);

                // now, if that imported anything, we'll want to try
                // to pull in the import...
                for(auto imp: parser.jempl.import_files) {
                    templates_to_expand.push_back(imp);
                }
            }
            total_errors += parser.error_count();
        }
    }

    std::cout << join(generated_code, "\n\n");

    return total_errors?1:0;

    #line 18184 "src/jemplpl/jemplpl.cc"

}

#line 1406 "src/fpl2cc/fpl_x_parser.h.jemp" 



