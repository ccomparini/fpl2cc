
#line 4 "src/fpl2cc/fpl_x_parser.h.jemp" 

#ifdef GENERATED_FPL
#define GENERATED_FPL (GENERATED_FPL + 1)
#else
#define GENERATED_FPL 1
#endif

#ifndef jemplpl_parser_H
#define jemplpl_parser_H

/*
  generated by fpl2cc v1.7 from src/fpl2cc/fpl_x_parser.h.jemp

  options:
        src_fpl: src/jemplpl/jemplpl.fpl
    src_path: /Users/chris/projects/fpl2cc/src/grammarlib
    out: 
    output_fn: src/jemplpl/jemplpl.cc
    check_only: false
    debug: false
    debug_types: false
    debug_melds: false
    entry_points: (missing arg 0)
    embed_include_path: 
    generate_code: true
    generate_main: false
    help: false
    single_step: false
    depfile: 
    statedump: src/jemplpl/jemplpl.states
    dump_dependencies: false
    lr_stack_reserve: 1000
    param_stack_reserve: 1000
    new_parser: false


  calculated goal(s):
    { complete }

 */

//  elements:
//    _fpl_null
//    fragment
//    complete
//    text
//    '@@'
//    '@/*'
//    /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
//    '*/@'
//    /\\n\?/
//    '@parameter:'
//    /[^@]+/
//    '@'
//    '@include:'
//    /\\s*/
//    '@embed:'
//    leading_ws
//    /@declare\\s+/
//    identifier
//    ':'
//    /(\?:[^@]|(\?:@@))*/
//    /@realign:\\s*/
//    '#'
//    !'#'
//    template_variant
//    '@-'
//    subst_start
//    '-@'
//    trailing_ws
//    subst_end
//    /(\?:[^-@]|-[^@])+/
//    rest_of_sub
//    /\\n*[ \\t]+/
//    /[ \\t]*\\n+[ \\t]+(\?!@)/
//    /[ \\t]*\\n/
//    /#\\s*/
//    /(\?:[^-{@]|-[^@]|)*\\{/
//    control_start
//    '}'
//    control_end
//    /[^@\\n]+/
//    /[a-zA-Z_][a-zA-Z_0-9]+/
//    ␄_fpl_goal

//  rules:
//     fragment+:fragments -> complete
//    text+:chunks -> fragment
//    '@@':at_sign -> text
//    '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment
//    '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment
//    '@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^ -> fragment
//    '@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^ -> fragment
//    leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment
//    /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment
//    '#'^ !'#':variant_expression '#'^ -> template_variant
//    leading_ws?^ '@-':arg_1 -> subst_start
//    '@':arg_0 -> subst_start
//    '-@':arg_0 trailing_ws?^ -> subst_end
//    '@':arg_0 -> subst_end
//    /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub
//    /\\n*[ \\t]+/:ws -> leading_ws
//    /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws
//    /[ \\t]*\\n/:ws -> trailing_ws
//    subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment
//    subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^ -> control_start
//    subst_start^ '}':control_statement subst_end^ -> control_end
//    control_start:control_statement -> fragment
//    control_end:control_statement -> fragment
//    subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment
//    /[^@\\n]+/:t -> text
//    leading_ws -> text
//    trailing_ws -> text
//    /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier
//    complete -> _fpl_goal


#line 32 "src/fpl2cc/fpl_x_parser.h.jemp" 


#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>


#line 1 "src/util/fs.h" 
#ifndef FS_H
#define FS_H

// creates the namespace "fs" as a hack around <filesystem>
// compatibility issues.

#include <filesystem>

#if __cplusplus <= 199711L
#error because it uses <filesystem>, we need c++11 or better
#endif

#ifdef __APPLE__
// sigh thanks apple
namespace fs = std::__fs::filesystem;
#else
namespace fs = std::filesystem;
#endif

#endif // FS_H


#line 47 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1 "src/util/src_location.h" 
#ifndef SRC_LOCATION_H
#define SRC_LOCATION_H

#include<string>

// we don't have <source_location>.  hence this reinvention.
typedef const std::string &src_location;

#define _CLUDGE_TO_STR(x) #x
#define _CLUDGE_STR(x) _CLUDGE_TO_STR(x)
#define THIS_LINE __FILE__ " line " _CLUDGE_STR(__LINE__)

#ifndef __has_builtin
#define __has_builtin(x) 0
#endif

#if __has_builtin(__builtin_FILE) && __has_builtin(__builtin_LINE)
#define CALLER_FILE() (std::string(__builtin_FILE()))
#define CALLER_LINE() (            __builtin_LINE() )

// CALLER() returns a file/line string
#define CALLER() \
(std::string(__builtin_FILE()) + ":" + std::to_string(__builtin_LINE()))
#else
#define CALLER_FILE() ("(file unavailable)")
#define CALLER_LINE() (0)
#define CALLER() "(caller unavailable)"
#endif


#endif // SRC_LOCATION_H

#line 48 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1 "src/util/to_hex.h" 
#ifndef TO_HEX_H
#define TO_HEX_H

#include<array>
#include<string>

#include<stdio.h>

// returns a string containing a big-endian hex dump
// of the thing passed
template<class T>
std::string to_hex(const T &inst) {
    unsigned char *hack = (unsigned char *)&inst;
    static const char hchr[] = {
        '0', '1', '2', '3', '4', '5', '6', '7',
        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'
    };

        std::string out;
        for(int ind = 0; ind < sizeof(T); ind++) {
            out += hchr[(hack[ind] >> 4) & 0x0f];
            out += hchr[ hack[ind]       & 0x0f];
        }
        return out;
    }

    // Because of various endianess issues, to get reasonable results
    // for various normal ints, we need this.
    template<class T>
    std::string _int_to_hex(T val) {
        int shift = sizeof(val) * 8;
        std::string out;
        out.reserve(2 * sizeof(val)); // 2 chars per byte
        while((shift -= 8) >= 0) {
            out += to_hex(char((val >> shift) & 0xff));
        }

        return out;
    }
    inline std::string to_hex(signed int num) { return _int_to_hex(num); }
    inline std::string to_hex(signed long int num) { return _int_to_hex(num); }
    inline std::string to_hex(signed long long int num) { return _int_to_hex(num); }
    inline std::string to_hex(signed short int num) { return _int_to_hex(num); }
    inline std::string to_hex(unsigned int num) { return _int_to_hex(num); }
    inline std::string to_hex(unsigned long int num) { return _int_to_hex(num); }
    inline std::string to_hex(unsigned long long int num) { return _int_to_hex(num); }
    inline std::string to_hex(unsigned short int num) { return _int_to_hex(num); }

    template<class TT>
    std::string bs_to_hex(const TT &in, const std::string &separator = " ") {
        std::string out;
        for(auto el : in) {
            if(out.length())
            out += separator;
            out += to_hex(el);
        }
        return out;
    }

    #endif // TO_HEX_H

    #line 49 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1 "src/util/utf8.h" 
    #ifndef UTF8_H
    #define UTF8_H

    typedef unsigned char utf8_byte;

    namespace utf8 {

        /**
        
        utf-8 unicode function miscelany.
        
        These are unicode/utf-8 related functions I ripped from other
        code I wrote and which I'm stashing here.  Generally speaking,
        these functions take a utf8_byte pointer and return a size_t
        telling how many bytes at that position match what they were
        asked for.  Also generally, they check if they are passed a
        NULL pointer and return a length of 0 for such.
        
        One could probably split hairs and point out that, despite being
        in the namespace "utf8", these functions are specific to (de-facto
        or official) unicode characters, and utf8 could theoretically be
        used to encode other character sets.  I've never seen that, though.
        
         */

        /**
          Returns true if the pointer passed appears to be within a utf-8
          character (as opposed to being at the start of one); false otherwise.
        
          If this returns true, *at is definitely not the start of a utf-8
          encoded character.  If it returns false, it might be.
        
          Returns false is given a NULL pointer.
         */
        inline bool is_within_character(const utf8_byte *at) {
            if(!at) return false;

            // If the top 2 bits of the byte are 0b10, then
            // it's a continuation byte (i.e. within a character)
            // 0xc0 = 0b11000000
            // 0x80 = 0b10000000
            return (*at & 0xc0) == 0x80;
        }


        /**
          Returns the number of bytes which the pointer passed would have
          to be advanced to get to the "next" character (assuming there is
          one).
        
          This means if the pointer passed points to the start of a utf-8
          encoded character, the number of bytes returned will be the
          length of the character, but if the pointer points to the middle
          of a character, callers can still advance to the ostensible start
          of next character by incrementing by the value returned.  It's
          a best-effort approach.
        
          This all also means (due to the best effort), that if the pointer
          passed points to non-utf-8-encoded data, an arbitrarily large length
          (up to maxlen) may be returned.
        
          Caveat: The maxlen passed is the maximum length which this function
          will examine, and not necessarily the max length returned.  So if,
          say, this is passed a pointer to the last byte of a buffer, but that
          byte indicates a character length of more than one, the length
          returned might indicate a next character outside the buffer.
          However, this function will not attempt to access memory outside
          of maxlen bytes past the pointer passed.
        
          Note also: byte 0x00 is, for purposes of this function, a 1-byte
          character.  So don't use this to look for a 0-length character
          at the end of a string.
        
         */
        inline size_t character_length(const utf8_byte *at, size_t maxlen) {

            if(!at) return 0;

            // https://en.wikipedia.org/wiki/UTF-8#Encoding
            // if the high bit isn't set, it's a single byte:
            if((at[0] & 0x80) == 0) return 1;

            // otherwise, if we're at the start of the character,
            // the top 2 bits will be set, and bits following
            // specify the size.  so if the top 2 bits are set,
            // we'll assume we're at the start of a char and take
            // that byte's word for it on the size:
            if((at[0] & 0xe0) == 0xc0) return 2;  // 0b110x xxxx
            if((at[0] & 0xf0) == 0xe0) return 3;  // 0b1110 xxxx
            if((at[0] & 0xf8) == 0xf0) return 4;  // 0b1111 0xxx

            // looks like we're in the middle of a character,
            // so count bytes until we're no longer within the
            // character:
            int len = 1;
            for( ; len < maxlen; ++len) {
                if(!is_within_character(at + len))
                break;
            }

            return len;
        }

        /*
          Returns the length in bytes of the newline character at the
          position passed (which will be 0 if it's not a newline).
        
          Note:  This covers de-facto newlines (such as the MS Windows/MS DOS
          0x0d 0x0a newline) as well as official unicode newlines.
        
         */
        inline size_t newline_length(const utf8_byte *at) {
            // For our purposes, any 2 bytes in a row with one each of 0x0a
            // and 0x0d counts as a single newline (which covers Microsoft
            // newlines and some old-fashioned newlines).  Also, either of
            // 0x0d or 0x0a alone counts as a newline (which covers unix
            // newlines and some other old fashioned newlines).

            // Do we want to count other unicode newlines?
            //  https://www.unicode.org/standard/reports/tr13/tr13-5.html
            // this^^ implies yes;  on the other hand, is it more confusing
            // if people put weird newlines in their source code?
            // Probably.  But, for consistency, we probably should - we
            // do already count them as spaces.
            // (Perhaps pass a flag so the caller can say what they want?)

            if(at == NULL)  return 0;

            if(at[0] == 0x0d) {
                if(at[1] == 0x0a) return 2; // Microsoft newline
                return 1; // OS-9 style newline (heh)
            }

            if(at[0] == 0x0a) {
                if(at[1] == 0x0d) return 2; // weirdo old British newline
                return 1; // normal unix newline
            }

            return 0;
        }

        /*
          Returns the length in bytes of the utf-8 character at *at,
          or 0 if that character isn't a space.
         */
        inline size_t space_length(const utf8_byte *at) {
            if(at == NULL) return 0;

            switch(*at) {
                // ascii ones are simple and common:
                case 0x09:    // character tabulation (aka "tab")
                case 0x0A:    // line feed
                case 0x0B:    // line tabulation
                case 0x0C:    // form feed
                case 0x0D:    // carriage return
                case 0x20:    // space
                return 1;
                case 0xc2:
                if(at[1] == 0x85) return 2; // U+0085 = next line
                if(at[1] == 0xa0) return 2; // U+00A0 = no-break space
                return 0;
                case 0xe1:
                if(at[1] == 0x9a && at[2] == 0x80)
                return 3; // 0xe1,0x9a,0x80 = U+1680 = ogham space mark
                return 0;
                case 0xe2:
                if(at[1] == 0x80) {
                    if(at[2] >= 0x80 && at[2] <= 0x8a) {
                        // 0xe2,0x80,0x80 -> U+2000 = en quad
                        // 0xe2,0x80,0x81 -> U+2001 = em quad
                        // 0xe2,0x80,0x82 -> U+2002 = en space
                        // 0xe2,0x80,0x83 -> U+2003 = em space
                        // 0xe2,0x80,0x84 -> U+2004 = three-per-em space
                        // 0xe2,0x80,0x85 -> U+2005 = four-per-em space
                        // 0xe2,0x80,0x86 -> U+2006 = six-per-em space
                        // 0xe2,0x80,0x87 -> U+2007 = figure space
                        // 0xe2,0x80,0x88 -> U+2008 = punctuation space
                        // 0xe2,0x80,0x89 -> U+2009 = thin space
                        // 0xe2,0x80,0x8a -> U+200A = hair space
                        return 3;
                    }

                    if(at[2] == 0xa8)
                    return 3; // 0xe2,0x80,0xa8 -> U+2028 = line separator

                    if(at[2] == 0xa9)
                    return 3; // 0xe2,0x80,0xa9 -> U+2029 = paragraph separator

                    if(at[2] == 0xaf)
                    return 3; // 0xe2,0x80,0xaf -> U+202F = narrow no-break sp.

                } else if(at[1] == 0x81 && at[2] == 0x9f) {
                    return 3; // 0xe2,0x81,0x9f -> 205F = medium mathematical space
                }
                return 0;

                case 0xe3:
                if(at[1] == 0x80 && at[2] == 0x80)
                return 3; // 0xe3,0x80,0x80 = U+3000 ideographic space
                return 0;

                default:
                // not space
                return 0;
            }

            // can't get here.
        } 

    } // end namespace utf8


    #endif // UTF8_H

    #line 50 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1 "src/util/c_str_escape.h" 
    #ifndef C_STR_ESCAPE_H
    #define C_STR_ESCAPE_H

    #include<string>

    /*
       Returns a version of the string passed which is suitable for
       embedding in a c (or c++) program
     */
    inline std::string c_str_escape(const std::string src) {
        std::string escaped;
        for(const uint8_t &inch : src) {
            switch(inch) {
                case 0x00: escaped += "\\0";  break;
                case 0x07: escaped += "\\a";  break; // Alert (Beep, Bell)
                case 0x08: escaped += "\\b";  break; // Backspace
                case 0x0C: escaped += "\\f";  break; // Formfeed Page Break
                case 0x0A: escaped += "\\n";  break; // Newline (Line Feed)
                case 0x0D: escaped += "\\r";  break; // Carriage Return
                case 0x09: escaped += "\\t";  break; // Horizontal Tab
                case 0x0B: escaped += "\\v";  break; // Vertical Tab
                case 0x5C: escaped += "\\\\"; break;
                case 0x22: escaped += "\\\""; break;
                case 0x3F: escaped += "\\?";  break; // (to avoid trigraphs)
                default:
                if(inch < 0x20 || inch == 0x7f) {
                    // other non-printable ascii char not handled above.
                    // note that this will (effectively) cover utf-8
                    // or whatever - it's a case of "bytes is bytes".
                    char buf[23]; // 23 is a lucky number larger than 5 :P

                    // we use octal instrad of hex because hex escape
                    // sequences are arbitrarily long, which means that
                    // (eg) "foo\x23bar" would actully be interpreted
                    // as "foo" "\x23ba" "r" (since b and a are both
                    // hex digits).  I find this counter intuitive but
                    // that's how it works.  I believe it's because char
                    // size is not necessarily 8 bits, as far as c is
                    // concerned.  However, for whatever reason, octal
                    // escapes are always 3 octal digits, so octal
                    // doesn't have that problem.
                    snprintf(buf, sizeof(buf), "\\%03o", unsigned(inch) & 0xff);
                    escaped += buf;
                } else {
                    // either normal, or utf-8.  just copy it verbatim! yay
                    escaped += inch;
                }
                break;
            }
        }
        return escaped;
    }

    #endif // C_STR_ESCAPE_H

    #line 51 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1 "src/util/is_iterable.h" 
    #ifndef IS_ITERABLE_H
    #define IS_ITERABLE_H

    #include<iterator>
    #include<type_traits>

    /*
       Defines an is_iterable() macro which (in theory) you can use to determine
       if a given type is iterable.
    
       usage:
       if constexpr(is_iterable(some_type)) {
            ... 
       }
    
       I don't know why there's no standard/built in way to do this.  Maybe there
       is one.  Whatever.  this works well enough.  Moving on.
     */

    template <typename T, typename = int>
    struct _is_iterable
    : std::false_type
    {};

    // uhh let's say it's iterable if it has a "begin" method
    // (or, sloppily, anything called "begin")
    // or actually apparently... gah I hate c++.
    // just try to make something work at all.  std::begin.
    // whatevs.  shipit.
    // checking std::begin allows this to work with arrays.
    template <typename T>
    struct _is_iterable <T, decltype(std::begin(std::declval<T&>()), 0)>
    : std::true_type
    {};

    #define is_iterable(type) (_is_iterable<type>::value)

    #endif // IS_ITERABLE_H

    #line 52 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1 "src/util/stringformat.h" 
    #ifndef STRINGFORMAT_H
    #define STRINGFORMAT_H

    #ifndef GENERATED_FPL
    #include "c_str_escape.h"
    #include "is_iterable.h"
    #include "to_hex.h"
    #endif

    #include <cstdlib>
    #include <ctype.h>
    #include <list>
    #include <tuple>

    // OK SO #include<format> doen't seem to exist on my machine.
    // let the reinvention commence.
    // Oh, interesting. this is a nightmare in c++.

    //inline std::string _stringformat(const utf8_byte *s) {
    inline std::string _stringformat(const uint8_t *s) {
        if(!s) {
            return "";
        } else {
            return std::string((const char *)s);
        }
    }

    inline std::string _stringformat(const char *s) {
        if(!s) {
            return "";
        } else {
            return std::string(s);
        }
    }

    inline std::string _stringformat(char * s) {
        return std::string(s);
    }

    inline std::string _stringformat(char c) {
        return std::string(1, c);
    }

    inline std::string _stringformat(bool b) {
        if(b) return "true";
        return "false";
    }

    // You can call to_string on normal c types such
    // as int, float etc and expect a reasonable result,
    // but there's no such (identity) sub for std::string.
    // Supplying one here makes the _stringformat template
    // version below work for things which can convert
    // themselves to string.  (sigh)
    inline std::string to_string(const std::string &in) {
        return in;
    }

    // this must be declared BEFORE the most general _stringformat,
    // or else it never gets matched, but since it calls the
    // more general one, the definition is later
    template <typename T, typename U>
    std::string _stringformat(std::pair<T, U> &x);

    // some alternative syntax models I think the WG21 should
    // consider for templates:
    //   http://shakespearelang.sourceforge.net/report/shakespeare/shakespeare.html
    //   https://www.dangermouse.net/esoteric/chef.html

    // the next 2 templates are c++ hackery to detect if a thing
    // passed has a to_str() method:
    template <typename T, typename = int>
    struct _has_to_str
    : std::false_type
    {};

    template <typename T>
    struct _has_to_str <T, decltype(&T::to_str, 0)>
    : std::true_type
    {};

    template <typename T, typename = void>
    struct _to_string_exists_for
    : std::false_type
    {};

    template <typename T>
    struct _to_string_exists_for<T,
    std::void_t<decltype(to_string(std::declval<T>()))>>
    : std::true_type
    {};

    template <typename T, typename = void>
    struct _std_to_string_exists_for
    : std::false_type
    {};

    template <typename T>
    struct _std_to_string_exists_for<T,
    std::void_t<decltype(std::to_string(std::declval<T>()))>>
    : std::true_type
    {};

    template<typename T>
    //std::string _stringformat(const T &in, const std::string &opts = "") {
    std::string _stringformat(T &in, const std::string &opts = "") {
        if constexpr (std::is_convertible_v<T, std::string> or
        std::is_convertible_v<T, std::string_view>) {
            // it's either already a string or directly convertible
            return in;
        } else if constexpr (_has_to_str<T>::value) {
            // it has a to_str method, so use that:
            return in.to_str();
        } else if constexpr (_to_string_exists_for<T>::value) {
            // second choice is a supplied to_string
            return to_string(in);
        } else if constexpr (_std_to_string_exists_for<T>::value) {
            // ... or fall back on std::to_string:
            return std::to_string(in);
        } else if constexpr (is_iterable(T)) {
            // or if it's iterable, recursively compose something
            // from its elements:
            std::string out;
            for(auto el = in.begin(); el != in.end(); ++el) {
                if(std::next(el) == in.end())
                out += _stringformat(*el);
                else
                out += _stringformat(*el) + ", ";
            }
            return "{ " + out + " }";
        } else {
            // otherwise the best we can do is hex dump:
            return "0x" + to_hex(in);
        }
    }

    template<typename... Args>
    std::string _stringformat(std::tuple<Args...> &in) {
        // I read online someplace that std::pair was a special case
        // of std::tuple, so I was hoping this would cover std::map
        // entries, but of course it doesn't.  why would I expect
        // any generality?  whatevs.  leaving it because it does
        // work for std::tuple.
        std::string out;
        std::apply([&out](auto &&... args) {
            const int num_args = sizeof...(args);
            const std::string str_arg[] = { _stringformat(args) ... };
            for(int argn = 0; argn < num_args; argn++) {
                if(argn > 0) {
                    out += ", ";
                }
                out += str_arg[argn];
            }
        }, in);
        return "( " + out + " )";
    }

    template <typename T, typename U>
    std::string _stringformat(std::pair<T, U> &x) {;
    return _stringformat(x.first) + " => " + _stringformat(x.second);
};

// (as above, but const pair)
template <typename T, typename U>
std::string _stringformat(const std::pair<T, U> &x) {;
return _stringformat(x.first) + " => " + _stringformat(x.second);
};

class stringformat_post_processor {
// {::c} -> columnate output (on tabs)
static std::string c(const std::string &in) {
    std::list<int> colwidths;

    // find out the starts and widths of the columns:
    int cw = 0;
    colwidths.push_back(0);
    auto col = colwidths.begin();
    for(size_t pos = 0; pos < in.length(); ++pos) {
        cw++; // (the column terminator counts as part of the column)
        // tab, newline, or end of string ends the column:
        if(in[pos] == '\t' || in[pos] == '\n' || (pos + 1 >= in.length())) {
            if(cw > *col) {
                *col = cw;
            }

            if(std::next(col) == colwidths.end())
            colwidths.push_back(0);

            // .. and newline puts us back to the first column:
            if(in[pos] == '\n') col = colwidths.begin();
            else                col = std::next(col);
            cw = 0;
        }
    }

    std::string out;
    auto colw = colwidths.begin();
    for(size_t pos = 0; pos < in.length(); pos++) {
        size_t eoc = in.find_first_of("\t\n", pos);
        if(eoc == std::string::npos) eoc = in.length();

        size_t len = eoc - pos;
        out += in.substr(pos, len);

        if(in[eoc] == '\n' || std::next(colw) == colwidths.end()) {
            out += "\n";
            colw = colwidths.begin();
        } else {
            for(int pad = 0; pad < *colw - len; ++pad)
            out += " ";
            colw = std::next(colw);
        }

        pos = eoc;
    }
    return out;
}

// {::e} -> do a c string ecape
static std::string e(const std::string &in) {
    return c_str_escape(in);
}

// {::i} -> indent by the level indicated in the string
// (which needs to be numeric, but, annoyingly, will
// already have been stringformatted)
static std::string i(const std::string &in) {
    int indent = 0;
    int exponent = 1;
    for(int ch = in.length() - 1; ch >= 0; --ch) {
        if((in[ch] < '0') || (in[ch] > '9')) {
            // non-numeric "digit" - just pop out of the loop.
            // in theory we -could- reasonably do something
            // with negatives, but let's not for now.
            break;
        } else {
            indent += (in[ch] - '0') * exponent;
            exponent *= 10;
        }
    }
    std::string out;
    for(int len = 0; len < indent; len++) {
        out += "  ";
    }
    return out;
}

// {::n} -> translate newlines to "\n"
static std::string n(const std::string &in) {
    std::string out;
    size_t last_pos = 0;
    size_t pos = in.find("\n");
    for( ; pos != std::string::npos; pos = in.find("\n", last_pos)) {
        out += in.substr(last_pos, pos - last_pos);
        out += "\\n";
        last_pos = pos + 1;
    }
    out += in.substr(last_pos);

    return out;
}

// {::U} -> translate characters to upper case
static std::string U(const std::string &in) {
    std::string out;
    for(auto ch : in) {
        out += toupper(ch);
    }
    return out;
}

// {::l} -> translate characters to lower case
static std::string l(const std::string &in) {
    std::string out;
    for(auto ch : in) {
        out += tolower(ch);
    }
    return out;
}

public:
static std::string process(char fmt, const std::string &in) {
    switch(fmt) {
        case 'c': return c(in);  // columnate (tab-delimited)
        case 'e': return e(in);  // c-string escape
        case 'i': return i(in);  // indent this level
        case 'l': return l(in);  // lowercase
        case 'n': return n(in);  // translate newlines to '\n'
        case 'U': return U(in);  // uppercase
    }
    // .. would be nice to warn about missing format here....
    return in;
}
};

template <typename... Args>
std::string stringformat(std::string_view fmt, Args&&... args) {

const int num_args = sizeof...(args);
// ok this works at all - string convert each argument,
// before and regardless of if it's going to be used.
// it sucks because we can't determine how to format
// a given argument before we format it.  is this why
// clang isn't shiping with an implementation?
// ok whatevs shipit.
const std::string str_arg[] = { _stringformat(args) ... };

// possibly better syntax.  see the notes file.

// ok whatevs here's something kinda like format():
// https://en.cppreference.com/w/cpp/language/parameter_pack
// OMG you cannot iterate the Args list.  you have to recurse.
// oh but you _can_ expand to a tuple and sorta iterate that,
// but not at run time.
// I _think_ the c++ way you have to do this backwards
// and for each agument substitute that arg into the string,
// as opposed to going through the string as I'm doing. ohwell.
std::string out;
const size_t inlen = fmt.size();
if(inlen == 0) return ""; // (because inlen might be unsigned)

int argi = 0;
size_t ind;
for(ind = 0; ind < inlen; ++ind) {
    if(fmt[ind] == '{') {
        ++ind; // skip the begin brace
        if(fmt[ind] == '{') {
            // '{{' evaluates to a single '{' (it's how you escape '{')
            out += '{';
        } else {
            // parse the contents of the {}:
            // Within {}, let's say the _future_ format is:
            //  [ variable name ] [':' [ to-string function ] [':' [ post processing ] ] ]
            // But, we can't, presently, because we can't see the names
            // of the parameters and we've already converted everything
            // to string.  So let's allow numeric parameter index instead
            // of the variable name.
            size_t ts_ind = 0; // pos of to-string function, if any
            size_t pp_ind = 0; // pos of post processing function, if any
            long arg_num = argi;
            if(fmt[ind] >= '0' && fmt[ind] <= '9') {
                const char *istart = fmt.data() + ind;
                char       *iend   = const_cast<char *>(istart + 1);
                arg_num = strtol(istart, &iend, 10);
                ind += iend - istart - 1;
            }
            while(fmt[ind] && (fmt[ind] != '}')) {
                if(fmt[ind] == ':') {
                    if(!ts_ind)
                    ts_ind = ind + 1;
                    else if(!pp_ind)
                    pp_ind = ind + 1;
                    // else for now we're ignoring spurious ':'
                }
                ind++;
            }

            if(arg_num < num_args) {
                std::string sub = str_arg[arg_num];
                if(ts_ind) {
                    while(fmt[ts_ind]) {

                        ts_ind++;
                        if(fmt[ts_ind] == ':' || fmt[ts_ind] == '}')
                        break;
                    }
                }
                if(pp_ind) {
                    while(fmt[pp_ind]) {
                        sub = stringformat_post_processor::process(
                        fmt[pp_ind], sub
                        );
                        pp_ind++;
                        if(fmt[pp_ind] == ':' || fmt[pp_ind] == '}')
                        break;
                    }
                }
                out += sub;
            } else {
                out += "(missing arg " + std::to_string(arg_num) + ")";
            }
            argi++;
        }
    } else if((fmt[ind] == '}') && (fmt[ind + 1] == '}')) {
        // turn '}}' into a single '}' so that we can balance
        // braces if there's an embedded '{{' (by doing nothing
        // here and thus skipping the first '}')
    } else {
        out += fmt[ind];
    }
}

return out;
}

// returns the string passed, with an extra newline at the end
// if the string didn't have one already.
inline std::string ensure_nl(const std::string &src) {
if(src[src.length() - 1] != '\n') 
return src + "\n";

return src;
}


#endif // STRINGFORMAT_H


#line 53 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1 "src/util/jerror.h" 
#ifndef JERROR_H
#define JERROR_H

#include <functional>
#include <list>
#include <iostream>
#include <string>

#ifndef GENERATED_FPL
#include "util/src_location.h"
#include "util/stringformat.h"
#endif // GENERATED_FPL

/* 
 "jest" error system ... or to-be.  I had to call it something.
 
  Usage:

     void my_error_handler(const std::string &msg, src_location caller) { ... }
     void my_warning_handler(const std::string &msg), src_location caller ...

     // install my_error_handler_func as the error handler
     // (they need names so that the destructors don't get
     // called right away)
     jerror::handler x(jerror::error_channel, my_error_handler);
     jerror::handler y(jerror::warning_channel, my_warning_handler);

     if(something_of_concern)
         jerror::warning("we have concerns...");
 
     if(something_bad)
         jerror::error("something bad happened");

 Applications or libraries calling jerror::error should _not_ assume 
 that the program or function or anything will terminate, but they
 should also not assume they won't.
 
 Why not use exceptions?  C++ exceptions don't allow warn vs error.
 Also, c++ exceptions lean heavily on making a new type for everything
 which can go wrong, which is a pain.  Also, this lets the receiving
 handler know the src_location whence the error or warning was sent.

 */
class jerror {
public:
using channel = enum {
    error_channel   = 0,
    warning_channel,
    NUM_CHANNELS
};

using callback = std::function<
void(const std::string &error, src_location caller)
>;
using callback_with_channel = std::function<
void(channel chan, const std::string &error, src_location caller)
>;

private:
using handler_stack = std::list<callback_with_channel>;

static inline handler_stack channels[NUM_CHANNELS];

static void on_msg(
channel chan, const std::string &msg, src_location caller
) {
    handler_stack handlers = channels[chan];

    if(handlers.size()) {
        (handlers.back())(chan, msg, caller);
    } else {
        if(chan > error_channel) {
            std::cerr << ensure_nl(stringformat("{} at {}", msg, caller));
        } else {
            std::cerr << ensure_nl(stringformat("Fatal error: {}\tat {}", msg, caller));
            exit(2112);
        }
    }
}

static void push_handler(
channel chan, callback_with_channel cb, src_location caller
) {
    if((chan >= 0) && (chan < NUM_CHANNELS)) {
        jerror::channels[chan].push_back(cb);
    } else {
        error(stringformat(
        "{} Can't install handler - there's no channel {}\n",
        caller, chan
        ));
    }
}

static void pop_handler(channel chan) {
    if((chan >= 0) && (chan < NUM_CHANNELS)) {
        jerror::channels[chan].pop_back();
    }
}

public:

// handler is a class so that it can push itself to the handler list
// and pop itself when it goes out of scope
class handler {
    channel which_chan;
    public:
    handler(channel chan, callback cb, src_location caller = CALLER()) :
    which_chan(chan) {
        push_handler(
        which_chan,
        [cb](channel, const std::string &err, src_location caller) {
            cb(err, caller);
        },
        caller
        );
    }

    handler(channel chan, callback_with_channel cb, src_location caller = CALLER()) :
    which_chan(chan) {
        push_handler(which_chan, cb, caller);
    }

    ~handler() {

        pop_handler(which_chan);
    }
};

// call this to throw an error.
// calls the most recently installed error handler, or, if
// there's no such thing installed, prints an error message
// and aborts.
static void error(
const std::string &msg, src_location caller = CALLER()
) {
    on_msg(error_channel, msg, caller);
}

static void warning(
const std::string &msg, src_location caller = CALLER()
) {
    on_msg(warning_channel, msg, caller);
}
};

#endif // JERROR_H


#line 54 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1 "src/util/utf8_buffer.h" 
#ifndef UTF8_BUFFER_H
#define UTF8_BUFFER_H

#ifndef GENERATED_FPL
#include "jerror.h"
#include "src_location.h"
#include "utf8.h"
#endif // GENERATED_FPL

#include <cstring>
#include <fstream>
#include <string>
#include <vector>

struct utf8_buffer : public std::basic_string<utf8_byte> {
std::string source;

utf8_buffer(int dummy = 0, src_location caller = CALLER()) :
source(caller) { }

explicit utf8_buffer( 
const utf8_byte *src,
size_t num_bytes = -1,
src_location caller = CALLER()
) :
source(caller)
{
    if(num_bytes == -1)
    num_bytes = std::strlen((const char *)src);

    assign(src, num_bytes);
}

explicit utf8_buffer(
const std::string &fn, src_location caller = CALLER()
) {
    slurp_file(fn, caller);
}

utf8_buffer(std::istream &in, src_location caller = CALLER()) {
    slurp_stream(in, caller);
}

void slurp_file(const std::string &fn, src_location caller = CALLER()) {
    source = fn;

    std::ifstream in(fn);
    if(!in.is_open()) {
        jerror::error(stringformat(
        "{} can't open '{}': {}",
        caller, fn, std::string(strerror(errno))
        ), caller);
    }

    in.seekg(0, std::ios::end);
    const size_t filesize = in.tellg();
    in.seekg(0, std::ios::beg);

    std::vector<utf8_byte> buf(filesize + 1);
    in.read(reinterpret_cast<char *>(buf.data()), filesize + 1);
    buf[filesize] = '\0';
    assign(buf.data(), buf.size());
}

void slurp_stream(std::istream &in, src_location caller = CALLER()) {
    // This one's annoying, because it may be coming from a
    // file, but afaik there's no way to get the filename (or
    // file descriptor or anything else useful about where the
    // stream is from).  should never have used c++ streams.. sigh.
    source = caller;

    const size_t bufsize = 2<<16;
    utf8_byte buf[bufsize];
    while(!in.eof()) {
        in.read((char *)buf, bufsize - 1);
        size_t bytes_read = in.gcount();
        buf[bytes_read] = '\0';
        *this += buf;
    }
    *this += '\0';
}

/**
        Returns a vector containing the offsets of the
        start of each line in the buffer.

        To match normal line number conventions, the vector
        is 1-based - i.e., line_starts()[1] is the start of
        the first line in the file.  line_starts()[0] happens
        to be the same as line 1, but that may change in
        the future.

     */
std::vector<size_t> line_starts() const {
    std::vector<size_t> out;

    // line numbers are traditionally 1-based.
    // so, push 0 as the 0th line position.
    // (it has to be 0 because the line starts must
    // be ordered, and size_t is supposed to be unsigned,
    // and line 1 will start at 0)
    out.push_back(0);

    // first line starts at start of buffer:
    out.push_back(0);
    size_t pos = 0;
    while(pos < size()) {
        if(size_t nl_len = utf8::newline_length(data() + pos)) {
            out.push_back(pos + nl_len);
            pos += nl_len;
        } else {
            ++pos;
        }
    }

    return out;
}

/**
       Helper function for getting a line number from the result
       of line_starts().

       I would have thought that std::lower_bound would do this (i.e.
       return the lower bound of the range containing the value
       passed - hence the whole line_starts() approach), but it does
       not.  I'm not sure why it's named the way it is.  Anyway,
       use this instead.
     */
static int line_number(
const std::vector<size_t> &lines, size_t position
) {
    // size_t isn't supposed to be signed, so this probably
    // can't happen, but you never know:
    if(position < 0)
    return 0;

    auto ub = std::upper_bound(lines.begin(), lines.end(), position);
    // upper_bound -does- do at least aproximately what you would
    // expect: that is, it returns the first element whose value is
    // greater than the value passed.  So, in our case, it's the
    // start of the next line, and hence our line is the entry before
    // it.  Decrementing here is safe because we store 0 in the first
    // (and 0th) line entries, so the earliest possible thing
    // upper_bound can return is past those entries.
    --ub;
    return ub - lines.begin();
}

std::string to_str() const {
    return std::string((const char *)c_str());
}
};


#endif // UTF8_BUFFER_H

#line 55 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1 "src/fpl2cc/fpl_reader.h" 
#ifndef FPL_READER_H
#define FPL_READER_H

/*
   The c++ standard regex engine doesn't work on streams or anything
   like that, so for now anyway we just buffer the entire input.
   Hence this class.
 */

#include <fstream>
#include <functional>
#include <memory>
#include <regex>
#include <string>

#ifndef GENERATED_FPL
#include "util/fs.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"
#include "util/to_hex.h"
#include "util/utf8.h"
#include "util/utf8_buffer.h"
#endif // GENERATED_FPL

class fpl_reader;
using fpl_reader_p = std::shared_ptr<fpl_reader>;
using fpl_reader_p_c = std::shared_ptr<const fpl_reader>;

using ErrorCallback = std::function<void(const std::string &error)>;

using LengthCallback = std::function<size_t(const utf8_byte *inp)>;


class fpl_reader {

std::string input_filename;
utf8_buffer buffer;

std::vector<size_t> line_start;

ErrorCallback on_error;
size_t read_pos;

// ... surely there's a better way to get an empty match set..?
std::cmatch empty_match;
inline std::cmatch no_match() {
    if(!empty_match.ready()) {
        // generate an empty match set by looking for an arbitrary
        // character in an empty string.  there must be a better way..
        std::regex_search("", empty_match, std::regex("a"));
    }
    return empty_match;
}

// Returns true if the position passed would be eof.
// Throws an error (and returns true) if the position
// is entirely outside the buffer.
// See also the simpler eof() in the public section
inline bool eof(size_t off, src_location caller = CALLER()) const {
    bool is_eof = false;
    if(off >= buffer.length()) {
        // we're completely outside the buffer. count it as
        // eof; in any case callers should not expect reads
        // from that position to work
        is_eof = true;

        // call the on_error callback directly, since the
        // line number is going to be invalid anyway:
        on_error(stringformat(
        "{}: test for eof at invalid offset {} (0x{})",
        caller, off, to_hex(off)
        ));
    } else {
        // else it's eof if we're at the last byte of the file
        is_eof = off == buffer.length() - 1;
    }
    return is_eof;
}

// returns a pointer to the next byte of the input
// buffer.
inline const utf8_byte *inpp() const {
    return buffer.data() + read_pos;
}

// as above, but with a relative offset.
// returns a pointer to the end of the buffer if the
// offset is outside the buffer.
inline const utf8_byte *inpp(size_t offset) const {
    size_t full_pos = read_pos + offset;
    if(full_pos >= buffer.length()) {
        full_pos = buffer.length() - 1;
    }
    return buffer.data() + full_pos;
}

// as inpp(), above, but returns as a const char *
// for ease in passing to standard library stuff.
inline const char *inpp_as_char(size_t offset = 0) const {
    return reinterpret_cast<const char *>(inpp(offset));
}

// returns the line number for the position passed,
// or 0 if pos is before the start of the buffer
// or the number of the last line in the file if pos
// is past the end of the buffer.
// if *off is non-null, records the (1-based) byte
// offset of the position within the line as well.
inline int calc_line_number(
size_t at, int *off, const std::string &caller = CALLER()
) const {

    auto line_num = utf8_buffer::line_number(line_start, at);

    if(off) {
        // store the offset within the line as well,
        // since we've been asked to.  as with lines,
        // offsets are 1 based - hence the +1.
        *off = at - line_start[line_num] + 1;
    }

    return line_num;
}

public:

// default error callback/handler:
static void default_fail(const std::string &msg) {
    fprintf(stderr, "%s\n", msg.c_str());
    exit(1);
}

explicit fpl_reader(
std::istream &input,
const std::string &infn,
ErrorCallback ecb = &default_fail
) :
input_filename(infn),
buffer(input),
on_error(ecb),
read_pos(0) {

    line_start = buffer.line_starts();
}

explicit fpl_reader(
const utf8_buffer &input,
const std::string &infn,
ErrorCallback ecb = &default_fail
) :
input_filename(infn),
buffer(input),
on_error(ecb),
read_pos(0) {
    // for better or worse, we explicitly end the
    // input buffer with a \0:
    buffer.push_back('\0');

    line_start = buffer.line_starts();
}

explicit fpl_reader(
const std::string &infn,
ErrorCallback ecb = &default_fail
) :
input_filename(infn),
buffer(infn),
on_error(ecb),
read_pos(0) {

    line_start = buffer.line_starts();
}

inline size_t current_position() const {
    return read_pos;
}

// total bytes buffered as of now
inline size_t total_bytes() const {
    return buffer.length();
}

inline size_t bytes_left() const {
    return total_bytes() - current_position();
}

// returns the 1-based line number for the position passed.
// positions past the end of the file evaluate to the last
// line in the file.
// if the offset pointer passed is non-null, the utf-8 char
// offset within the line is saved there.
inline int line_number(
size_t pos, int *offset = nullptr, src_location &caller = CALLER()
) const {
    return calc_line_number(pos, offset, caller);
}

// as above, but returns the current input line number
inline int line_number(
int *offset = nullptr, src_location &caller = CALLER()
) const {
    return line_number(read_pos, offset, caller);
}

inline const std::string &filename() const {
    return input_filename;
}

inline std::string location_str(size_t offset=0) const {
    if(offset == 0) offset = read_pos;
    int ch;
    int ln = line_number(offset, &ch);
    return stringformat("{}:{}:{}", filename(), ln, ch);
}

std::string base_name() const {

    std::string infn = fs::path(input_filename).filename();

    // "base name" is everything before the first "."
    // in the filename...
    size_t end_of_base = infn.find(".");
    if(end_of_base > 0) {
        return infn.substr(0, end_of_base);
    }

    // .. or, if there's no ".", it's the whole filename:
    return infn;
}

// returns the directory portion of the path to the input file
std::string input_dir() const {
    fs::path in = fs::path(input_filename);
    in.remove_filename();
    return in;
}

inline bool eof(src_location caller = CALLER()) const {
    return eof(read_pos, caller);
}

inline utf8_byte peek(int offset = 0) const {
    return *inpp(offset);
}

// returns the next utf-8 char (at offset relative to the
// read pointer) as a std::string.
inline std::string next_char(int offset = 0) const {
    return std::string(inpp_as_char(offset), char_length(offset));
}

// formats an error message in the context of this reader.
std::string format_error_message(
size_t pos,
const std::string &msg,
src_location caller = CALLER()
) const {
    const char *nl = "";
    if(msg[msg.length() - 1] != '\n')
    nl = "\n";

    return stringformat("Error {} near «{}»: {}{}",
    location_str(pos), debug_peek(pos, 12), msg, nl
    );
}


// Returns the length in bytes of the newline "character" at the
// position passed.
// Any 2 bytes in a row with one each of 0x0a and 0x0d counts as
// a single newline (which covers Microsoft newlines and some
// old-fashioned newlines).  Also, either of 0x0d or 0x0a alone
// counts as a newline (which covers unix newlines and some other
// old fashioned newlines).
// If at isn't pointing to a newline, returns 0.
size_t newline_length(size_t at) const {
    if(at >= buffer.length())
    return 0;

    return utf8::newline_length(buffer.data() + at);
}


private:
// Returns the length in bytes of the the character at the absolute
// position passed.  Chracters ar positions outside the read buffer
// count as 0-byte chars.  Multi-byte newlines are counted as one
// multi-byte character.
size_t char_length_abs(size_t pos) const {
    if(pos >= buffer.length()) {
        return 0;
    }

    if(size_t nll = newline_length(pos)) {
        return nll;
    }

    return utf8::character_length(
    buffer.data() + pos, buffer.length() - pos
    );
}

public:
// Returns the length in bytes of the the character at the relative
// position passed. (relative to the current read pointers)
// For purposes of this function, a character is a single utf-8 encoded
// character, or a multi-ascii-character newline such as is used by
// ms dos and descendants (which we count as one character).
// If the position passed is in the middle of a character, returns
// the length of the remaining bytes (or tries to - GIGO, at this point).
// Returns 0 if given a NULL pointer.
size_t char_length(size_t offset = 0) const {
    return char_length_abs(offset += read_pos);
}

inline void go_to(size_t position) {
    read_pos = position;
    if(read_pos >= buffer.length()) {
        read_pos = buffer.length() - 1;
    } else if(read_pos < 0) {
        read_pos = 0;
    }
}

void go_to_line(unsigned int line) {
    if(line < line_start.size()) {
        go_to(line_start[line]);
    } // else toss an error?
}

inline size_t skip_bytes(size_t skip) {
    size_t start = read_pos;
    go_to(read_pos + skip);
    return read_pos - start;
}

// moves the read pointer past the next character
// and returns the number of bytes it was advanced
size_t eat_char() {
    return skip_bytes(char_length());
}

static size_t space_length(const utf8_byte *inp) {
    return utf8::space_length(inp);
}

size_t separator_length(LengthCallback separator_cb = &space_length) {
    size_t len = 0;
    while(size_t adv = separator_cb(inpp(len))) {
        len += adv;
    }

    return len;
}

size_t eat_separator(LengthCallback separator_cb = &utf8::space_length) {
    return skip_bytes(separator_length(separator_cb));
}

inline char read_byte() {
    if(const utf8_byte *in = inpp()) {
        read_pos++;
        return *in;
    }
    return '\0';
}

inline bool read_byte_equalling(utf8_byte this_byte) {
    if(const utf8_byte *in = inpp()) {
        if(*in == this_byte) {
            read_pos++;
            return true;
        }
    }
    return false;
}

inline bool read_byte_not_equalling(utf8_byte this_byte) {
    if(const utf8_byte *in = inpp()) {
        if(*in != this_byte) {
            read_pos++;
            return true;
        }
    }
    return false;
}

// given the first byte of a potential string, returns
// the byte to expect to use for the end of that string.
// this is a helper for parse_string(), below.
utf8_byte string_end_delimiter(utf8_byte start) {
    switch(start) {
        case '\'': return '\'';
        case '"':  return '"';
        case '`':  return '`';
        case '/':  return '/'; // used for regex
    }
    return '\0';
}

//
// Reads and returns the string of characters delimited by the
// start-of-string delimiter at the current input position.
//
// For example, if the current input is on the single quote
// at the start of:
//        'fruitbat'; # hi this is a line of code
// this reads the "'" and infers that that's the delimiter, then
// reads through the next "'", returning a string containing
// "fruitbat", and leaving the read pointer on the ';'.
//
// End delimiters (and any other byte!) can be escaped with a
// backslash.  Note, however, that we always leave the backslash
// in - otherwise it would hide things like newlines encoded as
// '\n' from callers.
//
// If the initial character doesn't look like anything which
// can be used as a string delimiter, we return an empty string.
// 
// If there's no closing delimiter, it'll return everything up
// to the end of input and leave the read pointer there.
//
// Caveats:
//   - there's a good chance I'm going to deprecate/remove this
//   - generally, embedded '\0' are disallowed.  '\0' is treated
//     as a delimiter, however, so if you escape it you can
//     actually read a std::string with an embedded '\0' (though
//     you probably don't want to)
//   - at the moment, this is all byte oriented, so it probably
//     won't handle any non-ascii delimiters
//
inline std::string parse_string(src_location caller = CALLER()) {
    const size_t start_position = current_position();
    const utf8_byte end_byte = string_end_delimiter(read_byte());
    if(!end_byte) {
        // if end_byte is '\0' it means we're not starting on
        // a valid delimiter
        go_to(start_position); // (rewind)
        return "";
    }
    const char *start = inpp_as_char();

    // read_byte() returns 0 at (or past) end of input,
    // and returning a std::string with an embedded '\0'
    // is just going to cause mayhem, so we count any 0
    // as end of input.
    while(utf8_byte in = read_byte()) {
        if(in == end_byte) {
            break;
        }

        if(in == '\\') {
            read_byte(); // next byte is escaped - just skip
        }
    }

    const char *end = inpp_as_char();
    if(end > start) {
        // normal case, we read the string + the terminating
        // delimiter.  (end - start) is the number we read,
        // and - 1 excludes the terminator.
        return std::string(start, end - start - 1);
    }

    // end <= start is a degenerate case such as you might
    // get trying to parse a string at the last byte of the
    // file or such. returning empty string is the best we
    // can do.
    return "";
}

inline std::string read_string(size_t length) {
    auto result = std::string(inpp_as_char(), length);
    skip_bytes(length);
    return result;
}

// reads until we pass the next newline.
// returns all chars up to (but not including)
// that newline.
inline std::string read_line() {
    size_t nll;

    const utf8_byte *start = inpp();
    const utf8_byte *end   = inpp();
    while(!(nll = newline_length(read_pos))) {
        eat_char();
    }
    end = inpp();
    skip_bytes(nll);

    return std::string((char *)start, end - start);
}

// attempts to read characters exactly matching the string passed.
// returns true if it did, false otherwise.
inline bool read_exact_match(const std::string &match) {
    const utf8_byte *result = NULL;

    size_t ml = match.length();
    if(bytes_left() >= ml) {
        if(const char *in = inpp_as_char()) {
            if(!match.compare(0, ml, in, ml)) {
                result = inpp();
                read_pos += ml;
            }
        } // else we're at eof
    } // else fewer bytes left than length sought -> no match

    return result;
}

// Returns a (possibly empty) string with all characters -until-
// (but not including) the string passed (or end of input).
inline std::string read_to_exact_match(const std::string &str) {
    size_t result_len = 0;
    size_t match_len = 0;

    while(utf8_byte nb = peek(result_len + match_len)) {
        if(match_len >= str.length()) {
            break;
        } else if(nb == (utf8_byte)str[match_len]) {
            match_len++;
        } else {
            result_len += match_len + 1;
            match_len = 0;
        }
    }

    // If there was a partial match, we need to add it to the result
    // length.  For example, if the input is "edit"<eof> and pattern
    // is (eg) "item", "ed" will be the first part of the result, then
    // the "it" will match, after which it'll hit eof and no more input.
    // So if the match length is < pattern length, we need to add it
    // in.
    if(match_len < str.length())
    result_len += match_len;

    return read_string(result_len);
}

inline std::cmatch read_re(
const std::string &re, src_location caller = CALLER()
) {
    // this doesn't support utf-8 in any reasonable way.
    // btw:
    //  https://stackoverflow.com/questions/37989081/how-to-use-unicode-range-in-c-regex

    std::cmatch matched;
    // match_continuous is so that it will start the
    // match at exactly at the inpp (and ideally won't
    // try to keep matching the rest of the input)
    // https://en.cppreference.com/w/cpp/regex/match_flag_type
    auto opts = std::regex_constants::match_continuous;
    if(const char *in = inpp_as_char()) {

        // OK SO
        // https://en.cppreference.com/w/cpp/regex/syntax_option_type
        //   icase, multiline, nosubs
        // in theory, we can and should make these be options.
        // a reasonable way to do that might be to have callers
        // pass in a constructed re already (might want that so
        // that we're not constantly recompiling regexes anyway).
        // but, in the context of fully buffered files, I'm not
        // sure when you would _not_ want multiline - regexes here
        // already match past newlines, and $ is just going to match
        // the end of the buffer (which in theory could be anywhere,
        // and in practice is end of file - not useful).
        // SO I'm just going to turn on multiline always.
        // cmc - turning it back off again because gnu doesn't
        // support it (thus, I guess it's non-portable).
        // keeping it out of both versions because we wouldn't
        // want regexes to work differently on different platforms.
        // const std::regex cre(re, std::regex::multiline);
        try {
            const std::regex cre(re);
            if(std::regex_search(in, matched, cre, opts))
            read_pos += matched.length();
        }
        catch(const std::regex_error& err) {
            // doing the error detection here essentially turns
            // a non-compiling regex error into an internal error.
            // so I think we really want callers to compile the
            // regex.  but, that complicates life for the callers,
            // so doing it this way for the moment.
            on_error(stringformat(
            "/{}/ <- {} (caller: {})", re, err.what(), caller
            ));
            matched = no_match();
        }
    } else {
        // (we are at eof - no match)
        matched = no_match();
    }
    return matched;
}

// Reads everything -up to- the regular expression passed
// (or to end of input, if there's no match)
inline std::string read_to_re(
const std::string &re, src_location caller = CALLER()
) {
    size_t length = bytes_left();
    if(const char *in = inpp_as_char()) {
        std::cmatch matched;
        // as above, should really compile the regex first.
        try {
            const std::regex cre(re);
            if(std::regex_search(in, matched, cre)) {
                length = matched.position();
            }
        }
        catch(const std::regex_error& err) {
            on_error(stringformat(
            "/{}/ <- {} (caller: {})", re, err.what(), caller
            ));
        }
    }
    return read_string(length);
}

// "eat" equivalents of the "read" method above simply
// consume the matching input (without returning it).
// Instead, they return the number of bytes consumed (i.e.
// how far the read pointer went forward)
size_t eat_exact_match(const std::string &match) {
    if(read_exact_match(match))
    return match.length();
    return 0;
}

// eats input not matching the string passed (i.e.,
// consumes input up to the match or to end of input)
size_t eat_not_exact_match(const std::string &match) {
    // might be more efficient to do read_to_exact_match in
    // term of this (instead of the other way around).  ohwell.
    return read_to_exact_match(match).length();
}

size_t eat_re(const std::string &match) {
    return read_re(match).length();
}

// as with eat_not_exact_match, consumes input not
// matching the regular expression string passed
size_t eat_not_re(const std::string &match) {
    return read_to_re(match).length();
}

// pos is the position in the input at which to look; size_t(-1)
// means use the current read position (the default).
// num_chars is the maximum number of utf8 chars to
// look at.
// since we translate things like newlines (to "\n")
// and eof, the output length might be more characters
// than the num_chars passed.
// if pf_esc is set, we attempt to make the string safe
// to pass to printf() family functions.
inline std::string debug_peek(size_t pos, int num_chars = 12) const {
    if(!buffer.data()) return "<NO INPUT>";

    if(pos == size_t(-1)) pos = read_pos;

    if(num_chars < 0) {
        return "¡Negative peek length¡";
    }

    std::string out;
    for(int chp = 0; chp < num_chars; ++chp) {
        if(pos >= buffer.length()) {
            out += "<EOF>";
            break;
        } else if(buffer[pos] == '\0') {
            pos++;
            out += "\\0";
        } else if(int nl = newline_length(pos)) {
            pos += nl;
            out += "\\n";
        } else {
            out += buffer[pos++];
        }
    }
    return out;
}

// errrf params here are different from peek()
inline std::string debug_peek(int num_chars = 12) const {
    return debug_peek(size_t(-1), num_chars);
}
};

class SourcePosition {
fpl_reader_p_c source;
size_t         offset; // byte offset into the file

public:

SourcePosition() : source(nullptr), offset(0) { }

SourcePosition(fpl_reader_p src, size_t pos)
: source(src), offset(pos) {
}

SourcePosition(fpl_reader_p src)
: source(src), offset(src->current_position()) {
}

operator bool() const {
    return source != nullptr;
}

// errf.. wat?  this keeps it from magically converting to some
// total nonsense size_t, (probably via bool?) if, for example,
// we pass one of these to reader->go_to()
operator size_t() const {
    return offset;
}

bool operator==(const SourcePosition &other) const {
    return (offset == other.offset)
    && (source == other.source);
}

bool operator!=(const SourcePosition &other) const {
    return !(*this == other);
}

const fpl_reader &reader()   const { return *source; }
size_t            position() const { return offset; }

std::string debug_peek(
SourcePosition to_pos = SourcePosition(),
int max_length = -1
) const {
    int length = 12;

    if(!source) {
        return "¡debug_peek: no source reader¡";
    }

    if(to_pos) {
        if(source == to_pos.source) {
            length = to_pos.offset - offset;
        } else {
            return "¡debug_peek source file mismatch: "
            + source->filename() + " vs "
            + to_pos.source->filename() + "¡";
        }
    }

    if(max_length >= 0 && length > max_length) {
        length = max_length;
    }

    return source->debug_peek(offset, length);
}

int line_number(int *pos = nullptr) const {
    if(source)
    return source->line_number(offset, pos);
    return 0;
}

inline std::string filename() const {
    if(source)
    return source->filename();
    return "<no source file>";
}

inline std::string to_str() const {
    if(source)
    return source->location_str(offset);

    return "<no source>";
}
};


#endif // FPL_READER_H



#line 56 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 58 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 59 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1 "src/jemplpl/jemplpl.fpl"

/*

 jemplpl - .jemp to c++ converter.

 Given one or more template files, creates corresponding c++ functions
 white return strings containing filled-in copies of said templates,
 and writes them to stdout.

 */

#include <filesystem>
#include <iostream>
#include <list>
#include <set>
#include <string>

#include "fpl2cc/fpl_reader.h"
#include "util/c_str_escape.h"
#include "util/jerror.h"
#include "util/join.h"
#include "util/reformat_code.h"
#include "util/searchpath.h"
#include "util/stringformat.h"
#include "util/utf8_buffer.h"

#define VERSION_MAJ 0
#define VERSION_MIN 9


#line 2121 "src/jemplpl/jemplpl.cc"


#line 61 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 62 "src/fpl2cc/fpl_x_parser.h.jemp" 



#line 64 "src/fpl2cc/fpl_x_parser.h.jemp" 


class jemplpl_parser {

public:

#line 73 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 74 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 78 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 81 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// complete (0:1):        •fragment+:fragments                                                                                     => state 39 (src/grammarlib/jemp.fpl:12)
// fragment (1:1):        •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
// text (2:1):            •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
// fragment (3:4):        •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 56 (src/grammarlib/jemp.fpl:24)
// fragment (4:4):        •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 42 (src/grammarlib/jemp.fpl:35)
// fragment (5:5):        •'@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^                                                 => state 46 (src/grammarlib/jemp.fpl:40)
// fragment (6:5):        •'@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^                                                     => state 51 (src/grammarlib/jemp.fpl:46)
// fragment (7:7):        •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:52)
// fragment (7:6):        leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 33 (src/grammarlib/jemp.fpl:52)
// fragment (8:4):        •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 61 (src/grammarlib/jemp.fpl:65)
// subst_start (10:2):    •leading_ws?^ '@-':arg_1                                                                                 => state 31 (src/grammarlib/jemp.fpl:72)
// subst_start (10:1):    leading_ws?^ •'@-':arg_1                                                                                 => state 32 (src/grammarlib/jemp.fpl:72)
// subst_start (11:1):    •'@':arg_0                                                                                               => state 60 (src/grammarlib/jemp.fpl:73)
// leading_ws (15:1):     •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:83)
// trailing_ws (16:1):    •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:97)
// trailing_ws (17:1):    •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:101)
// fragment (18:6):       •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:109)
// fragment (19:5):       •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:112)
// control_start (20:3):  •subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^                                      => state 9  (src/grammarlib/jemp.fpl:124)
// control_end (21:3):    •subst_start^ '}':control_statement subst_end^                                                           => state 9  (src/grammarlib/jemp.fpl:125)
// fragment (22:1):       •control_start:control_statement                                                                         => state 40 (src/grammarlib/jemp.fpl:127)
// fragment (23:1):       •control_end:control_statement                                                                           => state 41 (src/grammarlib/jemp.fpl:128)
// fragment (24:3):       •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:133)
// text (25:1):           •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:137)
// text (26:1):           •leading_ws                                                                                              => state 31 (src/grammarlib/jemp.fpl:141)
// text (27:1):           •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:142)
// _fpl_goal (29:1):      •complete                                                                                                => state 65 (src/fpl2cc/productions.h:4227)
//
void state_0() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__fragment(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_39);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__text(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_2);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_31);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_start(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_9);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__control_start(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_40);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__control_end(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_41);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_start(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_9);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_31);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_1);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__complete(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_65);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_4(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_4);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_5(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_56);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_9(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_42);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_12(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_46);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_14(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_51);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_16(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_33);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_20(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_61);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_24(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_32);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_60);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_31(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_5);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_32(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_7);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_33(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_8);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_39(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_6);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// text (27:0):  trailing_ws • => (reduce) (src/grammarlib/jemp.fpl:142)
//
void state_1() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__trailing_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__trailing_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // trailing_ws has base step num 0; canonical step is <27.0 = trailing_ws>
        ReductionParameter<std::string> arg_trailing_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_27 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_trailing_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _text);
        lr_push(_text, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (1:1):      •text+:chunks                   => state 2  (src/grammarlib/jemp.fpl:15)
// fragment (1:0):      text+:chunks •                  => (reduce) (src/grammarlib/jemp.fpl:15)
// text (2:1):          •'@@':at_sign                   => state 4  (src/grammarlib/jemp.fpl:20)
// leading_ws (15:1):   •/\\n*[ \\t]+/:ws               => state 5  (src/grammarlib/jemp.fpl:83)
// trailing_ws (16:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:97)
// trailing_ws (17:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:101)
// text (25:1):         •/[^@\\n]+/:t                   => state 6  (src/grammarlib/jemp.fpl:137)
// text (26:1):         •leading_ws                     => state 3  (src/grammarlib/jemp.fpl:141)
// text (27:1):         •trailing_ws                    => state 1  (src/grammarlib/jemp.fpl:142)
//
void state_2() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__text(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_2);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_3);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_1);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_4(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_4);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_31(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_5);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_32(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_7);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_33(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_8);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_39(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_6);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__text(
        lr_read_pos, true
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__text(
        argument_start, true
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // chunks has base step num 0; canonical step is <1.0 = text+:chunks>
        ReductionParameter<std::string> arg_chunks(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        1
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_1 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_chunks
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// text (26:0):  leading_ws • => (reduce) (src/grammarlib/jemp.fpl:141)
//
void state_3() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__leading_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__leading_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // leading_ws has base step num 0; canonical step is <26.0 = leading_ws>
        ReductionParameter<std::string> arg_leading_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_26 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_leading_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _text);
        lr_push(_text, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// text (2:0):  '@@':at_sign • => (reduce) (src/grammarlib/jemp.fpl:20)
//
void state_4() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_4(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_4(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // at_sign has base step num 0; canonical step is <2.0 = '@@':at_sign>
        ReductionParameter<Terminal> arg_at_sign(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_2 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_at_sign
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _text);
        lr_push(_text, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// leading_ws (15:0):  /\\n*[ \\t]+/:ws • => (reduce) (src/grammarlib/jemp.fpl:83)
//
void state_5() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_31(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_31(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // ws has base step num 0; canonical step is <15.0 = /\\n*[ \\t]+/:ws>
        ReductionParameter<Terminal> arg_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_15 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _leading_ws);
        lr_push(_leading_ws, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// text (25:0):  /[^@\\n]+/:t • => (reduce) (src/grammarlib/jemp.fpl:137)
//
void state_6() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_39(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_39(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // t has base step num 0; canonical step is <25.0 = /[^@\\n]+/:t>
        ReductionParameter<Terminal> arg_t(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_25 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_t
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _text);
        lr_push(_text, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// trailing_ws (16:0):  /[ \\t]*\\n+[ \\t]+(\?!@)/:ws • => (reduce) (src/grammarlib/jemp.fpl:97)
//
void state_7() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_32(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_32(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // ws has base step num 0; canonical step is <16.0 = /[ \\t]*\\n+[ \\t]+(\?!@)/:ws>
        ReductionParameter<Terminal> arg_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_16 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _trailing_ws);
        lr_push(_trailing_ws, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// trailing_ws (17:0):  /[ \\t]*\\n/:ws • => (reduce) (src/grammarlib/jemp.fpl:101)
//
void state_8() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_33(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_33(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // ws has base step num 0; canonical step is <17.0 = /[ \\t]*\\n/:ws>
        ReductionParameter<Terminal> arg_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_17 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _trailing_ws);
        lr_push(_trailing_ws, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (18:5):       subst_start^ •/#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 19 (src/grammarlib/jemp.fpl:109)
// fragment (19:4):       subst_start^ •/#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 19 (src/grammarlib/jemp.fpl:112)
// control_start (20:2):  subst_start^ •/(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^                                      => state 15 (src/grammarlib/jemp.fpl:124)
// control_end (21:2):    subst_start^ •'}':control_statement subst_end^                                                           => state 10 (src/grammarlib/jemp.fpl:125)
// fragment (24:2):       subst_start^ •/(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 17 (src/grammarlib/jemp.fpl:133)
//
void state_9() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_34(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_19);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_35(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_15);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_37(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_10);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_29(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_17);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:2):    •'-@':arg_0 trailing_ws?^                       => state 13 (src/grammarlib/jemp.fpl:75)
// subst_end (13:1):    •'@':arg_0                                      => state 12 (src/grammarlib/jemp.fpl:76)
// control_end (21:1):  subst_start^ '}':control_statement •subst_end^  => state 11 (src/grammarlib/jemp.fpl:125)
//
void state_10() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_end(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_11);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_26(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_13);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_12);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// control_end (21:0):  subst_start^ '}':control_statement subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:125)
//
void state_11() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_37(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_37(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_3_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // control_statement has base step num 1; canonical step is <21.1 = '}':control_statement>
        ReductionParameter<Terminal> arg_control_statement(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_21 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_control_statement
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _control_end);
        lr_push(_control_end, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (13:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:76)
//
void state_12() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_0 has base step num 0; canonical step is <13.0 = '@':arg_0>
        ReductionParameter<Terminal> arg_arg_0(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_13 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_0
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _subst_end);
        lr_push(_subst_end, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:1):    '-@':arg_0 •trailing_ws?^       => state 14 (src/grammarlib/jemp.fpl:75)
// subst_end (12:0):    '-@':arg_0 trailing_ws?^ •      => (reduce) (src/grammarlib/jemp.fpl:75)
// trailing_ws (16:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws  => state 7  (src/grammarlib/jemp.fpl:97)
// trailing_ws (17:1):  •/[ \\t]*\\n/:ws                => state 8  (src/grammarlib/jemp.fpl:101)
//
void state_13() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__trailing_ws(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_14);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_32(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_7);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_33(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_8);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__trailing_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_26(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_26(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__trailing_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_2_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_0 has base step num 0; canonical step is <12.0 = '-@':arg_0>
        ReductionParameter<Terminal> arg_arg_0(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_12 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_0
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _subst_end);
        lr_push(_subst_end, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:0):  '-@':arg_0 trailing_ws?^ • => (reduce) (src/grammarlib/jemp.fpl:75)
//
void state_14() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__trailing_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_26(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_26(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__trailing_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_2_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_0 has base step num 0; canonical step is <12.0 = '-@':arg_0>
        ReductionParameter<Terminal> arg_arg_0(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_12 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_0
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _subst_end);
        lr_push(_subst_end, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:2):      •'-@':arg_0 trailing_ws?^                                            => state 13 (src/grammarlib/jemp.fpl:75)
// subst_end (13:1):      •'@':arg_0                                                           => state 12 (src/grammarlib/jemp.fpl:76)
// control_start (20:1):  subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement •subst_end^  => state 16 (src/grammarlib/jemp.fpl:124)
//
void state_15() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_end(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_16);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_26(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_13);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_12);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// control_start (20:0):  subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:124)
//
void state_16() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_35(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_35(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_3_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // control_statement has base step num 1; canonical step is <20.1 = /(\?:[^-{@]|-[^@]|)*\\{/:control_statement>
        ReductionParameter<Terminal> arg_control_statement(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_20 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_control_statement
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _control_start);
        lr_push(_control_start, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:2):  •'-@':arg_0 trailing_ws?^                              => state 13 (src/grammarlib/jemp.fpl:75)
// subst_end (13:1):  •'@':arg_0                                             => state 12 (src/grammarlib/jemp.fpl:76)
// fragment (24:1):   subst_start^ /(\?:[^-@]|-[^@])+/:variable •subst_end^  => state 18 (src/grammarlib/jemp.fpl:133)
//
void state_17() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_end(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_18);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_26(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_13);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_12);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (24:0):  subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:133)
//
void state_18() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_29(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_29(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_3_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // variable has base step num 1; canonical step is <24.1 = /(\?:[^-@]|-[^@])+/:variable>
        ReductionParameter<Terminal> arg_variable(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_24 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_variable
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (18:4):    subst_start^ /#\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 20 (src/grammarlib/jemp.fpl:109)
// fragment (19:3):    subst_start^ /#\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 20 (src/grammarlib/jemp.fpl:112)
// identifier (28:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                           => state 30 (src/grammarlib/jemp.fpl:145)
//
void state_19() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__identifier(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_20);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_40(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_30);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// template_variant (9:3):  •'#'^ !'#':variant_expression '#'^                                                                       => state 27 (src/grammarlib/jemp.fpl:70)
// rest_of_sub (14:1):      •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 24 (src/grammarlib/jemp.fpl:77)
// fragment (18:3):         subst_start^ /#\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^  => state 21 (src/grammarlib/jemp.fpl:109)
// fragment (19:2):         subst_start^ /#\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^                           => state 25 (src/grammarlib/jemp.fpl:112)
//
void state_20() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__template_variant(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_21);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_25);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_21(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_27);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_29(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_24);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// rest_of_sub (14:1):  •/(\?:[^-@]|-[^@])+/:arg_0                                                                               => state 24 (src/grammarlib/jemp.fpl:77)
// fragment (18:2):     subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^  => state 22 (src/grammarlib/jemp.fpl:109)
//
void state_21() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__rest_of_sub(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_22);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_29(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_24);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:2):  •'-@':arg_0 trailing_ws?^                                                                                => state 13 (src/grammarlib/jemp.fpl:75)
// subst_end (13:1):  •'@':arg_0                                                                                               => state 12 (src/grammarlib/jemp.fpl:76)
// fragment (18:1):   subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^  => state 23 (src/grammarlib/jemp.fpl:109)
//
void state_22() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_end(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_23);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_26(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_13);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_12);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (18:0):  subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:109)
//
void state_23() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__rest_of_sub(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__template_variant(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__identifier(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_34(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_34(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__identifier(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__template_variant(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__rest_of_sub(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_4_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_5_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_6_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // jempl_args has base step num 4; canonical step is <18.4 = rest_of_sub:jempl_args>
        ReductionParameter<std::string> arg_jempl_args(
        *this, step_4_start + 0,
        step_5_start - step_4_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // jempl_name has base step num 2; canonical step is <18.2 = identifier:jempl_name>
        ReductionParameter<std::string> arg_jempl_name(
        *this, step_2_start + 0,
        step_3_start - step_2_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // variant has base step num 3; canonical step is <18.3 = template_variant:variant>
        ReductionParameter<std::string> arg_variant(
        *this, step_3_start + 0,
        step_4_start - step_3_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_18 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_jempl_args
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        , arg_jempl_name
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        , arg_variant
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// rest_of_sub (14:0):  /(\?:[^-@]|-[^@])+/:arg_0 • => (reduce) (src/grammarlib/jemp.fpl:77)
//
void state_24() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_29(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_29(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_0 has base step num 0; canonical step is <14.0 = /(\?:[^-@]|-[^@])+/:arg_0>
        ReductionParameter<Terminal> arg_arg_0(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_14 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_0
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _rest_of_sub);
        lr_push(_rest_of_sub, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_end (12:2):  •'-@':arg_0 trailing_ws?^                                                       => state 13 (src/grammarlib/jemp.fpl:75)
// subst_end (13:1):  •'@':arg_0                                                                      => state 12 (src/grammarlib/jemp.fpl:76)
// fragment (19:1):   subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^  => state 26 (src/grammarlib/jemp.fpl:112)
//
void state_25() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_end(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_26);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_26(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_13);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_12);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (19:0):  subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ • => (reduce) (src/grammarlib/jemp.fpl:112)
//
void state_26() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__rest_of_sub(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__identifier(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_34(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__subst_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_34(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__identifier(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__rest_of_sub(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__subst_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_4_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_5_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // jempl_args has base step num 3; canonical step is <19.3 = rest_of_sub:jempl_args>
        ReductionParameter<std::string> arg_jempl_args(
        *this, step_3_start + 0,
        step_4_start - step_3_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // jempl_name has base step num 2; canonical step is <19.2 = identifier:jempl_name>
        ReductionParameter<std::string> arg_jempl_name(
        *this, step_2_start + 0,
        step_3_start - step_2_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_19 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_jempl_args
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        , arg_jempl_name
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// template_variant (9:2):  '#'^ •!'#':variant_expression '#'^  => state 28 (src/grammarlib/jemp.fpl:70)
//
void state_27() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT_INV__terminal_22(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_28);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// template_variant (9:1):  '#'^ !'#':variant_expression •'#'^  => state 29 (src/grammarlib/jemp.fpl:70)
//
void state_28() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_21(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_29);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// template_variant (9:0):  '#'^ !'#':variant_expression '#'^ • => (reduce) (src/grammarlib/jemp.fpl:70)
//
void state_29() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_21(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_22(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_21(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_21(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_22(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_21(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_3_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // variant_expression has base step num 1; canonical step is <9.1 = !'#':variant_expression>
        ReductionParameter<Terminal> arg_variant_expression(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_9 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_variant_expression
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _template_variant);
        lr_push(_template_variant, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// identifier (28:0):  /[a-zA-Z_][a-zA-Z_0-9]+/:name • => (reduce) (src/grammarlib/jemp.fpl:145)
//
void state_30() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_40(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_40(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // name has base step num 0; canonical step is <28.0 = /[a-zA-Z_][a-zA-Z_0-9]+/:name>
        ReductionParameter<Terminal> arg_name(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_28 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_name
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _identifier);
        lr_push(_identifier, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:6):      leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 33 (src/grammarlib/jemp.fpl:52)
// subst_start (10:1):  leading_ws?^ •'@-':arg_1                                                                         => state 32 (src/grammarlib/jemp.fpl:72)
// text (26:0):         leading_ws •                                                                                     => (reduce) (src/grammarlib/jemp.fpl:141)
//
void state_31() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_16(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_33);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_24(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_32);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__leading_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__leading_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // leading_ws has base step num 0; canonical step is <26.0 = leading_ws>
        ReductionParameter<std::string> arg_leading_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_26 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_leading_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _text);
        lr_push(_text, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_start (10:0):  leading_ws?^ '@-':arg_1 • => (reduce) (src/grammarlib/jemp.fpl:72)
//
void state_32() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_24(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__leading_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__leading_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_24(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_2_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_1 has base step num 1; canonical step is <10.1 = '@-':arg_1>
        ReductionParameter<Terminal> arg_arg_1(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_10 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_1
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _subst_start);
        lr_push(_subst_start, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:5):     leading_ws? /@declare\\s+/^ •identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 34 (src/grammarlib/jemp.fpl:52)
// identifier (28:1):  •/[a-zA-Z_][a-zA-Z_0-9]+/:name                                                                   => state 30 (src/grammarlib/jemp.fpl:145)
//
void state_33() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__identifier(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_34);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_40(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_30);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:4):  leading_ws? /@declare\\s+/^ identifier:name_decl •':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 35 (src/grammarlib/jemp.fpl:52)
//
void state_34() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_18(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_35);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:3):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ •/(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^  => state 36 (src/grammarlib/jemp.fpl:52)
//
void state_35() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_19(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_36);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:2):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value •'@'^ /\\n\?/^  => state 37 (src/grammarlib/jemp.fpl:52)
//
void state_36() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_37);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:1):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ •/\\n\?/^  => state 38 (src/grammarlib/jemp.fpl:52)
//
void state_37() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_38);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (7:0):  leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:52)
//
void state_38() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_19(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_18(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__identifier(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_16(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__leading_ws(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__leading_ws(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_16(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__identifier(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_18(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_19(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_4_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_5_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_6_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_7_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // leading_ws has base step num 0; canonical step is <7.0 = leading_ws?>
        ReductionParameter<std::string> arg_leading_ws(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // name_decl has base step num 2; canonical step is <7.2 = identifier:name_decl>
        ReductionParameter<std::string> arg_name_decl(
        *this, step_2_start + 0,
        step_3_start - step_2_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // value has base step num 4; canonical step is <7.4 = /(\?:[^@]|(\?:@@))*/:value>
        ReductionParameter<Terminal> arg_value(
        *this, step_4_start + 0,
        step_5_start - step_4_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_7 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_leading_ws
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        , arg_name_decl
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        , arg_value
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// complete (0:1):        •fragment+:fragments                                                                                     => state 39 (src/grammarlib/jemp.fpl:12)
// complete (0:0):        fragment+:fragments •                                                                                    => (reduce) (src/grammarlib/jemp.fpl:12)
// fragment (1:1):        •text+:chunks                                                                                            => state 2  (src/grammarlib/jemp.fpl:15)
// text (2:1):            •'@@':at_sign                                                                                            => state 4  (src/grammarlib/jemp.fpl:20)
// fragment (3:4):        •'@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^                              => state 56 (src/grammarlib/jemp.fpl:24)
// fragment (4:4):        •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^                                                         => state 42 (src/grammarlib/jemp.fpl:35)
// fragment (5:5):        •'@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^                                                 => state 46 (src/grammarlib/jemp.fpl:40)
// fragment (6:5):        •'@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^                                                     => state 51 (src/grammarlib/jemp.fpl:46)
// fragment (7:7):        •leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 31 (src/grammarlib/jemp.fpl:52)
// fragment (7:6):        leading_ws? •/@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^          => state 33 (src/grammarlib/jemp.fpl:52)
// fragment (8:4):        •/@realign:\\s*/^ text:realign '@'^ /\\n\?/^                                                             => state 61 (src/grammarlib/jemp.fpl:65)
// subst_start (10:2):    •leading_ws?^ '@-':arg_1                                                                                 => state 31 (src/grammarlib/jemp.fpl:72)
// subst_start (10:1):    leading_ws?^ •'@-':arg_1                                                                                 => state 32 (src/grammarlib/jemp.fpl:72)
// subst_start (11:1):    •'@':arg_0                                                                                               => state 60 (src/grammarlib/jemp.fpl:73)
// leading_ws (15:1):     •/\\n*[ \\t]+/:ws                                                                                        => state 5  (src/grammarlib/jemp.fpl:83)
// trailing_ws (16:1):    •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                                                                           => state 7  (src/grammarlib/jemp.fpl:97)
// trailing_ws (17:1):    •/[ \\t]*\\n/:ws                                                                                         => state 8  (src/grammarlib/jemp.fpl:101)
// fragment (18:6):       •subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^  => state 9  (src/grammarlib/jemp.fpl:109)
// fragment (19:5):       •subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^                           => state 9  (src/grammarlib/jemp.fpl:112)
// control_start (20:3):  •subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^                                      => state 9  (src/grammarlib/jemp.fpl:124)
// control_end (21:3):    •subst_start^ '}':control_statement subst_end^                                                           => state 9  (src/grammarlib/jemp.fpl:125)
// fragment (22:1):       •control_start:control_statement                                                                         => state 40 (src/grammarlib/jemp.fpl:127)
// fragment (23:1):       •control_end:control_statement                                                                           => state 41 (src/grammarlib/jemp.fpl:128)
// fragment (24:3):       •subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^                                                    => state 9  (src/grammarlib/jemp.fpl:133)
// text (25:1):           •/[^@\\n]+/:t                                                                                            => state 6  (src/grammarlib/jemp.fpl:137)
// text (26:1):           •leading_ws                                                                                              => state 31 (src/grammarlib/jemp.fpl:141)
// text (27:1):           •trailing_ws                                                                                             => state 1  (src/grammarlib/jemp.fpl:142)
//
void state_39() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__fragment(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_39);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__text(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_2);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_31);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_start(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_9);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__control_start(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_40);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__control_end(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_41);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__subst_start(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_9);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_31);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_1);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_4(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_4);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_5(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_56);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_9(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_42);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_12(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_46);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_14(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_51);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_16(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_33);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_20(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_61);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_24(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_32);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_60);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_31(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_5);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_32(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_7);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_33(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_8);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_39(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_6);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__fragment(
        lr_read_pos, true
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__fragment(
        argument_start, true
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // fragments has base step num 0; canonical step is <0.0 = fragment+:fragments>
        ReductionParameter<std::string> arg_fragments(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        1
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_0 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_fragments
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _complete);
        lr_push(_complete, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (22:0):  control_start:control_statement • => (reduce) (src/grammarlib/jemp.fpl:127)
//
void state_40() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__control_start(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__control_start(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // control_statement has base step num 0; canonical step is <22.0 = control_start:control_statement>
        ReductionParameter<std::string> arg_control_statement(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_22 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_control_statement
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (23:0):  control_end:control_statement • => (reduce) (src/grammarlib/jemp.fpl:128)
//
void state_41() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__control_end(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__control_end(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // control_statement has base step num 0; canonical step is <23.0 = control_end:control_statement>
        ReductionParameter<std::string> arg_control_statement(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_23 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_control_statement
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (4:3):  '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\n\?/^  => state 43 (src/grammarlib/jemp.fpl:35)
//
void state_42() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_10(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_43);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (4:2):  '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\n\?/^  => state 44 (src/grammarlib/jemp.fpl:35)
//
void state_43() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_44);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (4:1):  '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\n\?/^  => state 45 (src/grammarlib/jemp.fpl:35)
//
void state_44() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_45);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (4:0):  '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:35)
//
void state_45() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_10(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_9(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_9(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_10(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_4_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // param_decl has base step num 1; canonical step is <4.1 = /[^@]+/:param_decl>
        ReductionParameter<Terminal> arg_param_decl(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_4 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_param_decl
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (5:4):  '@include:'^ •/\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^  => state 47 (src/grammarlib/jemp.fpl:40)
//
void state_46() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_13(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_47);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (5:3):  '@include:'^ /\\s*/^ •/[^@]+/:include_file '@'^ /\\n\?/^  => state 48 (src/grammarlib/jemp.fpl:40)
//
void state_47() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_10(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_48);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (5:2):  '@include:'^ /\\s*/^ /[^@]+/:include_file •'@'^ /\\n\?/^  => state 49 (src/grammarlib/jemp.fpl:40)
//
void state_48() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_49);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (5:1):  '@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ •/\\n\?/^  => state 50 (src/grammarlib/jemp.fpl:40)
//
void state_49() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_50);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (5:0):  '@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:40)
//
void state_50() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_10(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_13(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_12(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_12(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_13(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_10(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_4_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_5_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // include_file has base step num 2; canonical step is <5.2 = /[^@]+/:include_file>
        ReductionParameter<Terminal> arg_include_file(
        *this, step_2_start + 0,
        step_3_start - step_2_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_5 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_include_file
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (6:4):  '@embed:'^ •/\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^  => state 52 (src/grammarlib/jemp.fpl:46)
//
void state_51() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_13(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_52);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (6:3):  '@embed:'^ /\\s*/^ •/[^@]+/:embed_file '@'^ /\\n\?/^  => state 53 (src/grammarlib/jemp.fpl:46)
//
void state_52() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_10(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_53);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (6:2):  '@embed:'^ /\\s*/^ /[^@]+/:embed_file •'@'^ /\\n\?/^  => state 54 (src/grammarlib/jemp.fpl:46)
//
void state_53() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_54);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (6:1):  '@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ •/\\n\?/^  => state 55 (src/grammarlib/jemp.fpl:46)
//
void state_54() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_55);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (6:0):  '@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:46)
//
void state_55() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_10(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_13(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_14(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_14(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_13(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_10(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_4_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_5_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // embed_file has base step num 2; canonical step is <6.2 = /[^@]+/:embed_file>
        ReductionParameter<Terminal> arg_embed_file(
        *this, step_2_start + 0,
        step_3_start - step_2_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_6 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_embed_file
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (3:3):  '@/*'^ •/(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^  => state 57 (src/grammarlib/jemp.fpl:24)
//
void state_56() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_6(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_57);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (3:2):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment •'*/@'^ /\\n\?/^  => state 58 (src/grammarlib/jemp.fpl:24)
//
void state_57() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_7(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_58);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (3:1):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ •/\\n\?/^  => state 59 (src/grammarlib/jemp.fpl:24)
//
void state_58() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_59);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (3:0):  '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:24)
//
void state_59() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_7(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_6(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_5(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_5(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_6(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_7(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_4_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // comment has base step num 1; canonical step is <3.1 = /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment>
        ReductionParameter<Terminal> arg_comment(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_3 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_comment
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// subst_start (11:0):  '@':arg_0 • => (reduce) (src/grammarlib/jemp.fpl:73)
//
void state_60() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_1_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // arg_0 has base step num 0; canonical step is <11.0 = '@':arg_0>
        ReductionParameter<Terminal> arg_arg_0(
        *this, step_0_start + 0,
        step_1_start - step_0_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_11 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_arg_0
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _subst_start);
        lr_push(_subst_start, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// text (2:1):          •'@@':at_sign                                 => state 4  (src/grammarlib/jemp.fpl:20)
// fragment (8:3):      /@realign:\\s*/^ •text:realign '@'^ /\\n\?/^  => state 62 (src/grammarlib/jemp.fpl:65)
// leading_ws (15:1):   •/\\n*[ \\t]+/:ws                             => state 5  (src/grammarlib/jemp.fpl:83)
// trailing_ws (16:1):  •/[ \\t]*\\n+[ \\t]+(\?!@)/:ws                => state 7  (src/grammarlib/jemp.fpl:97)
// trailing_ws (17:1):  •/[ \\t]*\\n/:ws                              => state 8  (src/grammarlib/jemp.fpl:101)
// text (25:1):         •/[^@\\n]+/:t                                 => state 6  (src/grammarlib/jemp.fpl:137)
// text (26:1):         •leading_ws                                   => state 3  (src/grammarlib/jemp.fpl:141)
// text (27:1):         •trailing_ws                                  => state 1  (src/grammarlib/jemp.fpl:142)
//
void state_61() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__text(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_62);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__leading_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_3);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONTERM_PRODUCTION__trailing_ws(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_1);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_4(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_4);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_31(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_5);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_32(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_7);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_33(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_8);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_39(false)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_6);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (8:2):  /@realign:\\s*/^ text:realign •'@'^ /\\n\?/^  => state 63 (src/grammarlib/jemp.fpl:65)
//
void state_62() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_EXACT__terminal_11(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_63);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (8:1):  /@realign:\\s*/^ text:realign '@'^ •/\\n\?/^  => state 64 (src/grammarlib/jemp.fpl:65)
//
void state_63() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_TERM_REGEX__terminal_8(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        set_state(&jemplpl_parser::state_64);

        #line 38 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// fragment (8:0):  /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ • => (reduce) (src/grammarlib/jemp.fpl:65)
//
void state_64() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 40 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        #line 5 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 7 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // we've matched something, and we're going to generate and
        // push a result, so first we need to clear any mismatches
        // from the top of the stack:
        clear_mismatches();


        #line 15 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 21 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_8(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_11(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__text(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 23 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos = lr_position_before__terminal_20(
        lr_read_pos, false
        );

        #line 33 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 34 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        lr_read_pos++;  // (we went until just before the real frame start)


        #line 37 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        // Now that we know where the frame starts, we can go forward through
        // the stack to find the appropriate slices for our arguments.  We do
        // need to do this back-and-forth thing to get the arguments correct
        // for rules like: 
        //    foo:first foo*:rest -> bar ;
        int argument_start = lr_read_pos;

        // the step size is in lr_stack units, and may be different from the
        // argument size because some (melded) arguments span multiple steps:
        int step_size;


        #line 59 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_20(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_0_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__text(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_1_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_11(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_2_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 61 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        step_size = lr_stack_size_of__terminal_8(
        argument_start, false
        );


        #line 72 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        int step_3_start = argument_start;

        argument_start += step_size;

        #line 86 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 

        #line 87 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // and this just makes it easier to find the end of the last step:
        int step_4_start = argument_start;


        #line 92 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        // realign has base step num 1; canonical step is <8.1 = text:realign>
        ReductionParameter<std::string> arg_realign(
        *this, step_1_start + 0,
        step_2_start - step_1_start,
        0
        );


        #line 102 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 


        #line 109 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 111 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 121 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        std::string result = rule_8 (

        #line 123 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        arg_realign
        #line 125 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        );

        Product prod(result);

        #line 130 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 136 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        auto src_pos = lr_stack_entry(lr_read_pos).position();


        #line 139 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        lr_pop_to(lr_read_pos - 1);


        #line 147 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 
        bool eject = state_ejects(cur_state, _fragment);
        lr_push(_fragment, eject, src_pos, prod);


        #line 154 "src/fpl2cc/fpl_x_parser_reduce_call.h.jemp" 



        #line 45 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

//
// _fpl_goal (29:0):  complete • => (done) (src/fpl2cc/productions.h:4227)
//
void state_65() {

    #line 11 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    eat_separator();


    #line 18 "src/fpl2cc/fpl_x_parser_state.h.jemp" 



    #line 27 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    #line 31 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    if(shift_NONE___fpl_null(true)) {

        #line 35 "src/fpl2cc/fpl_x_parser_state.h.jemp" 


        #line 46 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
        // matched a goal:
        terminate();

        #line 55 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

    } else

    #line 59 "src/fpl2cc/fpl_x_parser_state.h.jemp" 
    {

        #line 61 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

        mismatch();
    }


    #line 67 "src/fpl2cc/fpl_x_parser_state.h.jemp" 

}


#line 83 "src/fpl2cc/fpl_x_parser.h.jemp" 


private:

// If some poor hapless fpl author should happen to try
// to use a non-copy-constructable type in some way that
// it lands in the variant (below), they will be rewarded
// by their c++ compiler with about 23k lines of "note:"
// gibberish about every possible constructor in the
// standard libraries.  To avoid this, and to give a non-0
// chance at a useful error message, we do this lame hack
// of creating a static function whose only reason for
// existence is to give a scope to static_asserts:
static void check_copy() {

    #line 97 "src/fpl2cc/fpl_x_parser.h.jemp" 

    {

        #line 99 "src/fpl2cc/fpl_x_parser.h.jemp" 
        const bool copyable = std::is_copy_constructible<Terminal>::value;
        static_assert(copyable, "Terminal is not copy constructable");
    }

    #line 106 "src/fpl2cc/fpl_x_parser.h.jemp" 

    {

        #line 99 "src/fpl2cc/fpl_x_parser.h.jemp" 
        const bool copyable = std::is_copy_constructible<std::string>::value;
        static_assert(copyable, "std::string is not copy constructable");
    }

    #line 106 "src/fpl2cc/fpl_x_parser.h.jemp" 

}

public:
using State = decltype(&jemplpl_parser::state_0);

class Terminal {
    // the first string in "matches" is the entire terminal match
    // and will exist for exact matches as well as regex matches.
    // subsequent matches are used for capture groups in a regex
    // match.
    std::vector<std::string> matches;
    public:

    Terminal() { } // false valued terminal

    Terminal(const std::string &src) {
        matches.push_back(src);
    }

    // this prevents stuff like Terminal("foo") from matching
    // the Iterable one, below
    Terminal(const char *src) {
        matches.push_back(std::string(src));
    }

    // this is so that bool "just works" in return values from
    // custom scanners
    Terminal(bool matched) {
        if(matched) matches.push_back("");
    }

    template<typename Iter>
    Terminal(Iter begin, Iter end) : matches(begin, end) {
    }

    template<typename Iterable>
    Terminal(const Iterable &src) : matches(src.begin(), src.end()) {
    }

    std::string to_str() const {
        if(matches.size())
        return matches[0];
        return "";
    }

    // returns the length of the terminal match, in bytes
    size_t length() const {
        if(matches.size())
        return matches[0].size();
        return 0;
    }

    // returns a string containing the contents of the regex capture
    // group indicated by the index passed.
    // for example, if the regex /(.)y(.*)/ matched the string "dyad",
    // capgroup(0) would be "d" and capgroup(1) would be "ad".
    // default is the 0th capgroup.
    // returns the empty string for any non-existent capture groups.
    std::string capgroup(int capi = 0) const {
        if(capi + 1 < matches.size()) {
            return matches[capi + 1];
        }
        return "";
    }

    int num_capgroups() const {
        return matches.size() - 1;
    }

    operator bool() const {
        return matches.size() > 0;
    }

    operator std::string() const { return to_str(); }

    std::string operator+(const std::string & rhs) const {
        return to_str() + rhs;
    }

    friend bool operator==(const Terminal &lhs, const char *rhs) {
        return lhs.to_str() == rhs;
    }

    friend bool operator==(const char *lhs, const Terminal &rhs) {
        return lhs == rhs.to_str();
    }

};


#line 2 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"


#line 4 "src/fpl2cc/fpl_x_parser_generated_types.h.jemp"




class Product {
    struct false_product { };

    // this is the "product" we make everything produce for
    // the --check-only option.  It can be constructed from
    // anything, so that it can drop into any arbitrary rule.
    struct check_only {
        operator bool() const { return true; }
        std::string to_str() const {
            return "«dummy»";
        }

        // (construct from any set of arguments)
        template <typename... Args>
        check_only(Args&&... args) { }
    };

    // different fpl rules may or may not evaluate to different
    // types, so we use a std::variant:
    using Var = std::variant<
    false_product,
    Terminal,
    std::string
    >;

    Var red;

    public:
    // creates a false-valued Product:
    Product() : red(false_product()) { }

    // type-specific constructors:

    #line 229 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Product(Terminal result) : red(result) { }

    #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Product(std::string result) : red(result) { }

    #line 231 "src/fpl2cc/fpl_x_parser.h.jemp" 
    const Var &var() const { return red; }

    // Accessors for the different types are named as [element name]_val()
    // We start at type 1 instead of 0 because we don't need/want an
    // fpl_null accessor (it has no type anyway)

    #line 238 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _fragment_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _complete_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _text_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_4_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_5_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_6_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_7_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_8_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_9_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_10_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_11_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_12_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_13_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_14_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _leading_ws_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_16_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _identifier_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_18_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_19_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_20_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_21_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_22_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _template_variant_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_24_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _subst_start_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_26_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _trailing_ws_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _subst_end_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_29_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _rest_of_sub_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_31_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_32_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_33_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_34_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_35_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _control_start_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_37_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    std::string _control_end_val() const { return std::get<std::string>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_39_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_40_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    Terminal _terminal_41_val() const { return std::get<Terminal>(var()); }

    #line 243 "src/fpl2cc/fpl_x_parser.h.jemp" 
    operator bool() const {
        return !std::holds_alternative<false_product>(red);
    }

    std::string type_name() const {
        if(std::holds_alternative<false_product>(red))
        return "<no type>";

        if(std::holds_alternative<Terminal>(red))
        return "Terminal";


        #line 256 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(std::holds_alternative<Terminal>(red))
        return "Terminal";

        #line 259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(std::holds_alternative<std::string>(red))
        return "std::string";

        #line 259 "src/fpl2cc/fpl_x_parser.h.jemp" 
        // can't get here?
        jerror::error("Unknown type for product");
        return "unknown type";
    }

    std::string var_str() const {
        if(std::holds_alternative<false_product>(red))
        return "<null product>";

        if(std::holds_alternative<Terminal>(var()))
        return stringformat("{}", std::get<Terminal>(var()));


        #line 272 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(std::holds_alternative<Terminal>(var())) {

            #line 274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            return stringformat("{}", std::get<Terminal>(var()));
        }

        #line 278 "src/fpl2cc/fpl_x_parser.h.jemp" 
        if(std::holds_alternative<std::string>(var())) {

            #line 274 "src/fpl2cc/fpl_x_parser.h.jemp" 
            return stringformat("{}", std::get<std::string>(var()));
        }

        #line 278 "src/fpl2cc/fpl_x_parser.h.jemp" 


        jerror::error("Unknown type for product");
        return "unknown type";
    }

    // this is for debug and similar:
    std::string to_str() const {
        std::string out;
        return stringformat("{} «{}»", type_name(), var_str());
    }

    // phase out if possible, because this only supports the
    // top output_type() and that's wacky.
    std::string val(const std::string &caller = CALLER()) const {
        if(!std::holds_alternative<std::string>(red)) {
            std::string dummy;
            return dummy;
        }
        return std::get<std::string>(red);
    }

    // if it's a (regex) terminal with capture groups, this returns
    // the contents of the nth capgroup.  otherwise, returns an
    // empty string.
    std::string capgroup(int capi) const {
        if(std::holds_alternative<Terminal>(red))
        return std::get<Terminal>(red).capgroup(capi);
        return "";
    }
};

// This is an lr stack entry (as opposed to a param stack entry).
// In the new dual stack scheme, you would use one of these to
// refer to the param stack, however.
struct StackEntry {
    State          state;
    int            element_id;
    SourcePosition pos;        // start of match in source code
    int            param_ind;  // offset in param_stack
    bool           eject;
    bool           mismatch;

    StackEntry(State st, int el_id, SourcePosition p, int pind, bool ej) :
    state(st),
    element_id(el_id),
    pos(p),
    param_ind(pind),
    eject(ej),
    mismatch(false) {
    }

    // creates a "false" stack entry:
    StackEntry() :
    state(NULL),
    element_id(-1),
    param_ind(-1),
    eject(true),
    mismatch(false) {
    }

    StackEntry(const StackEntry &) = default;

    operator bool() const {
        return element_id > 0; // (null/invalid element id -> false)
    }

    int grammar_element_id() const {
        return element_id;
    }

    bool ejected() const {
        return eject;
    }

    SourcePosition position() const {
        return pos;
    }

    int line_number() const {
        return position().line_number();
    }

    std::string filename() const {
        return position().filename();
    }

    bool is_nonterminal() const {
        return jemplpl_parser::is_nonterminal(element_id);
    }

    // Returns the first Product corresponding to this
    // StackEntry, if there is one.  Otherwise, returns
    // a false Product.
    Product product(const jemplpl_parser &owner) const {
        if(param_ind >= 0 && param_ind < owner.param_stack.size()) {
            return owner.param_stack[param_ind];
        }
        return Product();
    }

    std::string to_str() const {
        return stringformat("{}{} {} param[{}] ({})",
        mismatch?"⏮ ":"",
        state_to_str(state),
        element_str(element_id),
        param_ind,  // need the owner to get the product
        position()
        );
    }
};

// Pushes an element to the lr and/or parameter stacks as appropriate.
// "ejected" elements (those marked with a '^' in fpl source) are
// not pushed to the param stack.  Redundant lr_stack entries may or
// may not actually be pushed.  (in the current implementation, they
// are pushed, but that might not pertain in the future)
void lr_push(
int element_id, bool eject, const SourcePosition &pos, Product pr
) {
    lr_stack.push_back(StackEntry(
    cur_state, element_id, pos, param_stack.size(), eject
    ));
    if(!eject) {
        param_stack.push_back(pr);
    }
}

private:
fpl_reader_p            reader;      // (must be non-null)
State                   cur_state;
std::vector<StackEntry> lr_stack;
int                     lr_read_pos;
std::vector<Product>    param_stack;
size_t                  bytes_eaten; // since last terminal
bool                    stop_parsing;
int                     max_errors;
int                     num_errors;

bool                    single_step; // debugging

// this is called when something appears to have
// gone wrong due to a bug in the parser itself:
void internal_error(const std::string &msg) {
    error(stringformat(
    "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
    ));
    terminate();
}

public:
// constructors:
jemplpl_parser(const jemplpl_parser &rhs) = delete;

jemplpl_parser(fpl_reader_p rdr) :
reader(rdr),
cur_state(&jemplpl_parser::state_0),
lr_read_pos(0),
bytes_eaten(0),
stop_parsing(false),
max_errors(1),
num_errors(0),
single_step(false) {


    #line 442 "src/fpl2cc/fpl_x_parser.h.jemp" 


    lr_stack.reserve(1000);
    param_stack.reserve(1000);
}

// debugging:
void set_single_step(bool newval) { single_step = newval; }
void debug_pause() {
    int inch;
    if(single_step)
    inch = getchar();
    if(inch == 'c')
    single_step = false;
}

template<typename... Args>
void debug_print(const std::string_view &fmt, Args&&... args) {

    #line 462 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // --debug option is off

    #line 466 "src/fpl2cc/fpl_x_parser.h.jemp" 

}

void set_max_errors(int newmax) { max_errors = newmax; }

void error(size_t pos, const std::string &msg) {
    std::string full_msg = reader->format_error_message(pos, msg);
    fputs(full_msg.c_str(), stderr);
    if(++num_errors >= max_errors) {
        fputs("too many errors.  aborting\n", stderr);
        terminate();
    }
}

void error(const std::string &msg) {
    error(reader->current_position(), msg);
}

int error_count() const { return num_errors; }

bool eof() const {
    return reader->eof();
}

public:

std::string filename() const {
    return reader->filename();
}

int line_number() const {
    return reader->line_number();
}

int line_number(size_t pos) const {
    return reader->line_number(pos);
}

SourcePosition position() const {
    return SourcePosition(reader);
}

fpl_reader_p_c const_reader() const {
    return reader;
}

int param_stack_size() const {
    return param_stack.size();
}

int lr_stack_size() const {
    return lr_stack.size();
}

int lr_top_index() const {
    return lr_stack.size() - 1;
}

void lr_pop() {
    if(lr_stack.size() > 0) {
        auto popped = lr_stack.back();
        cur_state = popped.state;
        if(popped.param_ind >= 0) {
            param_stack.resize(popped.param_ind);
        }
        lr_stack.pop_back();
    }

    if(lr_stack.size() == 0) {
        // else there's nothing left to pop on the lr_stack,
        // and the param stack had better be clear, too, or
        // something is wrong:
        if(param_stack.size() > 0) {
            jerror::warning(stringformat(
            "popping from empty lr_stack, but there are {} params\n",
            param_stack.size()
            ));
        }
    }
}

// "pops" and discards down to the new maximum index
// specified
void lr_pop_to(int new_max) {
    while(lr_top_index() > new_max) {
        lr_pop();
    }
}

void clear_mismatches() {
    int num_cleared = 0;
    while(lr_top().mismatch) {
        lr_pop();
        num_cleared++;
    }

    if(lr_read_pos > lr_top_index()) {
        lr_read_pos = lr_top_index() + 1;
    }


    #line 566 "src/fpl2cc/fpl_x_parser.h.jemp" 

}

StackEntry lr_stack_entry(int pos) const {
    // (as usual, negative positions are relative to the top of stack)
    if(pos < 0) pos += lr_stack_size();

    if((pos >= 0) && (pos < lr_stack_size())) {
        return lr_stack[pos];
    } else {
        return StackEntry();
    }
}

StackEntry lr_next() const {
    return lr_stack_entry(lr_read_pos);
}

StackEntry lr_prev() const {
    return lr_stack_entry(lr_read_pos - 1);
}

StackEntry lr_top() const {
    return lr_stack_entry(lr_top_index());
}

// Increments the lr read pointer and returns true if the element ID
// passed matches the next item to read from the lr stack.  Otherwise,
// returns false.
bool lr_read(int element_id) {
    if(element_id == lr_next().element_id) {
        // we may be skipping a known mismatch, in which case
        // we'll return false since it's not a correct match.
        bool mismatch = lr_next().mismatch;
        if(mismatch) {

            #line 608 "src/fpl2cc/fpl_x_parser.h.jemp" 

        }

        lr_read_pos++;
        return !mismatch;
    }
    return false;
}

// lr_position_before_xxx(pos, multiple):  Each returns the
// first position before pos in the lr stack which does not
// match the element ID in question. If pos is past the top
// of the stack, starts at the top of the stack.
// Pseudo-recurses on subexpressions.
//
// These are used to put together the arguments for reduce
// actions.

#line 630 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before___fpl_null(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // _fpl_null
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 0) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__fragment(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // fragment
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 1) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__complete(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // complete
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 2) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__text(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // text
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 3) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_4(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@@'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 4) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_5(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@/*'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 5) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_6(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 6) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_7(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '*/@'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 7) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_8(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /\\n\?/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 8) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_9(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@parameter:'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 9) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_10(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /[^@]+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 10) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_11(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 11) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_12(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@include:'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 12) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_13(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /\\s*/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 13) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_14(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@embed:'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 14) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__leading_ws(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // leading_ws
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 15) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_16(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /@declare\\s+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 16) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__identifier(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // identifier
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 17) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_18(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // ':'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 18) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_19(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /(\?:[^@]|(\?:@@))*/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 19) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_20(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /@realign:\\s*/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 20) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_21(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '#'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 21) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_22(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // !'#'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 22) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__template_variant(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // template_variant
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 23) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_24(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '@-'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 24) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__subst_start(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // subst_start
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 25) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_26(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '-@'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 26) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__trailing_ws(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // trailing_ws
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 27) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__subst_end(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // subst_end
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 28) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_29(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /(\?:[^-@]|-[^@])+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 29) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__rest_of_sub(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // rest_of_sub
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 30) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_31(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /\\n*[ \\t]+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 31) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_32(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /[ \\t]*\\n+[ \\t]+(\?!@)/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 32) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_33(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /[ \\t]*\\n/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 33) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_34(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /#\\s*/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 34) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_35(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /(\?:[^-{@]|-[^@]|)*\\{/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 35) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__control_start(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // control_start
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 36) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_37(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // '}'
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 37) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__control_end(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // control_end
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 38) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_39(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /[^@\\n]+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 39) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_40(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // /[a-zA-Z_][a-zA-Z_0-9]+/
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 40) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_position_before__terminal_41(int pos, bool multiple) const {

    if(pos > lr_top_index())
    pos = lr_top_index();


    #line 639 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // ␄_fpl_goal
    // (checking pos >= 0 because negative indexes are relative
    // to end of stack)
    while(pos >= 0 && lr_stack_entry(pos).element_id == 41) {
        --pos;
        if(!multiple)
        break;
    }

    #line 648 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return pos;
}

#line 680 "src/fpl2cc/fpl_x_parser.h.jemp" 


// lr_stack_size_of_X(pos, multiple):  returns the number of
// stack entries matching X going forward through the lr stack,
// starting at the position passed.   If argument "multiple"
// is false, only counts up to one X.
// Note that while simple elements will be one stack entry
// each, subexpressions can (and normally do) take up multiple
// stack entries per X.

#line 689 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of___fpl_null(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 0) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__fragment(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 1) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__complete(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 2) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__text(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 3) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_4(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 4) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_5(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 5) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_6(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 6) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_7(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 7) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_8(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 8) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_9(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 9) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_10(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 10) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_11(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 11) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_12(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 12) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_13(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 13) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_14(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 14) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__leading_ws(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 15) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_16(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 16) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__identifier(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 17) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_18(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 18) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_19(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 19) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_20(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 20) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_21(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 21) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_22(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 22) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__template_variant(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 23) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_24(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 24) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__subst_start(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 25) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_26(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 26) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__trailing_ws(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 27) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__subst_end(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 28) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_29(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 29) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__rest_of_sub(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 30) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_31(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 31) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_32(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 32) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_33(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 33) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_34(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 34) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_35(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 35) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__control_start(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 36) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_37(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 37) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__control_end(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 38) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_39(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 39) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_40(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 40) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 
int lr_stack_size_of__terminal_41(int pos, bool multiple) const {
    int size = 0;

    #line 695 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // normal case - not a subexpression
    while(lr_stack_entry(pos + size).element_id == 41) {
        ++size;
        if(!multiple)
        break;
    }

    #line 702 "src/fpl2cc/fpl_x_parser.h.jemp" 


    return size;
}

#line 738 "src/fpl2cc/fpl_x_parser.h.jemp" 


// A StackSlice here is a set of 0 or more consecutive lr_stack
// entries. It's used to represent the match(es) which went into
// 1 particular step (see ReductionParameter, below), or the set
// of all steps which led to a current rule match (see
// all_matched_steps(), below), or any other slice of the lr_stack.
class StackSlice {
    int base_index; // in lr_stack
    int size;       // number of elements in lr_stack

    // owner here is annoying because we should be able to
    // infer it... jest feature?
    const jemplpl_parser &owner;

    public:
    // Returns the number of lr_stack entries in this slice:
    int count() const { return size; }

    int start() const { return base_index; }

    // Returns the number of parameter stack entries for this
    // entire slice.  This can be different from the number
    // of lr_stack entries due to ejectedness (in which case
    // there are 0 parameters) as well stuff like melding
    // (which is handled in ReductionParameter)
    int param_count() const {
        StackEntry sel = owner.lr_stack_entry(base_index);

        // no params if we're an empty slice.
        // without this check, we can end up returning a
        // negative size, and no one wants that.
        if(count() == 0) return 0;

        // this slice "contains" all arguments starting
        // at the position in the argument stack starting
        // at the argument from the base element and going
        // to just before the one for the base element of
        // the slice above us, or the top of the argument
        // stack if we're the topmost slice
        int cap_ind = base_index + size;
        if(cap_ind < owner.lr_stack_size()) {
            StackEntry eel = owner.lr_stack_entry(cap_ind);
            return eel.param_ind - sel.param_ind;
        } else {
            // goes to the end of the arg stack:
            return owner.param_stack_size() - sel.param_ind;
        }
    }

    // returns the corresponding base in the param stack
    // or -1 if there is no such thing.
    int param_base() const {
        return owner.lr_stack_entry(base_index).param_ind;
    }

    // construct a slice with a particular base and count.
    // if the count is -1 or unspecified, construct a slice
    // with the given base to the top of the stack
    StackSlice(const jemplpl_parser &o, int base, int count = -1) :
    base_index(base),
    size(count),
    owner(o)
    {
        if(size == -1) {
            size = owner.lr_stack.size() - base;
        }
    }

    // Negative indexes are offset from a hypothetical argument
    // just past the end of the slice (i.e. -1 means end-of-slice).
    // Accessing to entries outside the slice yields a "false"
    // stack entry.
    StackEntry operator [](int ind) const {
        if(ind < 0) ind += size; // allow negative indexes

        int off = ind + base_index;
        if((off < owner.lr_stack_size()) && (off >= 0)) {
            return owner.lr_stack[off];
        } else {
            return StackEntry();
        }
    }

    // Returns the nth "product" (from the param stack)
    // corresponding to this slice.
    // If the index passed is out of bounds, returns a 
    // default product.
    // Note that there may be 0 products for any slice,
    // so the 0th is not guaranteed to be anything real,
    // though if it's not it will still return a valid
    // (though false) Product.
    Product product(int ind, src_location caller = CALLER()) const {
        const int pbase = param_base();

        if(pbase < 0) {
            // this is probably an internal error:
            jerror::error(stringformat(
            "{} product({}) called on stack slice with no param base",
            caller, ind
            ));
            return Product();
        }

        const int num_args = param_count();
        if(ind < 0) {
            jerror::warning(stringformat(
            "{} wrapping is no longer supported on product({})",
            caller, ind
            ));
        }

        if((ind >= 0) && (ind < num_args)) {
            unsigned int sind = pbase + ind;
            return owner.param_stack_entry(sind, caller);
        } else {
            return Product();
        }
    }

    std::string to_str() const {
        std::string out = stringformat(
        "slice of {} entries at {}\n",
        size, base_index
        );
        for(int ind = 0; ind < size; ++ind) {
            out += stringformat("    {}\n", (*this)[ind]);
        }
        return out;
    }
};

// Call this within a reduce function to get a stack slice containing
// all the steps (StackEntries) for the matched rule.
// Don't call from outside a reduce function.
StackSlice all_matched_steps() {
    return StackSlice(*this, lr_read_pos);
}

// call this like:  prod_type_name(typeid(...));
static std::string prod_type_name(const std::type_info &tinf) {

    #line 879 "src/fpl2cc/fpl_x_parser.h.jemp" 

    if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
        return "Terminal";
    }

    #line 883 "src/fpl2cc/fpl_x_parser.h.jemp" 

    if(std::type_index(typeid(std::string)) == std::type_index(tinf)) {
        return "std::string";
    }

    #line 883 "src/fpl2cc/fpl_x_parser.h.jemp" 

    if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
        return "Terminal";
    }
    if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
        return "Product";
    }

    // if you can get here it's massive fail
    return stringformat("<unknown type {} in prod_type_name>", tinf);
}


// This represents the argument for a given step.  One "argument",
// in this context, can contain 0 or more elements (for example,
// in foo+ -> bar;, foo can have 1 or more elements).
template<typename ReduceType>
class ReductionParameter {
    // all access to param and lr stacks go through this:
    StackSlice lr_slice;

    // Number of param stack entries to go forward in the
    // param stack get to the next item in this parameter.
    int next_incr;

    public:
    ReductionParameter(
    jemplpl_parser &o, int lr_base, int lr_count, int lr_incr=1
    ) : lr_slice(o, lr_base, lr_count), next_incr(lr_incr) {
        // avoid divide by zero in count().  (perhaps we should
        // support an incr of 0 for single vars?)
        if(next_incr == 0) next_incr = 1;
    }

    // Returns the "span" size of this parameter in the
    // param stack.  This is the total number of entry
    // slots that the elements of this fpl-author-facing
    // parameter uses, and is potentially different from
    // the count() due to melding.
    int params_span_size() const {
        return lr_slice.param_count();
    }

    // Returns the position in the param stack for the start
    // of our params.
    int params_start() const {
        return lr_slice.param_base();
    }

    // returns the fpl-author-facing number of items
    // in this parameter:
    int count() const {
        int spsize = params_span_size();
        return spsize / next_incr + ((spsize % next_incr)?1:0);
    }

    // (syntactic sugar for optionals)
    bool exists() const { return count() !=  0; }

    SourcePosition position() const {
        return lr_slice[0].position();
    }

    SourcePosition end_position() const {
        return lr_slice[-1].position();
    }

    // this allows you to refer to the stack slice itself from within
    // reduce functions using the at sign (eg thing@self())
    ReductionParameter<ReduceType> self() { return *this; }

    // in reduce code, this is accessed via [] or (for the 0th element)
    // just the name of the variable itself.
    const ReduceType val(int ind = 0, src_location ca = CALLER()) const {
        const int num_args = count();
        if(ind < 0) ind += num_args; // negative = relative to end + 1 

        if((ind < 0) || (ind >= num_args)) {
            jerror::warning(stringformat(
            "Index {} out of range ({} items at {} span {}) at {}",
            ind, num_args, params_start(), params_span_size(), ca
            ));

            // return a default item of the ReduceType so we can move on:
            return ReduceType();
        }

        try {
            return std::get<ReduceType>(
            lr_slice.product(ind * next_incr, ca).var()
            );
        }
        catch (const std::bad_variant_access& e) {
            // this is an internal error and needs to be taken seriously:
            jerror::error(stringformat(
            "{} bad variant access (expected {}) on val({}) in {}\n",
            ca, prod_type_name(typeid(ReduceType)), ind, lr_slice
            ));
        }
        // try to return a default anyway:
        return ReduceType();
    }

    // Returns the value of the parameter,
    // or the default value passed if the index is out of range.
    // This is a convenience method for defaulting things like
    // values of optional parameters.
    const ReduceType val_or(
    ReduceType def, int ind = 0, src_location caller = CALLER()
    ) const {
        // this is as in val(), above:
        const int num_args = count();
        if(ind < 0) ind += num_args; // negative = relative to end + 1 

        if((ind < 0) || (ind >= num_args)) {
            return def;
        }

        return val(ind, caller);
    }

    static std::string type_name() {
        return prod_type_name(typeid(ReduceType));
    }

    std::string concatenate() const {
        std::string out;
        for(int ind = 0; ind < count(); ind++) {
            out += to_string(val(ind));
        }
        return out;
    }

    using ForeachFunc = std::function<void(const ReduceType &)>;
    void foreach(ForeachFunc func) const {
        for(int ind = 0; ind < count(); ++ind) {
            func(val(ind));
        }
    }

    std::string join(const std::string &fmt, const std::string &jv) const {
        std::string out;
        for(int ind = 0; ind < count(); ind++) {
            auto vfmt = stringformat(fmt, val(ind));
            if(ind < count() - 1)
            out += stringformat("{}{}", vfmt, jv);
            else // last element
            out += stringformat("{}", vfmt);
        }
        return out;
    }

    std::string join(const std::string &jv) const {
        return join("{}", jv);
    }

    // formats each according to the format passed and
    // then returns the concatenation of the results
    std::string catmap(const std::string &fmt) const {
        return join(fmt, "");
    }

    std::string to_str() const {
        return stringformat(
        "{} ({} items at {})",
        join("'{}'", ", "), count(), params_start()
        );
    }
};

void set_state(State st) {
    cur_state = st;
}

Product param_stack_entry(int pos, src_location caller = CALLER()) const {
    // this is very similar to lr_stack_entry.  generalize?
    if((pos >= 0) && (pos < param_stack.size())) {
        return param_stack[pos];
    } else {
        jerror::warning(stringformat(
        "param stack access out of range ({}/{}) at {}",
        pos, param_stack.size(), caller
        ));
        return Product();
    }
}

State current_state() const {
    return cur_state;
}

// this is more or less debugging
std::string param_stack_string() const {
    std::string out;
    out += stringformat("param stack ({} items):\n", param_stack.size());
    for(int sind = param_stack.size() - 1; sind >= 0; --sind) {
        out += stringformat(
        "    [{}] {::n}\n", sind, param_stack_entry(sind)
        );
    }
    return out;
}

std::string to_str() const {
    std::string out;

    out += stringformat(
    "next up (lr pos {}): {}\n", lr_read_pos, next_up_str()
    );
    out += stringformat(
    "{} bytes of separator since last terminal\n", bytes_eaten
    );
    out += stringformat("lr stack ({} items):\n", lr_stack.size());
    for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
        out += stringformat(
        " {} [{}] {}\n",
        sind == lr_read_pos?"->":"  ", sind, lr_stack_entry(sind)
        );
    }
    out += param_stack_string();
    return out;
}

Product result() const {
    // (... possibly we should only consider it a result if there's
    // exactly one item on the stack.  could simplify callers)
    return lr_top().product(*this);
}

int result_product_id() const {
    return lr_top().element_id;
}

// mismatch() begins or continues the backtracking process when
// a state hits unexpected input.
void mismatch() {
    // move the lr read pointer to before the last bad push:
    while(lr_stack_entry(--lr_read_pos).mismatch)
    ;

    if(lr_read_pos < 0) {
        lr_read_pos = 0;
        // can't go back any more, so terminate:
        terminate();
    } else {
        // mark whatever was there as a mismatch, and try that
        // state again:
        StackEntry &bad_entry = lr_stack[lr_read_pos];
        bad_entry.mismatch = true;
        cur_state = bad_entry.state;
        reader->go_to(bad_entry.position());
    }
}

void terminate() {
    stop_parsing = true;
}

// Removes terminals from the top of the lr stack and sets
// the source read position to the start of the removed
// terminals.
// This is used after termination to unwind such that the
// read position is just after the last successfully parsed
// thing instead of potentially being after some recognized
// but unused terminals, thus setting the read pointer to
// the start of any unrecognized input.
void rewind_to_nonterm() {
    if(result())
    return; // already after last nonterminal

    size_t rewind_to = reader->current_position();
    while(lr_stack.size() > 0) {
        auto last = lr_stack.back();
        if(last.is_nonterminal()) {
            break;
        }
        rewind_to = last.position();
        lr_pop();
    }
    reader->go_to(rewind_to);
}

// Returns a string with either the next bit of text
// (in French quotes) or the next production
std::string next_up_str() const {
    if(StackEntry next = lr_next()) {
        return stringformat(
        "{} = {::n}",
        element_str(next.element_id), next.product(*this)
        );
    } else {
        return stringformat(
        "«{}» ({}:{::n})",
        reader->debug_peek(32),
        reader->filename(), reader->current_position()
        );
    }
}

// not passing by reference here - instead, crossing fingers
// and hoping it really just gets inlined.
inline void post_parse(std::string result) {

    #line 1028 "src/fpl2cc/fpl_x_parser.h.jemp" 

}

bool more_to_parse() const {
    // there's more to parse if:
    //  - we haven't been told to stop (due to matching _fpl_goal,
    //    or errors, or whatever)
    //  - and there's more input -or- we're not at the goal
    return !stop_parsing
    && ((!eof() || lr_stack.size() > 1) || !result_is_goal());
}

// resets the state of the parser, discarding anything on
// the stack.
// does _not_ reset the input position, so as to allow
// mixed-parser parses.
void reset() {
    debug_print("resetting jemplpl_parser\n");

    lr_stack.clear();
    lr_read_pos      = 0;
    param_stack.clear();
    set_state(&jemplpl_parser::state_0);
    bytes_eaten      = 0;
    stop_parsing     = false;
    num_errors       = 0;
}

// In an fpl parser, we do not want to require that the whole
// input has been consumed.  This allows piecewise parsing.
// For example, a top down parser can invoke an fpl parser
// to handle some class of expressions, receive the result,
// and then continue parsing whatever it was parsing.  Or,
// let's say you're parsing a stream of input, and you want
// to parse it as it comes in instead of all at once after
// getting the entire thing.
//
// So, this parses as much as it can, then leaves the parser
// as intact as possible so that the caller can examine it
// for errors or whatever and decide what to do.
//
void parse_partial() {
    do {
        State st = current_state();
        (this->*st)();
    } while(more_to_parse());
}

// Attempts to parse a goal from the current input.
// If we didn't parse a goal, input remains at the
// position from the start of parse.
// Any additional input after the goal is left and may be
// parsed with additional passes of this or another parser.
// If it parsed a goal product, that product will be returned.
// Otherwise, returns a false product.
const Product parse_goal() {
    reset();
    parse_partial();
    rewind_to_nonterm();
    if(result_is_goal()) {
        return result();
    }
    return Product();
}

// Returns a string containing a list of possible terminals
// when in the state passed.  Used for error messages.
static std::string expected_terminals(State st) {

    #line 1098 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_0 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@parameter:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@include:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@embed:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@/*', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@-', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n*[ \\\\t]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@\\\\n]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/@realign:\\\\s*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/@declare\\\\s+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_1 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_2 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n*[ \\\\t]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@\\\\n]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_3 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_4 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_5 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_6 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_7 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_8 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_9 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'}', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^-{@]|-[^@]|)*\\\\{/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^-@]|-[^@])+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/#\\\\s*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_10 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'-@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_11 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_12 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_13 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_14 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_15 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'-@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_16 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_17 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'-@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_18 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_19 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[a-zA-Z_][a-zA-Z_0-9]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_20 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'#', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^-@]|-[^@])+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_21 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^-@]|-[^@])+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_22 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'-@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_23 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_24 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_25 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'-@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_26 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_27 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "!'#', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_28 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'#', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_29 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_30 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_31 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@-', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/@declare\\\\s+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_32 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_33 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[a-zA-Z_][a-zA-Z_0-9]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_34 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "':', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_35 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^@]|(\\\?:@@))*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_36 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_37 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_38 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_39 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@parameter:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@include:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@embed:', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@/*', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@-', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n*[ \\\\t]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@\\\\n]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/@realign:\\\\s*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/@declare\\\\s+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_40 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_41 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_42 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_43 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_44 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_45 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_46 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\s*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_47 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_48 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_49 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_50 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_51 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\s*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_52 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_53 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_54 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_55 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_56 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_57 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'*/@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_58 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_59 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_60 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_61 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n*[ \\\\t]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[^@\\\\n]+/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/[ \\\\t]*\\\\n/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_62 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "'@', "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_63 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "/\\\\n\\\?/, "

        #line 1103 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_64 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_65 == st) {
        return 
        #line 1101 "src/fpl2cc/fpl_x_parser.h.jemp" 
        "";
    }

    #line 1105 "src/fpl2cc/fpl_x_parser.h.jemp" 

    return "";
}

void report_parse_error(const std::string &errm) {
    // at this point, it looks clearest to just pass the
    // error through.  I'm keeping this function as a
    // place to hook counters or whatever, however.
    error(errm);
}

// returns a string telling why parse() failed, or
// an empty string if it appears to have worked
std::string why_bad_parse() const {
    Product got = result();
    int got_id  = result_product_id();

    // In this case, we're assuming we have the entire input.
    // So, we expect:
    //   - we're at eof (end of input)
    //   - only the result left on the stack
    //   - result is a goal
    if(!eof()) {
        // If we're not at end of input, we stopped when we
        // didn't recognize something.  If there's currently 
        // a "result", that's what was unexpected (i.e. it
        // recognized something, but that something didn't
        // fit the bigger picture).  Otherwise, it means we
        // got some generally unrecognized input:
        std::string prev_str;
        if(StackEntry prev = lr_prev()) {
            prev_str = stringformat(
            " after {} at {}",
            element_str(prev.grammar_element_id()),
            prev.position()
            );
        }
        if(got_id >= 0 && is_nonterminal(got_id)) {
            return stringformat(
            "unexpected element{}: {} ({}).\nso far we have:\n{}",
            prev_str,
            element_str(got_id), got,
            StackSlice(*this, 0)
            //next_up_str()
            );
        } else  {
            return stringformat(
            "unrecognised input{}.  expected one of: {}",
            prev_str,
            expected_terminals(current_state())
            );
        }
    } else if(lr_stack_size() > 1) {
        // If there's extra stuff on the stack after we rewound,
        // it means we recognized more than one component, but
        // nothing complete.
        return "incomplete input";
    } else if(!result_is_goal()) {
        return stringformat(
        "parsed a {} = {}, but that's not a goal ({})",
        element_str(got_id), got, "complete"
        );
    }
    return "";
}

// Parses the contents of the current reader.
// Input contents are assumed to be complete.
// Calls error() if any parse errors were detected.
// Returns whatever it got, regardless of errors,
// which might mean returning a default of whatever
// the reduce type is.
std::string parse() {
    // we're parsing from initial state...
    reset();
    parse_partial();

    // consume any additional "separators" (eg whitespace,
    // comments) before checking the parse, since it's
    // going to check eof()
    eat_separator();

    std::string errm = why_bad_parse();
    if(errm.length()) {
        report_parse_error(errm);
    } else {
        post_parse(result().val());
    }

    return result().val();
}

private:


#line 1199 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 178 "src/jemplpl/jemplpl.fpl"


static inline std::string quote(const std::string &str) {
    return "\"" + c_str_escape(str) + "\"";
}

// returns a string containing a c style "#line"
// line and the code to update the current line number,
// using the stack slice associated with the fpl
// reduction code argument passed.
template<typename SliceType>
static inline std::string line_num(const SliceType &tokens) {
    auto end_pos = tokens.end_position();
    return stringformat(
    "\n#line {} \"{}\"\n"
    "source.ln = {};\n",
    end_pos.line_number(), end_pos.filename(),
    end_pos.line_number()
    );
}

public:

struct _jempl {
    // for the function we'll create:
    std::list<std::string> params;

    std::string realign_fragment;

    Searchpath import_path;
    std::set<std::string> imports;
    std::set<std::filesystem::path> import_files;

    std::string fmt_params() {
        return join(params, ",");
    }

    std::string realign_frag(
    const std::string &filename = "source.filename()",
    const std::string &linenum  = "source.line_number()"
    ) const {
        if(realign_fragment.length()) {
            return "\nout += stringformat(" +
            quote("\n" + realign_fragment + "\n") +
            stringformat(", {}, {});\n", linenum, filename);
        }
        return "";
    }

} jempl;

void init_import_path(const std::filesystem::path &src) {
    jempl.import_path.append(src.parent_path());
    jempl.import_path.append_from_env("JEMP_INCLUDE_PATH");
    jempl.import_path.append_from_env("CPLUS_INCLUDE_PATH");
    jempl.import_path.append_from_env("C_INCLUDE_PATH");
    jempl.import_path.append_from_env("CPATH");
}

void add_import(const std::filesystem::path &imp) {
    jempl.import_files.insert(imp);
}

std::filesystem::path source_filename() const {
    return reader->filename();
}

std::string output_header(
const std::string prog_name, const std::string src_name
) {
    return stringformat(
    "// generated by {} v{}.{}\n"
    "//  source: {}\n",
    prog_name, VERSION_MAJ, VERSION_MIN, src_name
    );
}

static std::string function_name(std::filesystem::path src) {
    // remove directories above:
    src = src.filename();

    // remove _all_ extensions from the src path passed.
    // this means foo.h.jemp -> just foo
    while(src.has_extension())
    src = src.stem();

    return src;
}

std::string output_function_name() const {
    return function_name(source_filename());
}

void init(const std::filesystem::path &src) {
    init_import_path(src);
}

#line 15064 "src/jemplpl/jemplpl.cc"

// return to "private" after each such block.
// this way, authors can add public members
// to the parser without turning other stuff public 
private:

#line 1205 "src/fpl2cc/fpl_x_parser.h.jemp" 


// custom scanners:

#line 1208 "src/fpl2cc/fpl_x_parser.h.jemp" 



#line 1215 "src/fpl2cc/fpl_x_parser.h.jemp" 

#line 1218 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// _fpl_null
bool shift_NONTERM_PRODUCTION___fpl_null(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == __fpl_null) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not __fpl_null)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(__fpl_null)) {
        debug_print("shifting nonterm __fpl_null\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// fragment
bool shift_NONTERM_PRODUCTION__fragment(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _fragment) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _fragment)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_fragment)) {
        debug_print("shifting nonterm _fragment\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// complete
bool shift_NONTERM_PRODUCTION__complete(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _complete) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _complete)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_complete)) {
        debug_print("shifting nonterm _complete\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// text
bool shift_NONTERM_PRODUCTION__text(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _text) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _text)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_text)) {
        debug_print("shifting nonterm _text\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@@' 
bool shift_TERM_EXACT__terminal_4(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_4) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_4);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@@' (@@)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@@")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@@");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@@'\n");

        lr_push(_terminal_4, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_4)) {
            internal_error(stringformat(
            "expected item with id _terminal_4 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@/*' 
bool shift_TERM_EXACT__terminal_5(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_5) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_5);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@/*' (@/*)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@/*")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@/*");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@/*'\n");

        lr_push(_terminal_5, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_5)) {
            internal_error(stringformat(
            "expected item with id _terminal_5 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/ 
bool shift_TERM_REGEX__terminal_6(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_6) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_6);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/ ((\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*)

        std::cmatch match = reader->read_re("(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/\n");

        lr_push(_terminal_6, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_6)) {
            internal_error(stringformat(
            "expected item with id _terminal_6 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '*/@' 
bool shift_TERM_EXACT__terminal_7(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_7) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_7);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '*/@' (*/@)

        const SourcePosition pos = position();
        if(reader->read_exact_match("*/@")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("*/@");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '*/@'\n");

        lr_push(_terminal_7, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_7)) {
            internal_error(stringformat(
            "expected item with id _terminal_7 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /\\n\?/ 
bool shift_TERM_REGEX__terminal_8(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_8) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_8);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /\\n\?/ (\\n\?)

        std::cmatch match = reader->read_re("\\n\?");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /\\\\n\\\?/\n");

        lr_push(_terminal_8, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_8)) {
            internal_error(stringformat(
            "expected item with id _terminal_8 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@parameter:' 
bool shift_TERM_EXACT__terminal_9(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_9) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_9);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@parameter:' (@parameter:)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@parameter:")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@parameter:");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@parameter:'\n");

        lr_push(_terminal_9, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_9)) {
            internal_error(stringformat(
            "expected item with id _terminal_9 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /[^@]+/ 
bool shift_TERM_REGEX__terminal_10(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_10) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_10);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /[^@]+/ ([^@]+)

        std::cmatch match = reader->read_re("[^@]+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /[^@]+/\n");

        lr_push(_terminal_10, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_10)) {
            internal_error(stringformat(
            "expected item with id _terminal_10 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@' 
bool shift_TERM_EXACT__terminal_11(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_11) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_11);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@' (@)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@")) {
            if(
            reader->read_exact_match("@") ||
            reader->read_exact_match("/*") ||
            reader->read_exact_match("parameter:") ||
            reader->read_exact_match("include:") ||
            reader->read_exact_match("embed:") ||
            reader->read_exact_match("-") ||
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@'\n");

        lr_push(_terminal_11, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_11)) {
            internal_error(stringformat(
            "expected item with id _terminal_11 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@include:' 
bool shift_TERM_EXACT__terminal_12(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_12) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_12);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@include:' (@include:)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@include:")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@include:");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@include:'\n");

        lr_push(_terminal_12, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_12)) {
            internal_error(stringformat(
            "expected item with id _terminal_12 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /\\s*/ 
bool shift_TERM_REGEX__terminal_13(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_13) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_13);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /\\s*/ (\\s*)

        std::cmatch match = reader->read_re("\\s*");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /\\\\s*/\n");

        lr_push(_terminal_13, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_13)) {
            internal_error(stringformat(
            "expected item with id _terminal_13 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@embed:' 
bool shift_TERM_EXACT__terminal_14(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_14) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_14);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@embed:' (@embed:)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@embed:")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@embed:");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@embed:'\n");

        lr_push(_terminal_14, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_14)) {
            internal_error(stringformat(
            "expected item with id _terminal_14 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// leading_ws
bool shift_NONTERM_PRODUCTION__leading_ws(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _leading_ws) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _leading_ws)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_leading_ws)) {
        debug_print("shifting nonterm _leading_ws\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /@declare\\s+/ 
bool shift_TERM_REGEX__terminal_16(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_16) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_16);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /@declare\\s+/ (@declare\\s+)

        std::cmatch match = reader->read_re("@declare\\s+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /@declare\\\\s+/\n");

        lr_push(_terminal_16, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_16)) {
            internal_error(stringformat(
            "expected item with id _terminal_16 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// identifier
bool shift_NONTERM_PRODUCTION__identifier(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _identifier) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _identifier)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_identifier)) {
        debug_print("shifting nonterm _identifier\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// ':' 
bool shift_TERM_EXACT__terminal_18(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_18) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_18);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal ':' (:)

        const SourcePosition pos = position();
        if(reader->read_exact_match(":")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal(":");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting ':'\n");

        lr_push(_terminal_18, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_18)) {
            internal_error(stringformat(
            "expected item with id _terminal_18 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /(\?:[^@]|(\?:@@))*/ 
bool shift_TERM_REGEX__terminal_19(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_19) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_19);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /(\?:[^@]|(\?:@@))*/ ((\?:[^@]|(\?:@@))*)

        std::cmatch match = reader->read_re("(\?:[^@]|(\?:@@))*");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /(\\\?:[^@]|(\\\?:@@))*/\n");

        lr_push(_terminal_19, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_19)) {
            internal_error(stringformat(
            "expected item with id _terminal_19 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /@realign:\\s*/ 
bool shift_TERM_REGEX__terminal_20(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_20) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_20);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /@realign:\\s*/ (@realign:\\s*)

        std::cmatch match = reader->read_re("@realign:\\s*");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /@realign:\\\\s*/\n");

        lr_push(_terminal_20, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_20)) {
            internal_error(stringformat(
            "expected item with id _terminal_20 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '#' 
bool shift_TERM_EXACT__terminal_21(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_21) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_21);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '#' (#)

        const SourcePosition pos = position();
        if(reader->read_exact_match("#")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("#");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '#'\n");

        lr_push(_terminal_21, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_21)) {
            internal_error(stringformat(
            "expected item with id _terminal_21 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// !'#' 
bool shift_TERM_EXACT_INV__terminal_22(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_22) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_22);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal !'#' (#)

        std::string match = reader->read_to_exact_match("#");
        if(match.length())
        result = Terminal(match);


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting !'#'\n");

        lr_push(_terminal_22, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_22)) {
            internal_error(stringformat(
            "expected item with id _terminal_22 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// template_variant
bool shift_NONTERM_PRODUCTION__template_variant(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _template_variant) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _template_variant)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_template_variant)) {
        debug_print("shifting nonterm _template_variant\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '@-' 
bool shift_TERM_EXACT__terminal_24(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_24) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_24);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '@-' (@-)

        const SourcePosition pos = position();
        if(reader->read_exact_match("@-")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("@-");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '@-'\n");

        lr_push(_terminal_24, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_24)) {
            internal_error(stringformat(
            "expected item with id _terminal_24 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// subst_start
bool shift_NONTERM_PRODUCTION__subst_start(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _subst_start) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _subst_start)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_subst_start)) {
        debug_print("shifting nonterm _subst_start\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '-@' 
bool shift_TERM_EXACT__terminal_26(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_26) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_26);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '-@' (-@)

        const SourcePosition pos = position();
        if(reader->read_exact_match("-@")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("-@");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '-@'\n");

        lr_push(_terminal_26, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_26)) {
            internal_error(stringformat(
            "expected item with id _terminal_26 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// trailing_ws
bool shift_NONTERM_PRODUCTION__trailing_ws(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _trailing_ws) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _trailing_ws)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_trailing_ws)) {
        debug_print("shifting nonterm _trailing_ws\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// subst_end
bool shift_NONTERM_PRODUCTION__subst_end(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _subst_end) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _subst_end)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_subst_end)) {
        debug_print("shifting nonterm _subst_end\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /(\?:[^-@]|-[^@])+/ 
bool shift_TERM_REGEX__terminal_29(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_29) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_29);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /(\?:[^-@]|-[^@])+/ ((\?:[^-@]|-[^@])+)

        std::cmatch match = reader->read_re("(\?:[^-@]|-[^@])+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /(\\\?:[^-@]|-[^@])+/\n");

        lr_push(_terminal_29, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_29)) {
            internal_error(stringformat(
            "expected item with id _terminal_29 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// rest_of_sub
bool shift_NONTERM_PRODUCTION__rest_of_sub(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _rest_of_sub) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _rest_of_sub)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_rest_of_sub)) {
        debug_print("shifting nonterm _rest_of_sub\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /\\n*[ \\t]+/ 
bool shift_TERM_REGEX__terminal_31(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_31) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_31);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /\\n*[ \\t]+/ (\\n*[ \\t]+)

        std::cmatch match = reader->read_re("\\n*[ \\t]+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /\\\\n*[ \\\\t]+/\n");

        lr_push(_terminal_31, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_31)) {
            internal_error(stringformat(
            "expected item with id _terminal_31 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /[ \\t]*\\n+[ \\t]+(\?!@)/ 
bool shift_TERM_REGEX__terminal_32(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_32) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_32);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /[ \\t]*\\n+[ \\t]+(\?!@)/ ([ \\t]*\\n+[ \\t]+(\?!@))

        std::cmatch match = reader->read_re("[ \\t]*\\n+[ \\t]+(\?!@)");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/\n");

        lr_push(_terminal_32, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_32)) {
            internal_error(stringformat(
            "expected item with id _terminal_32 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /[ \\t]*\\n/ 
bool shift_TERM_REGEX__terminal_33(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_33) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_33);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /[ \\t]*\\n/ ([ \\t]*\\n)

        std::cmatch match = reader->read_re("[ \\t]*\\n");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /[ \\\\t]*\\\\n/\n");

        lr_push(_terminal_33, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_33)) {
            internal_error(stringformat(
            "expected item with id _terminal_33 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /#\\s*/ 
bool shift_TERM_REGEX__terminal_34(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_34) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_34);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /#\\s*/ (#\\s*)

        std::cmatch match = reader->read_re("#\\s*");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /#\\\\s*/\n");

        lr_push(_terminal_34, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_34)) {
            internal_error(stringformat(
            "expected item with id _terminal_34 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /(\?:[^-{@]|-[^@]|)*\\{/ 
bool shift_TERM_REGEX__terminal_35(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_35) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_35);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /(\?:[^-{@]|-[^@]|)*\\{/ ((\?:[^-{@]|-[^@]|)*\\{)

        std::cmatch match = reader->read_re("(\?:[^-{@]|-[^@]|)*\\{");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /(\\\?:[^-{@]|-[^@]|)*\\\\{/\n");

        lr_push(_terminal_35, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_35)) {
            internal_error(stringformat(
            "expected item with id _terminal_35 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// control_start
bool shift_NONTERM_PRODUCTION__control_start(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _control_start) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _control_start)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_control_start)) {
        debug_print("shifting nonterm _control_start\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// '}' 
bool shift_TERM_EXACT__terminal_37(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_37) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_37);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal '}' (})

        const SourcePosition pos = position();
        if(reader->read_exact_match("}")) {
            if(
            false
            ) {
                // "bad suffix" - though we matched the terminal,
                // it's part of a longer terminal.  so, cancel
                // the match/rewind:
                reader->go_to(pos);
            } else {
                result = Terminal("}");
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting '}'\n");

        lr_push(_terminal_37, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_37)) {
            internal_error(stringformat(
            "expected item with id _terminal_37 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 


// control_end
bool shift_NONTERM_PRODUCTION__control_end(bool eject) {
    if(lr_next().mismatch && lr_next().element_id == _control_end) {
        debug_print(
        "not matching mismatched nonterm ('{}' is not _control_end)\n",
        lr_next()
        );
        return false;
    }

    if(lr_read(_control_end)) {
        debug_print("shifting nonterm _control_end\n");
        return true;
    }

    return false;
}



#line 1221 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /[^@\\n]+/ 
bool shift_TERM_REGEX__terminal_39(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_39) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_39);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /[^@\\n]+/ ([^@\\n]+)

        std::cmatch match = reader->read_re("[^@\\n]+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /[^@\\\\n]+/\n");

        lr_push(_terminal_39, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_39)) {
            internal_error(stringformat(
            "expected item with id _terminal_39 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// /[a-zA-Z_][a-zA-Z_0-9]+/ 
bool shift_TERM_REGEX__terminal_40(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_40) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_40);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal /[a-zA-Z_][a-zA-Z_0-9]+/ ([a-zA-Z_][a-zA-Z_0-9]+)

        std::cmatch match = reader->read_re("[a-zA-Z_][a-zA-Z_0-9]+");
        if(!match.empty()) {
            if(match.length() || (lr_top().position() != position())) {
                result = Terminal(match.begin(), match.end());
            }
        }


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting /[a-zA-Z_][a-zA-Z_0-9]+/\n");

        lr_push(_terminal_40, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_40)) {
            internal_error(stringformat(
            "expected item with id _terminal_40 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1219 "src/fpl2cc/fpl_x_parser.h.jemp" 

// (terminals and assertions - everything else)

#line 4 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 


#line 8 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
// ␄_fpl_goal 
bool shift_END_OF_PARSE__terminal_41(bool eject) {
    if(auto next_up = lr_next()) {
        if(next_up.mismatch && next_up.element_id == _terminal_41) {
            // parser has already determined that this element isn't
            // leading to any legitimate production in this context
            // (it's a "mismatch"), so "read" it and return false so
            // that other states/shifts can try to match something
            // else:
            lr_read(_terminal_41);
        }
        // Would this ever be a match?  
        return false;
    }

    const SourcePosition pos = position();
    Terminal result;

    {
        // "scan" a terminal by advancing the read pointer to just beyond
        // the terminal if the current input matches the element passed.
        // Leaves the read pointer where it is and leaves the result_var
        // untouched if the current input doesn't match the element passed.

        // scan terminal ␄_fpl_goal (_fpl_goal)

        // end of parse placeholder


    }



    if(result) {
        clear_mismatches();  // (we matched)

        debug_print("shifting ␄_fpl_goal\n");

        lr_push(_terminal_41, eject, pos, Product(result));


        #line 42 "src/fpl2cc/fpl_x_parser_shift_term.h.jemp" 
        bytes_eaten = 0;

        if(!lr_read(_terminal_41)) {
            internal_error(stringformat(
            "expected item with id _terminal_41 but this was next up (at lr {}): {}\n"
            "stack:\n{}\n",
            lr_read_pos, lr_next(),
            lr_stack
            ));
        }

        return true;
    }

    return false;
}



#line 1224 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1225 "src/fpl2cc/fpl_x_parser.h.jemp" 


// shift_NONE_xxx()
bool shift_NONE___fpl_null(bool eject) {
    // this always matches. it's used to match at ends of rules.
    return true;
}


public:

typedef enum {

    #line 1231 "src/fpl2cc/fpl_x_parser.h.jemp" 
    __fpl_null, // 0 _fpl_null

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _fragment, // 1 fragment

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _complete, // 2 complete

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _text, // 3 text

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_4, // 4 '@@'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_5, // 5 '@/*'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_6, // 6 /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_7, // 7 '*/@'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_8, // 8 /\\n\?/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_9, // 9 '@parameter:'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_10, // 10 /[^@]+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_11, // 11 '@'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_12, // 12 '@include:'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_13, // 13 /\\s*/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_14, // 14 '@embed:'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _leading_ws, // 15 leading_ws

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_16, // 16 /@declare\\s+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _identifier, // 17 identifier

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_18, // 18 ':'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_19, // 19 /(\?:[^@]|(\?:@@))*/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_20, // 20 /@realign:\\s*/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_21, // 21 '#'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_22, // 22 !'#'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _template_variant, // 23 template_variant

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_24, // 24 '@-'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _subst_start, // 25 subst_start

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_26, // 26 '-@'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _trailing_ws, // 27 trailing_ws

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _subst_end, // 28 subst_end

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_29, // 29 /(\?:[^-@]|-[^@])+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _rest_of_sub, // 30 rest_of_sub

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_31, // 31 /\\n*[ \\t]+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_32, // 32 /[ \\t]*\\n+[ \\t]+(\?!@)/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_33, // 33 /[ \\t]*\\n/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_34, // 34 /#\\s*/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_35, // 35 /(\?:[^-{@]|-[^@]|)*\\{/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _control_start, // 36 control_start

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_37, // 37 '}'

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _control_end, // 38 control_end

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_39, // 39 /[^@\\n]+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_40, // 40 /[a-zA-Z_][a-zA-Z_0-9]+/

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
    _terminal_41, // 41 ␄_fpl_goal

    #line 1234 "src/fpl2cc/fpl_x_parser.h.jemp" 
} ElementID;

// returns a string describing the element matching the ID
// passed. this is for debugging.
static std::string element_str(int id) {
    switch(id) {

        #line 1241 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 0: return "_fpl_null (0)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 1: return "fragment (1)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 2: return "complete (2)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 3: return "text (3)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 4: return "'@@' (4)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 5: return "'@/*' (5)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 6: return "/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/ (6)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 7: return "'*/@' (7)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 8: return "/\\\\n\\\?/ (8)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 9: return "'@parameter:' (9)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 10: return "/[^@]+/ (10)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 11: return "'@' (11)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 12: return "'@include:' (12)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 13: return "/\\\\s*/ (13)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 14: return "'@embed:' (14)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 15: return "leading_ws (15)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 16: return "/@declare\\\\s+/ (16)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 17: return "identifier (17)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 18: return "':' (18)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 19: return "/(\\\?:[^@]|(\\\?:@@))*/ (19)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 20: return "/@realign:\\\\s*/ (20)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 21: return "'#' (21)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 22: return "!'#' (22)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 23: return "template_variant (23)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 24: return "'@-' (24)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 25: return "subst_start (25)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 26: return "'-@' (26)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 27: return "trailing_ws (27)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 28: return "subst_end (28)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 29: return "/(\\\?:[^-@]|-[^@])+/ (29)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 30: return "rest_of_sub (30)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 31: return "/\\\\n*[ \\\\t]+/ (31)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 32: return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/ (32)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 33: return "/[ \\\\t]*\\\\n/ (33)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 34: return "/#\\\\s*/ (34)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 35: return "/(\\\?:[^-{@]|-[^@]|)*\\\\{/ (35)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 36: return "control_start (36)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 37: return "'}' (37)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 38: return "control_end (38)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 39: return "/[^@\\\\n]+/ (39)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 40: return "/[a-zA-Z_][a-zA-Z_0-9]+/ (40)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 41: return "␄_fpl_goal (41)";

        #line 1244 "src/fpl2cc/fpl_x_parser.h.jemp" 
    }
    return stringformat("¡unknown element id {}!", id);
}

static bool is_nonterminal(int id, const std::string &caller = CALLER()) {
    switch(id) {

        #line 1251 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 0: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 1: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 2: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 3: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 4: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 5: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 6: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 7: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 8: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 9: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 10: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 11: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 12: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 13: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 14: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 15: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 16: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 17: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 18: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 19: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 20: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 21: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 22: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 23: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 24: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 25: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 26: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 27: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 28: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 29: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 30: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 31: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 32: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 33: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 34: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 35: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 36: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 37: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 38: return true;

        #line 1254 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 39: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 40: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1252 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case 41: return false;

        #line 1256 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1257 "src/fpl2cc/fpl_x_parser.h.jemp" 
    }
    jerror::error(stringformat(
    "internal error {}: invalid terminal id: {}\n", caller, id
    ));
    return false;
}

// returns the name of the state function for the state pointer passed
static std::string state_to_str(State st) {
    if(!st) return "NULL";
    // c++ won't let you compare pointers in a switch statement.. sigh

    #line 1269 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_0 == st) return "state_0";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_1 == st) return "state_1";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_2 == st) return "state_2";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_3 == st) return "state_3";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_4 == st) return "state_4";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_5 == st) return "state_5";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_6 == st) return "state_6";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_7 == st) return "state_7";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_8 == st) return "state_8";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_9 == st) return "state_9";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_10 == st) return "state_10";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_11 == st) return "state_11";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_12 == st) return "state_12";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_13 == st) return "state_13";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_14 == st) return "state_14";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_15 == st) return "state_15";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_16 == st) return "state_16";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_17 == st) return "state_17";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_18 == st) return "state_18";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_19 == st) return "state_19";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_20 == st) return "state_20";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_21 == st) return "state_21";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_22 == st) return "state_22";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_23 == st) return "state_23";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_24 == st) return "state_24";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_25 == st) return "state_25";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_26 == st) return "state_26";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_27 == st) return "state_27";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_28 == st) return "state_28";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_29 == st) return "state_29";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_30 == st) return "state_30";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_31 == st) return "state_31";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_32 == st) return "state_32";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_33 == st) return "state_33";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_34 == st) return "state_34";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_35 == st) return "state_35";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_36 == st) return "state_36";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_37 == st) return "state_37";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_38 == st) return "state_38";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_39 == st) return "state_39";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_40 == st) return "state_40";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_41 == st) return "state_41";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_42 == st) return "state_42";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_43 == st) return "state_43";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_44 == st) return "state_44";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_45 == st) return "state_45";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_46 == st) return "state_46";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_47 == st) return "state_47";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_48 == st) return "state_48";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_49 == st) return "state_49";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_50 == st) return "state_50";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_51 == st) return "state_51";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_52 == st) return "state_52";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_53 == st) return "state_53";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_54 == st) return "state_54";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_55 == st) return "state_55";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_56 == st) return "state_56";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_57 == st) return "state_57";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_58 == st) return "state_58";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_59 == st) return "state_59";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_60 == st) return "state_60";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_61 == st) return "state_61";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_62 == st) return "state_62";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_63 == st) return "state_63";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_64 == st) return "state_64";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_65 == st) return "state_65";

    #line 1271 "src/fpl2cc/fpl_x_parser.h.jemp" 

    // if we got here, the State (pointer) passed doesn't match any
    // of our state functions:
    return "<not a state>";
}

// return a stack-trace style dump of the state passed.
static const char *state_string(State st) {

    #line 1279 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_0 == st) {
        return "state_0:\n"
        "    complete (0:1):\t •fragment+:fragments \t=> state 39\t(src/grammarlib/jemp.fpl:12)\n"
        "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
        "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
        "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 56\t(src/grammarlib/jemp.fpl:24)\n"
        "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:35)\n"
        "    fragment (5:5):\t •'@include:'^ /\\\\s*/^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 46\t(src/grammarlib/jemp.fpl:40)\n"
        "    fragment (6:5):\t •'@embed:'^ /\\\\s*/^ /[^@]+/:embed_file '@'^ /\\\\n\\\?/^ \t=> state 51\t(src/grammarlib/jemp.fpl:46)\n"
        "    fragment (7:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:52)\n"
        "    fragment (7:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 33\t(src/grammarlib/jemp.fpl:52)\n"
        "    fragment (8:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 61\t(src/grammarlib/jemp.fpl:65)\n"
        "    subst_start (10:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 31\t(src/grammarlib/jemp.fpl:72)\n"
        "    subst_start (10:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 32\t(src/grammarlib/jemp.fpl:72)\n"
        "    subst_start (11:1):\t •'@':arg_0 \t=> state 60\t(src/grammarlib/jemp.fpl:73)\n"
        "    leading_ws (15:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:83)\n"
        "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:97)\n"
        "    trailing_ws (17:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:101)\n"
        "    fragment (18:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:109)\n"
        "    fragment (19:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:112)\n"
        "    control_start (20:3):\t •subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:124)\n"
        "    control_end (21:3):\t •subst_start^ '}':control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:125)\n"
        "    fragment (22:1):\t •control_start:control_statement \t=> state 40\t(src/grammarlib/jemp.fpl:127)\n"
        "    fragment (23:1):\t •control_end:control_statement \t=> state 41\t(src/grammarlib/jemp.fpl:128)\n"
        "    fragment (24:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:133)\n"
        "    text (25:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:137)\n"
        "    text (26:1):\t •leading_ws \t=> state 31\t(src/grammarlib/jemp.fpl:141)\n"
        "    text (27:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:142)\n"
        "    _fpl_goal (29:1):\t •complete \t=> state 65\t(src/fpl2cc/productions.h:4227)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_1 == st) {
        return "state_1:\n"
        "    text (27:0):\t trailing_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:142)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_2 == st) {
        return "state_2:\n"
        "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
        "    fragment (1:0):\t text+:chunks •\t=> (reduce)\t(src/grammarlib/jemp.fpl:15)\n"
        "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
        "    leading_ws (15:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:83)\n"
        "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:97)\n"
        "    trailing_ws (17:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:101)\n"
        "    text (25:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:137)\n"
        "    text (26:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:141)\n"
        "    text (27:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:142)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_3 == st) {
        return "state_3:\n"
        "    text (26:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:141)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_4 == st) {
        return "state_4:\n"
        "    text (2:0):\t '@@':at_sign •\t=> (reduce)\t(src/grammarlib/jemp.fpl:20)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_5 == st) {
        return "state_5:\n"
        "    leading_ws (15:0):\t /\\\\n*[ \\\\t]+/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:83)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_6 == st) {
        return "state_6:\n"
        "    text (25:0):\t /[^@\\\\n]+/:t •\t=> (reduce)\t(src/grammarlib/jemp.fpl:137)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_7 == st) {
        return "state_7:\n"
        "    trailing_ws (16:0):\t /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:97)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_8 == st) {
        return "state_8:\n"
        "    trailing_ws (17:0):\t /[ \\\\t]*\\\\n/:ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:101)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_9 == st) {
        return "state_9:\n"
        "    fragment (18:5):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 19\t(src/grammarlib/jemp.fpl:109)\n"
        "    fragment (19:4):\t subst_start^ •/#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 19\t(src/grammarlib/jemp.fpl:112)\n"
        "    control_start (20:2):\t subst_start^ •/(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ \t=> state 15\t(src/grammarlib/jemp.fpl:124)\n"
        "    control_end (21:2):\t subst_start^ •'}':control_statement subst_end^ \t=> state 10\t(src/grammarlib/jemp.fpl:125)\n"
        "    fragment (24:2):\t subst_start^ •/(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 17\t(src/grammarlib/jemp.fpl:133)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_10 == st) {
        return "state_10:\n"
        "    subst_end (12:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (13:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:76)\n"
        "    control_end (21:1):\t subst_start^ '}':control_statement •subst_end^ \t=> state 11\t(src/grammarlib/jemp.fpl:125)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_11 == st) {
        return "state_11:\n"
        "    control_end (21:0):\t subst_start^ '}':control_statement subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:125)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_12 == st) {
        return "state_12:\n"
        "    subst_end (13:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:76)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_13 == st) {
        return "state_13:\n"
        "    subst_end (12:1):\t '-@':arg_0 •trailing_ws\?^ \t=> state 14\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (12:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:75)\n"
        "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:97)\n"
        "    trailing_ws (17:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:101)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_14 == st) {
        return "state_14:\n"
        "    subst_end (12:0):\t '-@':arg_0 trailing_ws\?^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:75)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_15 == st) {
        return "state_15:\n"
        "    subst_end (12:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (13:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:76)\n"
        "    control_start (20:1):\t subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement •subst_end^ \t=> state 16\t(src/grammarlib/jemp.fpl:124)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_16 == st) {
        return "state_16:\n"
        "    control_start (20:0):\t subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:124)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_17 == st) {
        return "state_17:\n"
        "    subst_end (12:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (13:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:76)\n"
        "    fragment (24:1):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable •subst_end^ \t=> state 18\t(src/grammarlib/jemp.fpl:133)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_18 == st) {
        return "state_18:\n"
        "    fragment (24:0):\t subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:133)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_19 == st) {
        return "state_19:\n"
        "    fragment (18:4):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 20\t(src/grammarlib/jemp.fpl:109)\n"
        "    fragment (19:3):\t subst_start^ /#\\\\s*/^ •identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 20\t(src/grammarlib/jemp.fpl:112)\n"
        "    identifier (28:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 30\t(src/grammarlib/jemp.fpl:145)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_20 == st) {
        return "state_20:\n"
        "    template_variant (9:3):\t •'#'^ !'#':variant_expression '#'^ \t=> state 27\t(src/grammarlib/jemp.fpl:70)\n"
        "    rest_of_sub (14:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 24\t(src/grammarlib/jemp.fpl:77)\n"
        "    fragment (18:3):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 21\t(src/grammarlib/jemp.fpl:109)\n"
        "    fragment (19:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name •rest_of_sub:jempl_args subst_end^ \t=> state 25\t(src/grammarlib/jemp.fpl:112)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_21 == st) {
        return "state_21:\n"
        "    rest_of_sub (14:1):\t •/(\\\?:[^-@]|-[^@])+/:arg_0 \t=> state 24\t(src/grammarlib/jemp.fpl:77)\n"
        "    fragment (18:2):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant •rest_of_sub:jempl_args subst_end^ \t=> state 22\t(src/grammarlib/jemp.fpl:109)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_22 == st) {
        return "state_22:\n"
        "    subst_end (12:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (13:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:76)\n"
        "    fragment (18:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args •subst_end^ \t=> state 23\t(src/grammarlib/jemp.fpl:109)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_23 == st) {
        return "state_23:\n"
        "    fragment (18:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:109)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_24 == st) {
        return "state_24:\n"
        "    rest_of_sub (14:0):\t /(\\\?:[^-@]|-[^@])+/:arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:77)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_25 == st) {
        return "state_25:\n"
        "    subst_end (12:2):\t •'-@':arg_0 trailing_ws\?^ \t=> state 13\t(src/grammarlib/jemp.fpl:75)\n"
        "    subst_end (13:1):\t •'@':arg_0 \t=> state 12\t(src/grammarlib/jemp.fpl:76)\n"
        "    fragment (19:1):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args •subst_end^ \t=> state 26\t(src/grammarlib/jemp.fpl:112)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_26 == st) {
        return "state_26:\n"
        "    fragment (19:0):\t subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:112)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_27 == st) {
        return "state_27:\n"
        "    template_variant (9:2):\t '#'^ •!'#':variant_expression '#'^ \t=> state 28\t(src/grammarlib/jemp.fpl:70)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_28 == st) {
        return "state_28:\n"
        "    template_variant (9:1):\t '#'^ !'#':variant_expression •'#'^ \t=> state 29\t(src/grammarlib/jemp.fpl:70)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_29 == st) {
        return "state_29:\n"
        "    template_variant (9:0):\t '#'^ !'#':variant_expression '#'^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:70)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_30 == st) {
        return "state_30:\n"
        "    identifier (28:0):\t /[a-zA-Z_][a-zA-Z_0-9]+/:name •\t=> (reduce)\t(src/grammarlib/jemp.fpl:145)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_31 == st) {
        return "state_31:\n"
        "    fragment (7:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 33\t(src/grammarlib/jemp.fpl:52)\n"
        "    subst_start (10:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 32\t(src/grammarlib/jemp.fpl:72)\n"
        "    text (26:0):\t leading_ws •\t=> (reduce)\t(src/grammarlib/jemp.fpl:141)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_32 == st) {
        return "state_32:\n"
        "    subst_start (10:0):\t leading_ws\?^ '@-':arg_1 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:72)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_33 == st) {
        return "state_33:\n"
        "    fragment (7:5):\t leading_ws\? /@declare\\\\s+/^ •identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 34\t(src/grammarlib/jemp.fpl:52)\n"
        "    identifier (28:1):\t •/[a-zA-Z_][a-zA-Z_0-9]+/:name \t=> state 30\t(src/grammarlib/jemp.fpl:145)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_34 == st) {
        return "state_34:\n"
        "    fragment (7:4):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl •':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 35\t(src/grammarlib/jemp.fpl:52)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_35 == st) {
        return "state_35:\n"
        "    fragment (7:3):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ •/(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 36\t(src/grammarlib/jemp.fpl:52)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_36 == st) {
        return "state_36:\n"
        "    fragment (7:2):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value •'@'^ /\\\\n\\\?/^ \t=> state 37\t(src/grammarlib/jemp.fpl:52)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_37 == st) {
        return "state_37:\n"
        "    fragment (7:1):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ •/\\\\n\\\?/^ \t=> state 38\t(src/grammarlib/jemp.fpl:52)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_38 == st) {
        return "state_38:\n"
        "    fragment (7:0):\t leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:52)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_39 == st) {
        return "state_39:\n"
        "    complete (0:1):\t •fragment+:fragments \t=> state 39\t(src/grammarlib/jemp.fpl:12)\n"
        "    complete (0:0):\t fragment+:fragments •\t=> (reduce)\t(src/grammarlib/jemp.fpl:12)\n"
        "    fragment (1:1):\t •text+:chunks \t=> state 2\t(src/grammarlib/jemp.fpl:15)\n"
        "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
        "    fragment (3:4):\t •'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 56\t(src/grammarlib/jemp.fpl:24)\n"
        "    fragment (4:4):\t •'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 42\t(src/grammarlib/jemp.fpl:35)\n"
        "    fragment (5:5):\t •'@include:'^ /\\\\s*/^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 46\t(src/grammarlib/jemp.fpl:40)\n"
        "    fragment (6:5):\t •'@embed:'^ /\\\\s*/^ /[^@]+/:embed_file '@'^ /\\\\n\\\?/^ \t=> state 51\t(src/grammarlib/jemp.fpl:46)\n"
        "    fragment (7:7):\t •leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 31\t(src/grammarlib/jemp.fpl:52)\n"
        "    fragment (7:6):\t leading_ws\? •/@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ \t=> state 33\t(src/grammarlib/jemp.fpl:52)\n"
        "    fragment (8:4):\t •/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ \t=> state 61\t(src/grammarlib/jemp.fpl:65)\n"
        "    subst_start (10:2):\t •leading_ws\?^ '@-':arg_1 \t=> state 31\t(src/grammarlib/jemp.fpl:72)\n"
        "    subst_start (10:1):\t leading_ws\?^ •'@-':arg_1 \t=> state 32\t(src/grammarlib/jemp.fpl:72)\n"
        "    subst_start (11:1):\t •'@':arg_0 \t=> state 60\t(src/grammarlib/jemp.fpl:73)\n"
        "    leading_ws (15:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:83)\n"
        "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:97)\n"
        "    trailing_ws (17:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:101)\n"
        "    fragment (18:6):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:109)\n"
        "    fragment (19:5):\t •subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:112)\n"
        "    control_start (20:3):\t •subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:124)\n"
        "    control_end (21:3):\t •subst_start^ '}':control_statement subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:125)\n"
        "    fragment (22:1):\t •control_start:control_statement \t=> state 40\t(src/grammarlib/jemp.fpl:127)\n"
        "    fragment (23:1):\t •control_end:control_statement \t=> state 41\t(src/grammarlib/jemp.fpl:128)\n"
        "    fragment (24:3):\t •subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ \t=> state 9\t(src/grammarlib/jemp.fpl:133)\n"
        "    text (25:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:137)\n"
        "    text (26:1):\t •leading_ws \t=> state 31\t(src/grammarlib/jemp.fpl:141)\n"
        "    text (27:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:142)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_40 == st) {
        return "state_40:\n"
        "    fragment (22:0):\t control_start:control_statement •\t=> (reduce)\t(src/grammarlib/jemp.fpl:127)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_41 == st) {
        return "state_41:\n"
        "    fragment (23:0):\t control_end:control_statement •\t=> (reduce)\t(src/grammarlib/jemp.fpl:128)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_42 == st) {
        return "state_42:\n"
        "    fragment (4:3):\t '@parameter:'^ •/[^@]+/:param_decl '@'^ /\\\\n\\\?/^ \t=> state 43\t(src/grammarlib/jemp.fpl:35)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_43 == st) {
        return "state_43:\n"
        "    fragment (4:2):\t '@parameter:'^ /[^@]+/:param_decl •'@'^ /\\\\n\\\?/^ \t=> state 44\t(src/grammarlib/jemp.fpl:35)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_44 == st) {
        return "state_44:\n"
        "    fragment (4:1):\t '@parameter:'^ /[^@]+/:param_decl '@'^ •/\\\\n\\\?/^ \t=> state 45\t(src/grammarlib/jemp.fpl:35)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_45 == st) {
        return "state_45:\n"
        "    fragment (4:0):\t '@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:35)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_46 == st) {
        return "state_46:\n"
        "    fragment (5:4):\t '@include:'^ •/\\\\s*/^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 47\t(src/grammarlib/jemp.fpl:40)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_47 == st) {
        return "state_47:\n"
        "    fragment (5:3):\t '@include:'^ /\\\\s*/^ •/[^@]+/:include_file '@'^ /\\\\n\\\?/^ \t=> state 48\t(src/grammarlib/jemp.fpl:40)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_48 == st) {
        return "state_48:\n"
        "    fragment (5:2):\t '@include:'^ /\\\\s*/^ /[^@]+/:include_file •'@'^ /\\\\n\\\?/^ \t=> state 49\t(src/grammarlib/jemp.fpl:40)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_49 == st) {
        return "state_49:\n"
        "    fragment (5:1):\t '@include:'^ /\\\\s*/^ /[^@]+/:include_file '@'^ •/\\\\n\\\?/^ \t=> state 50\t(src/grammarlib/jemp.fpl:40)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_50 == st) {
        return "state_50:\n"
        "    fragment (5:0):\t '@include:'^ /\\\\s*/^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:40)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_51 == st) {
        return "state_51:\n"
        "    fragment (6:4):\t '@embed:'^ •/\\\\s*/^ /[^@]+/:embed_file '@'^ /\\\\n\\\?/^ \t=> state 52\t(src/grammarlib/jemp.fpl:46)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_52 == st) {
        return "state_52:\n"
        "    fragment (6:3):\t '@embed:'^ /\\\\s*/^ •/[^@]+/:embed_file '@'^ /\\\\n\\\?/^ \t=> state 53\t(src/grammarlib/jemp.fpl:46)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_53 == st) {
        return "state_53:\n"
        "    fragment (6:2):\t '@embed:'^ /\\\\s*/^ /[^@]+/:embed_file •'@'^ /\\\\n\\\?/^ \t=> state 54\t(src/grammarlib/jemp.fpl:46)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_54 == st) {
        return "state_54:\n"
        "    fragment (6:1):\t '@embed:'^ /\\\\s*/^ /[^@]+/:embed_file '@'^ •/\\\\n\\\?/^ \t=> state 55\t(src/grammarlib/jemp.fpl:46)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_55 == st) {
        return "state_55:\n"
        "    fragment (6:0):\t '@embed:'^ /\\\\s*/^ /[^@]+/:embed_file '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:46)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_56 == st) {
        return "state_56:\n"
        "    fragment (3:3):\t '@/*'^ •/(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ \t=> state 57\t(src/grammarlib/jemp.fpl:24)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_57 == st) {
        return "state_57:\n"
        "    fragment (3:2):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment •'*/@'^ /\\\\n\\\?/^ \t=> state 58\t(src/grammarlib/jemp.fpl:24)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_58 == st) {
        return "state_58:\n"
        "    fragment (3:1):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ •/\\\\n\\\?/^ \t=> state 59\t(src/grammarlib/jemp.fpl:24)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_59 == st) {
        return "state_59:\n"
        "    fragment (3:0):\t '@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:24)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_60 == st) {
        return "state_60:\n"
        "    subst_start (11:0):\t '@':arg_0 •\t=> (reduce)\t(src/grammarlib/jemp.fpl:73)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_61 == st) {
        return "state_61:\n"
        "    text (2:1):\t •'@@':at_sign \t=> state 4\t(src/grammarlib/jemp.fpl:20)\n"
        "    fragment (8:3):\t /@realign:\\\\s*/^ •text:realign '@'^ /\\\\n\\\?/^ \t=> state 62\t(src/grammarlib/jemp.fpl:65)\n"
        "    leading_ws (15:1):\t •/\\\\n*[ \\\\t]+/:ws \t=> state 5\t(src/grammarlib/jemp.fpl:83)\n"
        "    trailing_ws (16:1):\t •/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws \t=> state 7\t(src/grammarlib/jemp.fpl:97)\n"
        "    trailing_ws (17:1):\t •/[ \\\\t]*\\\\n/:ws \t=> state 8\t(src/grammarlib/jemp.fpl:101)\n"
        "    text (25:1):\t •/[^@\\\\n]+/:t \t=> state 6\t(src/grammarlib/jemp.fpl:137)\n"
        "    text (26:1):\t •leading_ws \t=> state 3\t(src/grammarlib/jemp.fpl:141)\n"
        "    text (27:1):\t •trailing_ws \t=> state 1\t(src/grammarlib/jemp.fpl:142)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_62 == st) {
        return "state_62:\n"
        "    fragment (8:2):\t /@realign:\\\\s*/^ text:realign •'@'^ /\\\\n\\\?/^ \t=> state 63\t(src/grammarlib/jemp.fpl:65)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_63 == st) {
        return "state_63:\n"
        "    fragment (8:1):\t /@realign:\\\\s*/^ text:realign '@'^ •/\\\\n\\\?/^ \t=> state 64\t(src/grammarlib/jemp.fpl:65)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_64 == st) {
        return "state_64:\n"
        "    fragment (8:0):\t /@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ •\t=> (reduce)\t(src/grammarlib/jemp.fpl:65)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_65 == st) {
        return "state_65:\n"
        "    _fpl_goal (29:0):\t complete •\t=> (done)\t(src/fpl2cc/productions.h:4227)\n"
        ;
    }

    #line 1286 "src/fpl2cc/fpl_x_parser.h.jemp" 

    return "<invalid state>";
}

// Returns true if elements matching the element id passed
// are ejected in the context of the given state, or false
// otherwise.
// XXX actually this can all be determined when compiling the fpl.
// needs no runtime check.  nicht war?
static bool state_ejects(State st, int element_id) {

    #line 1296 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_0 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_start == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_9 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_12 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_14 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_5 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_20 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_16 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_1 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_2 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_3 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_4 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_5 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_6 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_7 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_8 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_9 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_34 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_10 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_end == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_11 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_12 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_13 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_trailing_ws == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_14 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_15 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_end == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_16 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_17 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_end == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_18 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_19 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_20 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_21 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_21 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_22 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_end == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_23 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_24 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_25 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_end == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_26 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_27 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_28 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_21 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_29 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_30 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_31 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_16 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_32 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_33 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_34 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_18 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_35 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_36 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_11 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_37 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_38 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_39 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_subst_start == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_9 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_12 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_14 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_5 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_20 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_16 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_40 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_41 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_42 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_43 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_11 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_44 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_45 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_46 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_13 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_47 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_48 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_11 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_49 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_50 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_51 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_13 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_52 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_53 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_11 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_54 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_55 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_56 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_57 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_7 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_58 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_59 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_60 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_61 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_62 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_11 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_63 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::_terminal_8 == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_64 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    if(&jemplpl_parser::state_65 == st) {

        #line 1299 "src/fpl2cc/fpl_x_parser.h.jemp" 

        if(ElementID::__fpl_null == element_id) {
            return true;
        } else

        #line 1303 "src/fpl2cc/fpl_x_parser.h.jemp" 

        {
            return false;
        }
    } else

    #line 1308 "src/fpl2cc/fpl_x_parser.h.jemp" 
    {
        return false;
    }
}

static bool is_goal(int el_id) {
    switch(el_id) {

        #line 1316 "src/fpl2cc/fpl_x_parser.h.jemp" 
        case ElementID::_complete: return true;

        #line 1318 "src/fpl2cc/fpl_x_parser.h.jemp" 

        default: return false;
    }
    return false;
}

bool result_is_goal() const {
    return is_goal(result_product_id());
}

static size_t separator_length(const utf8_byte *inp) {

    #line 1329 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1334 "src/fpl2cc/fpl_x_parser.h.jemp" 
    {

        #line 1336 "src/fpl2cc/fpl_x_parser.h.jemp" 

        #line 1339 "src/fpl2cc/fpl_x_parser.h.jemp" 


        #line 1 "src/grammarlib/none.inc"
        // separator "none" means 0 bytes of separator:
        return 0;

        #line 20350 "src/jemplpl/jemplpl.cc"


        #line 1343 "src/fpl2cc/fpl_x_parser.h.jemp" 

    }

    #line 1345 "src/fpl2cc/fpl_x_parser.h.jemp" 

    #line 1347 "src/fpl2cc/fpl_x_parser.h.jemp" 
    return 0;
}

size_t eat_separator() {
    bytes_eaten += reader->eat_separator(separator_length);
    return bytes_eaten;
}

// reduction rules:

#line 1357 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_0(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> fragments,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_0";
        }
        static const char *product() {
            return "complete";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 12;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:12";
        }
        static const char *to_str() {
            return "fragment+:fragments -> complete";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "fragments"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:12";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:12"
                );
            }
        }
    } this_rule;



    // fragment+:fragments -> complete

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 35 "src/jemplpl/jemplpl.fpl"

    std::string guts;

    fragments.foreach(
    [&guts] (const std::string &frag) { guts += frag; }
    );

    std::string function_name = output_function_name();

    #define _CLUDGE_TO_STR(x) #x
    #define _CLUDGE_STR(x) _CLUDGE_TO_STR(x)
    return stringformat(
    "#ifndef {}_H\n"
    "#define {}_H\n"
    "#line " _CLUDGE_STR(__LINE__) " \"" __FILE__ "\"\n\n"
    "#include <string>\n"
    "#include \"util/jerror.h\"\n"
    "#include \"util/stringformat.h\"\n"
    "#include \"util/utf8_buffer.h\"\n"
    "inline std::string {}({}) {{\n"
    "    struct _jemp_srcinfo {{\n"
    "        int ln;\n"
    "        std::string filename() const {{ return \"{}\"; }};\n"
    "        int line_number() const {{ return ln; }}\n"
    "    }} source;\n"
    "    source.ln = 1;\n"
    "    std::string out;\n"
    "    {}\n"
    "    return out;\n"
    "}\n"
    "#endif // {}_H\n",
    function_name,  // #ifndef .. 
    function_name,  // #define ..
    function_name, jempl.fmt_params(), // func decl
    filename(),           // source info
    guts,                 // the real stuff
    function_name   // #endif
    );


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 12 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_1(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> chunks,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_1";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 15;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:15";
        }
        static const char *to_str() {
            return "text+:chunks -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "chunks"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:15";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:15"
                );
            }
        }
    } this_rule;



    // text+:chunks -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 75 "src/jemplpl/jemplpl.fpl"

    std::string frag = "out += ";
    chunks.foreach(
    [&frag] (const std::string &chunk) { frag += quote(chunk) + "\n"; }
    );
    return frag + ";\n";


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 15 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_2(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> at_sign,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_2";
        }
        static const char *product() {
            return "text";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 20;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:20";
        }
        static const char *to_str() {
            return "'@@':at_sign -> text";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "at_sign"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:20";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:20"
                );
            }
        }
    } this_rule;



    // '@@':at_sign -> text

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 20 "src/grammarlib/jemp.fpl"
    return "@"; 

    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 20 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_3(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> comment,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_3";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 4;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 24;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:24";
        }
        static const char *to_str() {
            return "'@/*'^ /(\\\?:[^*]|(\\\?:\\\\*[^\\\\/])|(\\\?:\\\\*\\\\/[^@]))*/:comment '*/@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "comment"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:24";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:24"
                );
            }
        }
    } this_rule;



    // '@/*'^ /(\?:[^*]|(\?:\\*[^\\/])|(\?:\\*\\/[^@]))*/:comment '*/@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 84 "src/jemplpl/jemplpl.fpl"

    return line_num(comment.self()) + jempl.realign_frag();


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 24 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_4(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> param_decl,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_4";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 4;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 35;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:35";
        }
        static const char *to_str() {
            return "'@parameter:'^ /[^@]+/:param_decl '@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "param_decl"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:35";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:35"
                );
            }
        }
    } this_rule;



    // '@parameter:'^ /[^@]+/:param_decl '@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 88 "src/jemplpl/jemplpl.fpl"

    jempl.params.push_back(param_decl.val());
    return "";


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 35 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_5(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> include_file,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_5";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 5;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 40;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:40";
        }
        static const char *to_str() {
            return "'@include:'^ /\\\\s*/^ /[^@]+/:include_file '@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "include_file"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:40";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:40"
                );
            }
        }
    } this_rule;



    // '@include:'^ /\\s*/^ /[^@]+/:include_file '@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 94 "src/jemplpl/jemplpl.fpl"

    return jempl.realign_frag(include_file.val(), "1") + stringformat(
    "out += std::string((const char *)utf8_buffer({}).data());\n",
    include_file.val()
    ) + line_num(include_file.self()) + jempl.realign_frag();


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 40 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_6(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> embed_file,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_6";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 5;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 46;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:46";
        }
        static const char *to_str() {
            return "'@embed:'^ /\\\\s*/^ /[^@]+/:embed_file '@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "embed_file"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:46";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:46"
                );
            }
        }
    } this_rule;



    // '@embed:'^ /\\s*/^ /[^@]+/:embed_file '@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 108 "src/jemplpl/jemplpl.fpl"

    auto full_path = jempl.import_path.find(embed_file.val());

    utf8_buffer contents;
    contents.slurp_file(full_path, embed_file.position().to_str());

    return stringformat(
    "{} out += \"{::e}\";\n{}{}",
    jempl.realign_frag(quote(full_path), "1"),
    (const char *)contents.data(),
    line_num(embed_file.self()),
    jempl.realign_frag()
    );


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 46 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_7(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> leading_ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> name_decl,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> value,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_7";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 7;
        }
        static int num_params() {
            return 3;
        }
        static int line_number() {
            return 52;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:52";
        }
        static const char *to_str() {
            return "leading_ws\? /@declare\\\\s+/^ identifier:name_decl ':'^ /(\\\?:[^@]|(\\\?:@@))*/:value '@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "leading_ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "name_decl"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "value"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 3) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:52";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 3) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:52"
                );
            }
        }
    } this_rule;



    // leading_ws? /@declare\\s+/^ identifier:name_decl ':'^ /(\?:[^@]|(\?:@@))*/:value '@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 123 "src/jemplpl/jemplpl.fpl"

    return line_num(value.self())
    + stringformat("const auto {} = {};\n", name_decl.val(), value.val());


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 52 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_8(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> realign,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_8";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 4;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 65;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:65";
        }
        static const char *to_str() {
            return "/@realign:\\\\s*/^ text:realign '@'^ /\\\\n\\\?/^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "realign"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:65";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:65"
                );
            }
        }
    } this_rule;



    // /@realign:\\s*/^ text:realign '@'^ /\\n\?/^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 128 "src/jemplpl/jemplpl.fpl"

    jempl.realign_fragment = realign.val();

    return line_num(realign.self()) + jempl.realign_frag();


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 65 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_9(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> variant_expression,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_9";
        }
        static const char *product() {
            return "template_variant";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 3;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 70;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:70";
        }
        static const char *to_str() {
            return "'#'^ !'#':variant_expression '#'^ -> template_variant";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "variant_expression"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:70";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:70"
                );
            }
        }
    } this_rule;



    // '#'^ !'#':variant_expression '#'^ -> template_variant

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:70 (default action for '#'^ !'#':variant_expression '#'^ -> template_variant)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    variant_expression.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 70 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_10(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> arg_1,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_10";
        }
        static const char *product() {
            return "subst_start";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 2;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 72;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:72";
        }
        static const char *to_str() {
            return "leading_ws\?^ '@-':arg_1 -> subst_start";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "arg_1"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:72";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:72"
                );
            }
        }
    } this_rule;



    // leading_ws?^ '@-':arg_1 -> subst_start

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:72 (default action for leading_ws\?^ '@-':arg_1 -> subst_start)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    arg_1.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 72 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_11(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> arg_0,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_11";
        }
        static const char *product() {
            return "subst_start";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 73;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:73";
        }
        static const char *to_str() {
            return "'@':arg_0 -> subst_start";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "arg_0"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:73";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:73"
                );
            }
        }
    } this_rule;



    // '@':arg_0 -> subst_start

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:73 (default action for '@':arg_0 -> subst_start)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    arg_0.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 73 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_12(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> arg_0,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_12";
        }
        static const char *product() {
            return "subst_end";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 2;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 75;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:75";
        }
        static const char *to_str() {
            return "'-@':arg_0 trailing_ws\?^ -> subst_end";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "arg_0"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:75";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:75"
                );
            }
        }
    } this_rule;



    // '-@':arg_0 trailing_ws?^ -> subst_end

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:75 (default action for '-@':arg_0 trailing_ws\?^ -> subst_end)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    arg_0.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 75 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_13(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> arg_0,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_13";
        }
        static const char *product() {
            return "subst_end";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 76;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:76";
        }
        static const char *to_str() {
            return "'@':arg_0 -> subst_end";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "arg_0"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:76";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:76"
                );
            }
        }
    } this_rule;



    // '@':arg_0 -> subst_end

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:76 (default action for '@':arg_0 -> subst_end)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    arg_0.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 76 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_14(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> arg_0,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_14";
        }
        static const char *product() {
            return "rest_of_sub";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 77;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:77";
        }
        static const char *to_str() {
            return "/(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "arg_0"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:77";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:77"
                );
            }
        }
    } this_rule;



    // /(\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:77 (default action for /(\\\?:[^-@]|-[^@])+/:arg_0 -> rest_of_sub)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    arg_0.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 77 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_15(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_15";
        }
        static const char *product() {
            return "leading_ws";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 83;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:83";
        }
        static const char *to_str() {
            return "/\\\\n*[ \\\\t]+/:ws -> leading_ws";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:83";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:83"
                );
            }
        }
    } this_rule;



    // /\\n*[ \\t]+/:ws -> leading_ws

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:83 (default action for /\\\\n*[ \\\\t]+/:ws -> leading_ws)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ws.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 83 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_16(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_16";
        }
        static const char *product() {
            return "trailing_ws";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 97;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:97";
        }
        static const char *to_str() {
            return "/[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:97";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:97"
                );
            }
        }
    } this_rule;



    // /[ \\t]*\\n+[ \\t]+(\?!@)/:ws -> trailing_ws

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:97 (default action for /[ \\\\t]*\\\\n+[ \\\\t]+(\\\?!@)/:ws -> trailing_ws)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ws.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 97 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_17(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_17";
        }
        static const char *product() {
            return "trailing_ws";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 101;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:101";
        }
        static const char *to_str() {
            return "/[ \\\\t]*\\\\n/:ws -> trailing_ws";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:101";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:101"
                );
            }
        }
    } this_rule;



    // /[ \\t]*\\n/:ws -> trailing_ws

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:101 (default action for /[ \\\\t]*\\\\n/:ws -> trailing_ws)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    ws.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 101 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_18(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> jempl_args,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> jempl_name,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> variant,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_18";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 6;
        }
        static int num_params() {
            return 3;
        }
        static int line_number() {
            return 109;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:109";
        }
        static const char *to_str() {
            return "subst_start^ /#\\\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "jempl_args"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "jempl_name"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "variant"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 3) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:109";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 3) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:109"
                );
            }
        }
    } this_rule;



    // subst_start^ /#\\s*/^ identifier:jempl_name template_variant:variant rest_of_sub:jempl_args subst_end^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 139 "src/jemplpl/jemplpl.fpl"

    std::list<std::string> cases;
    std::string search_re = stringformat("{}.*\\.h\\.jemp$", jempl_name.val());
    for(auto templ : jempl.import_path.find_re(search_re)) {
        add_import(templ);

        cases.push_back(stringformat(
        "if(fruitbat == \"{}\") {{\n    out += {}{};\n}",
        function_name(templ), function_name(templ), jempl_args.val()
        ));
    }

    return stringformat(
    "{{\n"
    "    std::string fruitbat = stringformat(\"{}{}\", {});\n"
    "    {}\n"
    "}\n",
    jempl_name.val(),
    "{}",    // format for the variant.val() when expanding template
    variant.val(), // code for the variant.val()
    join(cases, " else ")
    );


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 109 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_19(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> jempl_args,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> jempl_name,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_19";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 5;
        }
        static int num_params() {
            return 2;
        }
        static int line_number() {
            return 112;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:112";
        }
        static const char *to_str() {
            return "subst_start^ /#\\\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "jempl_args"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "jempl_name"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 2) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:112";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 2) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:112"
                );
            }
        }
    } this_rule;



    // subst_start^ /#\\s*/^ identifier:jempl_name rest_of_sub:jempl_args subst_end^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 134 "src/jemplpl/jemplpl.fpl"

    add_import(jempl.import_path.find(jempl_name.val() + ".h.jemp"));
    return stringformat("\nout += {}{};\n", jempl_name.val(), jempl_args.val());


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 112 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_20(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> control_statement,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_20";
        }
        static const char *product() {
            return "control_start";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 3;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 124;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:124";
        }
        static const char *to_str() {
            return "subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ -> control_start";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "control_statement"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:124";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:124"
                );
            }
        }
    } this_rule;



    // subst_start^ /(\?:[^-{@]|-[^@]|)*\\{/:control_statement subst_end^ -> control_start

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:124 (default action for subst_start^ /(\\\?:[^-{@]|-[^@]|)*\\\\{/:control_statement subst_end^ -> control_start)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    control_statement.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 124 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_21(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> control_statement,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_21";
        }
        static const char *product() {
            return "control_end";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 3;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 125;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:125";
        }
        static const char *to_str() {
            return "subst_start^ '}':control_statement subst_end^ -> control_end";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "control_statement"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:125";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:125"
                );
            }
        }
    } this_rule;



    // subst_start^ '}':control_statement subst_end^ -> control_end

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:125 (default action for subst_start^ '}':control_statement subst_end^ -> control_end)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    control_statement.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 125 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_22(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> control_statement,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_22";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 127;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:127";
        }
        static const char *to_str() {
            return "control_start:control_statement -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "control_statement"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:127";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:127"
                );
            }
        }
    } this_rule;



    // control_start:control_statement -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 163 "src/jemplpl/jemplpl.fpl"

    return stringformat(
    "{}{}\n{}\n",
    line_num(control_statement.self()),
    jempl.realign_frag(),
    control_statement.val()
    );


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 127 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_23(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> control_statement,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_23";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 128;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:128";
        }
        static const char *to_str() {
            return "control_end:control_statement -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "control_statement"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:128";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:128"
                );
            }
        }
    } this_rule;



    // control_end:control_statement -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 163 "src/jemplpl/jemplpl.fpl"

    return stringformat(
    "{}{}\n{}\n",
    line_num(control_statement.self()),
    jempl.realign_frag(),
    control_statement.val()
    );


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 128 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_24(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> variable,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_24";
        }
        static const char *product() {
            return "fragment";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 3;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 133;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:133";
        }
        static const char *to_str() {
            return "subst_start^ /(\\\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "variable"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:133";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:133"
                );
            }
        }
    } this_rule;



    // subst_start^ /(\?:[^-@]|-[^@])+/:variable subst_end^ -> fragment

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 18 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 173 "src/jemplpl/jemplpl.fpl"

    return line_num(variable.self())
    + "out += stringformat(\"{}\"," + variable.val().to_str() + ");\n";


    #line 20 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 133 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_25(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> t,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_25";
        }
        static const char *product() {
            return "text";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 137;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:137";
        }
        static const char *to_str() {
            return "/[^@\\\\n]+/:t -> text";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "t"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:137";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:137"
                );
            }
        }
    } this_rule;



    // /[^@\\n]+/:t -> text

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:137 (default action for /[^@\\\\n]+/:t -> text)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    t.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 137 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_26(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> leading_ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_26";
        }
        static const char *product() {
            return "text";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 141;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:141";
        }
        static const char *to_str() {
            return "leading_ws -> text";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "leading_ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:141";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:141"
                );
            }
        }
    } this_rule;



    // leading_ws -> text

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:141 (default action for leading_ws -> text)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    leading_ws.val()

    #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 141 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_27(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> trailing_ws,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_27";
        }
        static const char *product() {
            return "text";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 142;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:142";
        }
        static const char *to_str() {
            return "trailing_ws -> text";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "trailing_ws"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:142";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:142"
                );
            }
        }
    } this_rule;



    // trailing_ws -> text

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:142 (default action for trailing_ws -> text)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    trailing_ws.val()

    #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 142 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_28(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<Terminal> name,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_28";
        }
        static const char *product() {
            return "identifier";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 145;
        }
        static const char *filename() {
            return "src/grammarlib/jemp.fpl";
        }
        static const char *location() {
            return "src/grammarlib/jemp.fpl:145";
        }
        static const char *to_str() {
            return "/[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "name"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/grammarlib/jemp.fpl:145";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                ""

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/grammarlib/jemp.fpl:145"
                );
            }
        }
    } this_rule;



    // /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/grammarlib/jemp.fpl:145 (default action for /[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 52 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    name.val().to_str()

    #line 54 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 145 "src/grammarlib/jemp.fpl"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1358 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 5 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

std::string rule_29(

#line 8 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
ReductionParameter<std::string> complete,

#line 11 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
bool dummy = true // hack for comma
) {

    #line 3 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 


    #line 5 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 

    struct {
        static const char *name() {
            return "rule_29";
        }
        static const char *product() {
            return "_fpl_goal";
        }
        static const char *product_type() {
            return "std::string";
        }
        static int num_steps() {
            return 1;
        }
        static int num_params() {
            return 1;
        }
        static int line_number() {
            return 4227;
        }
        static const char *filename() {
            return "src/fpl2cc/productions.h";
        }
        static const char *location() {
            return "src/fpl2cc/productions.h:4227";
        }
        static const char *to_str() {
            return "complete -> _fpl_goal";
        }
        static const char *param_name(unsigned int ind) {
            static const char *pname[] = {

                #line 40 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "complete"

                #line 42 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return pname[ind];
            } else {
                return "param_name index out of bounds at "
                "src/fpl2cc/productions.h:4227";
            }
        }
        static const char *param_type(unsigned int ind) {
            static const char *ptype[] = {

                #line 53 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
                "std::string"

                #line 55 "src/fpl2cc/fpl_x_parser_reduce_action_meta.h.jemp" 
            };
            if(ind < 1) {
                return ptype[ind];
            } else {
                return (
                "param_type index out of bounds at "
                "src/fpl2cc/productions.h:4227"
                );
            }
        }
    } this_rule;



    // complete -> _fpl_goal

    #line 17 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 


    #line 34 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 1 "src/fpl2cc/productions.h:4227 (default action for complete -> _fpl_goal)"
    // src/fpl2cc/fpl_x_parser_reduce_action.h.jemp:36
    return std::string(

    #line 38 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 41 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 48 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 49 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    complete.val()

    #line 51 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 55 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 56 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    );

    #line 58 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 

    #line 59 "src/fpl2cc/fpl_x_parser_reduce_action.h.jemp" 
    #line 4227 "src/fpl2cc/productions.h"
}



#line 1362 "src/fpl2cc/fpl_x_parser.h.jemp" 


#line 1363 "src/fpl2cc/fpl_x_parser.h.jemp" 



};

#endif // header guard


#line 1370 "src/fpl2cc/fpl_x_parser.h.jemp" 

int main(int argc, const char **argv) {

#line 276 "src/jemplpl/jemplpl.fpl"

if(argc < 2) {
    jerror::error("Please provide a source file name.\n");
}

std::list<std::filesystem::path> templates_to_expand;
for(int argi = 1; argi < argc; argi++) {
    templates_to_expand.push_back(argv[1]);
}

std::list<std::string> generated_code;
std::set<std::filesystem::path> already_expanded;
int total_errors = 0;
for(auto template_fn : templates_to_expand) {
    if(already_expanded.count(template_fn)) {
        continue;
    }
    already_expanded.insert(template_fn);
    fpl_reader_p inp = std::make_shared<fpl_reader>(template_fn);
    if(!inp) {
        jerror::warning(stringformat(
        "failed to create reader for {}",
        std::filesystem::absolute(template_fn).string()
        ));
        total_errors++;
    } else {
        jemplpl_parser parser(inp);
        parser.init(template_fn);
        std::string output = parser.parse();
        if(!output.length()) {
            jerror::warning(stringformat(
            "no output generated for '{}'\n", template_fn
            ));
            total_errors++;
        } else {
            // prepend the generated code so that function definitions
            // from imported jemps come before where they are used:
            generated_code.push_front(output);
            std::cout << parser.output_header(argv[0], template_fn);

            // now, if that imported anything, we'll want to try
            // to pull in the import...
            for(auto imp: parser.jempl.import_files) {
                templates_to_expand.push_back(imp);
            }
        }
        total_errors += parser.error_count();
    }
}

std::cout << reformat_code(join(generated_code, "\n\n"));

return total_errors?1:0;

#line 24109 "src/jemplpl/jemplpl.cc"

}

#line 1376 "src/fpl2cc/fpl_x_parser.h.jemp" 



#if GENERATED_FPL > 1
#define GENERATED_FPL (GENERATED_FPL - 1)
#else
#undef GENERATED_FPL
#endif



