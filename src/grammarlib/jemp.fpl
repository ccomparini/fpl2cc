#
# jemp - templates with enough rope to shoot yourself in the foot
#

# huh interesting reading:
#   https://jinja.palletsprojects.com/en/3.0.x/templates/

@separator none

# a complete template is composed of "fragments".  Each
# fragment is the "digest" of a section of the template.
fragment+:fragments -> complete ;

# arbitrary text is a fragment:
text -> fragment ;

# @ signs indicate some kind of substitution or other jemp
# directive.  If you want a plain @ in the expansion of your
# template, you escape that @ by doubling it:
'@@':at_sign -> text +{ return "@"; }+

# @/*  xxx  */@ is a comment.  default is simply to remove
# the comment contents (and trailing newline, if any)
'@/*'^ /(?:[^*]|(?:\*[^\/])|(?:\*\/[^@]))*/:comment '*/@'^ /\n?/^ -> fragment +{
    return "";
}+

# Declares a parameter for the template.
# syntax:
#   '@parameter' <language specific param decl> '@' '\n'
# Note that it must be on its own line.
# This is necessary because many languages need to know
# the type and/or name of each parameter in order to define
# a function or whatever we're generating.
'@parameter:'^ /[^@]+/:param_decl '@'^ /\n?/^ -> fragment ;

# declares a constant which can be used in later expansions
# or expressions. For example, to set "fruitbat" to 10 more
# than the current value of x, you might do:
#   @declare fruitbat: x + 10@
'@declare'^ sp^ identifier:name_decl ':'^ /(?:[^@]|(?:@@))*/:value '@'^ /\n?/^ -> fragment ;

leading_ws?^ '@-' -> subst_start +{ return "@-"; }+ # shouldn't be necessary - fix when fpl bug is fixed
'@'               -> subst_start ;

'-@' trailing_ws?^ -> subst_end +{ return "-@"; }+ # again shouldn't be necessary
'@'                -> subst_end ;

# template authors may wish to elide leading or trailing space,
# so we need to be able to identify leading/trailing space:
# \n is optional on leading_ws because it may have been eaten
# by an earlier trailing_ws
/\n?[ \t]+/:ws -> leading_ws  ;

# there are 2 variants on trailing whitespace.
# the first matches all space through the end of
# line and beyond, as long as the first non-whitespace
# on the next line _isn't_ a '@'. The reasoning
# here is that if it -does- start with an @, the
# author can strip the whitespace to the left
# by using '@-', but if it's regular text, there's
# no way for the author to trip leading whitespace
# (without doing a hack like putting in a dummy
# expansion).  If the author wants to indent the
# text within a multiline expansion, they can indent
# the beginning tag.
/[ \t]*\n[ \t]+(?!@)/:ws  -> trailing_ws ;

# ... and this is the "normal" trailing whitespace
# case..
/[ \t]*\n/:ws  -> trailing_ws ;

# Control statements (loops and if/else) are identified
# by ending with an opening or closing curly brace.
# This means you must always use curly braces on control
# statements. eg:
# @if(something) {@
#   something is true 
# @} else {@
#   something is false 
# @}@
subst_start^ /(?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment ;

# substitute a variable into the output
subst_start^ /(?:[^-@]|-[^@])+/:variable subst_end^ -> fragment ;

# plain text ends at an @ or a \n so that we can do substitutions
# and/or games with leading/trailing whitespace
/[^@\n]+/:t -> text ;

# if nothing above wanted to do anything with leading/trailing
# space, then it's just text:
leading_ws  -> text ;
trailing_ws -> text ;

# (identifiers might be used within @declare or whatever)
/[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier ;

# \t and regular space (0x20) might be used for readability
/[ \t]+/:space -> sp ;


