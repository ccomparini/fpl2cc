#
# jemp - templates with enough rope to shoot yourself in the foot
#

# huh interesting reading:
#   https://jinja.palletsprojects.com/en/3.0.x/templates/

@separator none
# XXX idea:  @+ starts an indented expansion where
# everything to the left of the @+ on the same line
# gets substituted in for newlins in the expansion.
# that way you can keep indent or do line comments 
# or whatever.  or maybe '@>'?
# 

# a complete template is composed of "fragments".  Each
# fragment is the "digest" of a section of the template.
fragment+:fragments -> complete ;

# arbitrary text is concatenated to a fragment:
text+:chunks -> fragment ;

# @ signs indicate some kind of substitution or other jemp
# directive.  If you want a plain @ in the expansion of your
# template, you escape that @ by doubling it:
'@@':at_sign -> text +{ return "@"; }+

# @/*  xxx  */@ is a comment.  default is simply to remove
# the comment contents (and trailing newline, if any)
'@/*'^ /(?:[^*]|(?:\*[^\/])|(?:\*\/[^@]))*/:comment '*/@'^ /\n?/^ -> fragment +{
    return "";
}+

# Declares a parameter for the template.
# syntax:
#   '@parameter' <language specific param decl> '@' '\n'
# Note that it must be on its own line.
# This is necessary because many languages need to know
# the type and/or name of each parameter in order to define
# a function or whatever we're generating.
'@parameter:'^ /[^@]+/:param_decl '@'^ /\n?/^ -> fragment ;

# declares a constant which can be used in later expansions
# or expressions. For example, to set "fruitbat" to 10 more
# than the current value of x, you might do:
#   @declare fruitbat: x + 10@
'@declare'^ /\s*/^ identifier:name_decl ':'^ /(?:[^@]|(?:@@))*/:value '@'^ /\n?/^ -> fragment ;

# Tells the jemp processor to use the given text as the format
# string in a call to stringformat() whenever it appears that
# the source line number might not align with the destination.
# Format parameters:
#    {0}: the line number
#    {1}: the name of the source file
# 
# So for example, if you're generating c/c++ code, you might do:
#   @realign:  #line {0} "{1}" @
# .. so that errors or whatever will be reported in the .jemp source
# instead of in the generated location(s).
'@realign:'^ /\s*/^ text:realign '@'^ /\n?/^ -> fragment ;

leading_ws?^ '@-' -> subst_start ;
'@'               -> subst_start ;

'-@' trailing_ws?^ -> subst_end ;
'@'                -> subst_end ;

# template authors may wish to elide leading or trailing space,
# so we need to be able to identify leading/trailing space:
# \n is optional on leading_ws because it may have been eaten
# by an earlier trailing_ws
/\n?[ \t]+/:ws -> leading_ws  ;

# there are 2 variants on trailing whitespace.
# the first matches all space through the end of
# line and beyond, as long as the first non-whitespace
# on the next line _isn't_ a '@'. The reasoning
# here is that if it -does- start with an @, the
# author can strip the whitespace to the left
# by using '@-', but if it's regular text, there's
# no way for the author to trip leading whitespace
# (without doing a hack like putting in a dummy
# expansion).  If the author wants to indent the
# text within a multiline expansion, they can indent
# the beginning tag.
/[ \t]*\n[ \t]+(?!@)/:ws  -> trailing_ws ;

# ... and this is the "normal" trailing whitespace
# case..
/[ \t]*\n/:ws  -> trailing_ws ;

# you can call another template with the "@#other_template(x, y ,z)@...
subst_start^ /#\s*/^ identifier:jempl_name /(?:[^-@]|-[^@])+/:jempl_args subst_end^ -> fragment ;

# Control statements (loops and if/else) are identified
# by ending with an opening or closing curly brace.
# This means you must always use curly braces on control
# statements. eg:
# @if(something) {@
#   something is true 
# @} else {@
#   something is false 
# @}@
# (note: the above is 3 "control statements" - if, else, and the closing })
# we -don't- eject the subst_end so that we can use its
# location to realign line numbers. (though hmm can
# we just have the end of match somehow?)
subst_start^ /(?:[^-{}@]|-[^@]|[{}][^-@])*[{}]/:control_statement subst_end^ -> fragment ;

# substitute a variable into the output
subst_start^ /(?:[^-@]|-[^@])+/:variable subst_end^ -> fragment ;

# plain text ends at an @ or a \n so that we can do substitutions
# and/or games with leading/trailing whitespace
/[^@\n]+/:t -> text ;

# if nothing above wanted to do anything with leading/trailing
# space, then it's just text:
leading_ws  -> text ;
trailing_ws -> text ;

# (identifiers might be used within @declare or whatever)
/[a-zA-Z_][a-zA-Z_0-9]+/:name -> identifier ;

# \t and regular space (0x20) might be used for readability
/[ \t]+/:space -> sp ;


