#
# "pure" fpl json spec.
#

element -> json ;

object   -> value ;
array    -> value ;
string   -> value ;
number   -> value ;

"null":null_val   -> value ;

"true":true_val   -> boolean ;
"false":false_val -> boolean ;
boolean           -> value ;

'{'^ (member (','^ member)*)?:members '}'^ -> object ;
string:key ':'^ value -> member ;

'['^ (value (','^ value)*)?:elements ']'^ -> array ;

value -> element ;

/"((?:[^"\\]|\\.)*)"/:src -> string ;

# json number specification appears to actually be fairly fussy.
# From the spec, I'm inferring that:
#  - leading 0 is disallowed unless followed by a decimal point
#    or the number is 0
#  - you can't have a leading '+' except when specifying exponent
#
# instead of being fussy like that, let's make this more accepting,
# and maybe add warnings if we need to.

# (2 expressions for floats is a way to make it so that just a
# decimal point doesn't match as a float)
/(-)?[0-9]+\.[0-9]*([eE][+-]?[0-9]+)?/:float_val -> number ;
/(-)?\.[0-9]+([eE][+-]?[0-9]+)?/:float_val       -> number ;

# this will match something like "02", which is not strictly
# legal json, but whatever:
/(-)?([0-9]+)/:integer                           -> number ;

@separator +{
    /*
      from crockford, whitespace is:
        '0020' ws
        '000A' ws
        '000D' ws
        '0009' ws
      .. so it's a more limited set than default fpl handles.
      btw our input is utf8 and all of those chars are in the ascii
      range, so going 8 bits at a time works:

      This should be part of the grammarlib.
    */
    size_t len = 0;
    while(is_json_space(*inp)) {
        inp++;
        len++;
    }

    return len;
}+


