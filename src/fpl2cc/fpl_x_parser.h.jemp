@parameter: const productions &prds @
@parameter: const options &opts @

#ifndef @ prds.parser_class_name() @_H
#define @ prds.parser_class_name() @_H

/*
  generated by fpl2cc

  options:
    @opts.to_str()@

  calculated goal(s):
    @prds.goal@
 */

@for(auto fn : opts.impl_sources) {@
    @code_block::from_file(fn, opts.src_path, "(command line)", 1).format()@
@}@

#include <string>
#include "fpl2cc/fpl_reader.h"
#include "fpl2cc/fpl_base_parser.h"

@if(prds.preamble.size()) {@
    @for(auto pre : prds.preamble) {@
        @pre.format()@
    @}@
@}@

class @ prds.parser_class_name() @ {

public:
    // state() and reduce_type tell FPLBaseParser what types to use
    void state();
    int error_count() { return base_parser.error_count(); }
    static @prds.reduce_type@ reduce_type;

private:
    using FPLBP = FPLBaseParser<@ prds.parser_class_name() @>;
    using State = FPLBP::State;
    using Product = FPLBP::Product;
    using StackEntry = FPLBP::StackEntry;
    FPLBP base_parser;

    @for(auto mem : prds.parser_members) {@
        @mem.format()@
        // return to "private" after each such block.
        // this way, authors can add public members
        // to the parser without turning other stuff public 
        private:
    @}@

    inline bool shift_TERM_EXACT(
        const std::string &match, int el_id, int min, int max, State new_st
    ) {
        return base_parser.shift_exact(match, el_id, min, max, new_st);
    }

    inline bool shift_TERM_REGEX(
        const std::string &re, int el_id, int min, int max, State new_st
    ) {
        return base_parser.shift_re(re, el_id, min, max, new_st);
    }

    inline bool shift_NONTERM_PRODUCTION(
        const std::string &, int el_id, int min, int max, State new_st
    ) {
        return base_parser.shift_nonterm(el_id, min, max, new_st);
    }

    inline bool shift_LACK_OF_SEPARATOR(
        const std::string &, int el_id, int min, int max, State new_st
    ) {
        // eat_separator is an indirect way to check base_parser.bytes_eaten.
        // right answer is to move bytes_eaten here.
        if(!eat_separator()) {
            FPLBP::Terminal term("<special ~>");
            base_parser.lr_push(new_st, FPLBP::Product(term, el_id, base_parser.position()));
            return true;
        }
        return false;
    }

public:
    @ fpl_x_parser_nonterm_enum(prds) @
    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh
        @for(auto st: prds.states) {-@
            if(&@prds.state_fn(st, true)@ == st) return "@prds.state_fn(st)@";
        @}@
        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    static const char *state_string(State st) {
        @for(auto st: prds.states) {-@
            if(&@prds.state_fn(st, true)@ == st) {
                return "@prds.state_fn(st, false)@:\n"
                       @st.to_str(&prds, "\"    ", "\\n\"\n", true)@;
            }
        @}@
        return "<invalid state>";
    }

    static bool is_goal(int id) {
        switch(id) {
            @for(auto gstr : prds.goal) {-@
                case NontermID::_@gstr@: return true;
            @}@
            default: return false;
        }
        return false;
    }

    static size_t separator_length(const utf8_byte *inp) {
        @if(prds.separator_code.size() == 0) {-@
            @/* set the default somewhere else XXX */@
            return space_length(inp);
        @}-@

        @for(auto sepc : prds.separator_code) {-@
            @sepc.format_scoped()@
        @}-@

        @/* catchall: if nothing returned a length yet, no separator */@
        return 0;
    }

    size_t eat_separator() {
        return base_parser.eat_separator(separator_length);
    }

    // reduction rules:
    @for(auto rule : prds.rules) {@
        @if(code_block rule_code = rule.reduce_code()) {-@
            @fpl_x_parser_reduce_action(prds, rule)@
        @}-@
    @}@

// OH HAI
    // parser states:
    @for(productions::lr_set state : prds.states) {@
        @fpl_x_parser_state(prds, state, prds.opts)@
    @}@

    @prds.parser_class_name()@(fpl_reader_p src) : base_parser(src) {
        @if(opts.single_step) {@
            base_parser.set_single_step(true);
        @}@
    }

    std::string to_str() { return base_parser.to_str(); }
    inline @prds.reduce_type@ parse() {
        auto result = base_parser.parse(*this);

        @if(prds.post_parse) {@
            @prds.post_parse.format()@
        @}@

        return result;
    };
};

@if(opts.generate_main || prds.default_main) {@
    @prds.default_main_code()@
@} else if(prds.main_guts) {@
    int main(int argc, const char **argv) {
        @prds.main_guts.format()@
    }
@}@

#endif // header guard
