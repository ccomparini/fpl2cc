@parameter: const productions &prds @
@parameter: const fpl_options &opts @
@declare class_name: prds.parser_class_name()@
@realign: #line {} "{}" @

#ifndef @class_name@_H
#define @class_name@_H

/*
  generated by fpl2cc @opts.version()@ from @source.filename()@

  options:
    @opts.to_str()@

  calculated goal(s):
    @prds.goals@
 */

@for(auto fn : opts.impl_sources) {@
    @code_block::from_file(fn, opts.src_path, "(command line)", 1).format()@
@}@

#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <type_traits>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>

#include "fpl2cc/fpl_reader.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"

@if(prds.preamble.size()) {@
    @for(auto pre : prds.preamble) {@
        @pre.format()@
    @}@
@}@

class @class_name@ {

    // If some poor hapless fpl author should happen to try
    // to use a non-copy-constructable type in some way that
    // it lands in the variant (below), they will be rewarded
    // by their c++ compiler with about 23k lines of "note:"
    // gibberish about every possible constructor in the
    // standard libraries.  To avoid this, and to give a non-0
    // chance at a useful error message, we do this lame hack
    // of creating a static function whose only reason for
    // existence is to give a scope to static_asserts:
    static void check_copy() {
        @-for(auto tp : prds.all_types) {@
            {
                // (having a separate "copyable" bool makes the
                // static_assert not expand templates into the
                // message)
                const bool copyable = std::is_copy_constructible<@tp@>::value;
                static_assert(copyable, "@tp@ is not copy constructable");
            }
        @}@
    }

public:
    void state(); // this just facilitates the "using State"
    using State = decltype(&@class_name@::state);

    class Terminal {
        // the first string in "matches" is the entire terminal match
        // and will exist for exact matches as well as regex matches.
        // subsequent matches are used for capture groups in a regex
        // match.
        std::vector<std::string> matches;
    public:

        Terminal() { } // false valued terminal

        Terminal(const std::string &src, const std::string &caller = CALLER()) {
            matches.push_back(src);
        }

        template<typename Iter>
        Terminal(Iter begin, Iter end) : matches(begin, end) {
        }

        std::string to_str() const {
            if(matches.size())
                return matches[0];
            return "";
        }

        // returns a string containing the contents of the regex capture
        // group indicated by the index passed.
        // for example, if the regex /(.)y(.*)/ matched the string "dyad",
        // capgroup(0) would be "d" and capgroup(1) would be "ad".
        // default is the 0th capgroup.
        // returns the empty string for any non-existent capture groups.
        std::string capgroup(int capi = 0) const {
            if(capi + 1 < matches.size()) {
                return matches[capi + 1];
            }
            return "";
        }

        int num_capgroups() const {
            return matches.size() - 1;
        }

        operator bool() const {
            return matches.size() > 0;
        }

        operator std::string() const { return to_str(); }

        std::string operator+(const std::string & rhs) const {
            return to_str() + rhs;
        }
    };

    class Product {
        struct false_product { };

        // this is the "product" we make everything produce for
        // the --check-only option.  It can be constructed from
        // anything, so that it can drop into any arbitrary rule.
        struct check_only {
            operator bool() const { return true; }
            std::string to_str() const {
                return "«dummy»";
            }

            // (construct from any set of arguments)
            template <typename... Args>
            check_only(Args&&... args) { }
        };

        using Var = std::variant<
            // consider adding std::monostate here
            false_product,
            @-for(auto type : prds.all_types) {-@
                @type@,
            @-}-@
            Terminal
        >;

        Var red;

    public:
        // creates a false-valued Product:
        Product() : red(false_product()) { }

        Product(Terminal tm) : red(tm) { }

        // type-specific constructors:
        @-for(auto type : prds.all_types) {-@
            Product(@type@ result) : red(result) { }
        @-}-@

        const Var &var() const { return red; }

        // Accessors for the different types are named as [element name]_val()
        // We start at element 1 instead of 0 because we don't need/want an
        // fpl_null accessor (it has no type anyway)
        @for(int el_id = 1; el_id < prds.elements.size(); ++el_id) {-@
            @declare el: prds.elements[el_id]@
            @declare type: prds.type_for(el)@
            @declare el_name: prds.element_id_name(el_id)@
            @type@ @el_name@_val() const { return std::get<@type@>(var()); }
        @-}-@

        operator bool() const {
            return !std::holds_alternative<false_product>(red);
        }

        std::string type_name() const {
            if(std::holds_alternative<false_product>(red))
                return "<no type>";

            if(std::holds_alternative<Terminal>(red))
                return "Terminal";

            @-for(auto type : prds.all_types) {-@
                if(std::holds_alternative<@type@>(red))
                    return "@type@";
            @-}-@
            // can't get here?
            jerror::error("Unknown type for product");
            return "unknown type";
        }

        std::string var_str() const {
            if(std::holds_alternative<false_product>(red))
                return "<null product>";

            if(std::holds_alternative<Terminal>(var()))
                return stringformat("{}", std::get<Terminal>(var()));

            @-for(auto type : prds.all_types) {-@
                if(std::holds_alternative<@type@>(var())) {
                    // using stringformat here because it supports
                    // several ways of converting to string:
                    return stringformat("{}", std::get<@type@>(var()));
                }
            @-}@

            jerror::error("Unknown type for product");
            return "unknown type";
        }

        // this is for debug and similar:
        std::string to_str() const {
            std::string out;
            return stringformat("{} «{}»", type_name(), var_str());
        }

        // phase out if possible, because this only supports the
        // top output_type() and that's wacky.
        @prds.output_type()@ val(const std::string &caller = CALLER()) const {
            if(!std::holds_alternative<@prds.output_type()@>(red)) {
                @prds.output_type()@ dummy;
                return dummy;
            }
            return std::get<@prds.output_type()@>(red);
        }

        std::string capgroup(int capi) const {
            if(std::holds_alternative<Terminal>(red))
                return std::get<Terminal>(red).capgroup(capi);
            return "";
        }
    };

    // This is an lr stack entry (as opposed to a param stack entry).
    // In the new dual stack scheme, you would use one of these to
    // refer to the param stack, however.
    struct StackEntry {
        State          state;
        int            element_id;
        SourcePosition pos;        // start of match in source code
        int            param_ind;  // offset in param_stack
        bool           eject;
        bool           mismatch;

        StackEntry(State st, int el_id, SourcePosition p, int pind, bool ej) :
            state(st),
            element_id(el_id),
            pos(p),
            param_ind(pind),
            eject(ej),
            mismatch(false) {
        }

        // creates a "false" stack entry:
        StackEntry() :
            state(NULL),
            element_id(-1),
            param_ind(-1),
            eject(true),
            mismatch(false) {
        }

        StackEntry(const StackEntry &) = default;

        operator bool() const {
            return element_id > 0; // note null element id makes this false.. hmm
        }

        int grammar_element_id() const {
            return element_id;
        }

        bool ejected() const {
            return eject;
        }

        SourcePosition position() const {
            return pos;
        }

        int line_number() const {
            return position().line_number();
        }

        std::string filename() const {
            return position().filename();
        }

        bool is_nonterminal() const {
            return @class_name@::is_nonterminal(element_id);
        }

        // Returns the first Product corresponding to this
        // StackEntry, if there is one.  Otherwise, returns
        // a false Product.
        Product product(const @class_name@ &owner) const {
            if(param_ind >= 0 && param_ind < owner.param_stack.size()) {
                return owner.param_stack[param_ind];
            }
            return Product();
        }

        std::string to_str() const {
            return stringformat("{}{} {} param[{}] ({})",
                mismatch?"xxx ":"",
                state_to_str(state),
                element_str(element_id),
                param_ind,  // need the owner to get the product
                position()
            );
        }
    };

    // Pushes an element to the lr and/or parameter stacks as appropriate.
    // "ejected" elements (those marked with a '^' in fpl source) are
    // not pushed to the param stack.  Redundant lr_stack entries may or
    // may not actually be pushed.  (in the current implementation, they
    // are pushed, but that might not pertain in the future)
    void lr_push(
        int element_id, bool eject, const SourcePosition &pos, Product pr
    ) {
        lr_stack.push_back(StackEntry(
            cur_state, element_id, pos, param_stack.size(), eject
        ));

        if(!eject) {
            param_stack.push_back(pr);
        }
    }

private:
    fpl_reader_p            reader;      // (must be non-null)
    State                   cur_state;
    std::vector<StackEntry> lr_stack;
    int                     lr_read_pos;
    std::vector<Product>    param_stack;
    size_t                  bytes_eaten; // since last terminal
    bool                    stop_parsing;
    int                     max_errors;
    int                     num_errors;

    bool                    single_step; // debugging

    // this is called when something appears to have
    // gone wrong due to a bug in the parser itself:
    void internal_error(const std::string &msg) {
        error(stringformat(
            "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
        ));
        terminate();
    }

public:
    // constructors:
    @class_name@(const @class_name@ &rhs) = delete;

    @class_name@(fpl_reader_p rdr) :
        reader(rdr),
        cur_state(&@class_name@::state_0),
        lr_read_pos(0),
        bytes_eaten(0),
        stop_parsing(false),
        max_errors(1),
        num_errors(0),
        single_step(false) {

        @if(opts.single_step) {@
            set_single_step(true);
        @}@

        lr_stack.reserve(@opts.lr_stack_reserve@);
        param_stack.reserve(@opts.param_stack_reserve@);
    }

    // debugging:
    void set_single_step(bool newval) { single_step = newval; }
    void debug_pause() {
        int inch;
        if(single_step)
            inch = getchar();
        if(inch == 'c')
            single_step = false;
    }

    void set_max_errors(int newmax) { max_errors = newmax; }

    void error(size_t pos, const std::string &msg) {
        std::string full_msg = reader->format_error_message(pos, msg);
        fputs(full_msg.c_str(), stderr);
        if(++num_errors >= max_errors) {
            fputs("too many errors.  aborting\n", stderr);
            terminate();
        }
    }

    void error(const std::string &msg) {
        error(reader->current_position(), msg);
    }

    int error_count() const { return num_errors; }

    bool eof() const {
        return reader->eof();
    }

public:

    std::string filename() const {
        return reader->filename();
    }

    int line_number() const {
        return reader->line_number();
    }

    int line_number(size_t pos) const {
        return reader->line_number(pos);
    }

    SourcePosition position() const {
        return SourcePosition(reader);
    }

    fpl_reader_p_c const_reader() const {
        return reader;
    }

    int param_stack_size() const {
        return param_stack.size();
    }

    int lr_stack_size() const {
        return lr_stack.size();
    }

    int lr_top_index() const {
        return lr_stack.size() - 1;
    }

    void lr_pop() {
        if(lr_stack.size() > 0) {
            auto popped = lr_stack.back();
            cur_state = popped.state;
            if(popped.param_ind >= 0) {
                param_stack.resize(popped.param_ind);
            }
            lr_stack.pop_back();
        }

        if(lr_stack.size() == 0) {
            // else there's nothing left to pop on the lr_stack,
            // and the param stack had better be clear, too, or
            // something is wrong:
            if(param_stack.size() > 0) {
                jerror::warning(stringformat(
                    "popping from empty lr_stack, but there are {} params\n",
                    param_stack.size()
                ));
            }
        }
    }

    // "pops" and discards down to the new maximum index
    // specified
    void lr_pop_to(int new_max) {
        while(lr_top_index() > new_max) {
            lr_pop();
        }
    }

    void clear_mismatches() {
        int num_cleared = 0;
        while(lr_top().mismatch) {
            lr_pop();
            num_cleared++;
        }

        if(lr_read_pos > lr_top_index()) {
            lr_read_pos -= num_cleared;
        }
    }

    StackEntry lr_stack_entry(int pos) const {
        // (as usual, negative positions are relative to the top of stack)
        if(pos < 0) pos += lr_stack_size();

        if((pos >= 0) && (pos < lr_stack_size())) {
            return lr_stack[pos];
        } else {
            return StackEntry();
        }
    }

    StackEntry lr_next() const {
        return lr_stack_entry(lr_read_pos);
    }

    StackEntry lr_prev() const {
        return lr_stack_entry(lr_read_pos - 1);
    }

    StackEntry lr_top() const {
        return lr_stack_entry(lr_top_index());
    }

    // Increments the lr read pointer and returns true if the element ID
    // passed matches the next item to read from the lr stack.  Otherwise,
    // returns false.
    bool lr_read(int element_id) {
        if(element_id == lr_next().element_id) {
            // we may be skipping a known mismatch, in which case
            // we'll return false since it's not a correct match.
            bool mismatch = lr_next().mismatch;
            if(mismatch) {
                @if(opts.debug) {@
                    std::cerr << stringformat(
                        "skipping mismatch el {} at lr pos {} (state {})\n",
                        element_id, lr_read_pos, state_to_str(cur_state)
                    );
                @}@
            }

            lr_read_pos++;
            return !mismatch;
        }
        return false;
    }

    // lr_position_before_xxx(pos, multiple):  Each returns the
    // first position before pos in the lr stack which does not
    // match the element ID in question. If pos is past the top
    // of the stack, starts at the top of the stack.
    // Recurses on subexpressions.  Always skips mismatches.
    //
    // These are used to put together the arguments for reduce
    // actions.
    @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
        @declare element: prds.elements.at(el_id)@
        @declare elname: prds.element_id_name(el_id)@
        @declare subrule_num:  prds.subrulenum_for_el(element)@
        int lr_position_before_@elname@(int pos, bool multiple) const {

            if(pos > lr_top_index())
                pos = lr_top_index();

            @if(subrule_num < 0) {@
                // normal case - not a subexpression
                // XXX whhhy does the NULL element match el ID 6?
                // (checking pos >= 0 because of that.  in theory,
                //  shouldn't have to check)
                while(pos >= 0 && lr_stack_entry(pos).element_id == @el_id@) {
                    --pos;
                    if(!multiple)
                        break;
                }
            @} else {@
                @declare subrule: prds.rules[subrule_num]@
                //   @subrule.to_str()@
                int subp = pos;
                int lastp;
                bool matched_whole = true;
                while(subp >= 0) {
                    @for(int sti = subrule.num_steps() - 1; sti >= 0; --sti) {@
                        @declare substep: subrule.nth_step(sti)@
                        @declare sename: prds.element_id_name(substep.gexpr)@
                        @declare mult: substep.qty.multiple@
                        @declare required: !substep.qty.optional@
                        lastp = subp;
                        subp = lr_position_before_@sename@(subp, @-mult-@);
                        if(lastp == subp) {
                            // (didn't match)
                            if(@required@) matched_whole = false;
                        } else {
                            pos = subp;
                        }
                    @}@
                    if(!multiple || !matched_whole)
                        break;
                }
            @}@

            return pos;
        }
    @}@

    // lr_count_of_X(pos, multiple):  returns the number of
    // stack entries matching X going forward through the lr stack,
    // starting at the position passed.   If argument "multiple"
    // is false, only counts up to one entry.
    @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
        @declare element: prds.elements.at(el_id)@
        @declare elname: prds.element_id_name(el_id)@
        @declare subrule_num:  prds.subrulenum_for_el(element)@
        int lr_count_of_@elname@(int pos, bool multiple) const {
            int size = 0;
            @if(subrule_num < 0) {@
                // normal case - not a subexpression
                while(lr_stack_entry(pos + size).element_id == @el_id@) {
                    ++size;
                    if(!multiple)
                        break;
                }
            @} else {@
                @declare subrule: prds.rules[subrule_num]@
                //   @subrule.to_str()@
                int subp = pos;
                bool matched_whole = true;
                while(subp < lr_stack_size()) {
                    int ssize = 0; // size of substep
                    int msize = 0; // size of subexpression match
                    @for(int sti = 0; sti < subrule.num_steps(); ++sti) {@
                        @declare substep: subrule.nth_step(sti)@
                        @declare sename: prds.element_id_name(substep.gexpr)@
                        @declare mult: substep.qty.multiple@

                        ssize = lr_count_of_@sename@(subp, @mult@);

                        if(@!substep.qty.optional@ && ssize == 0)
                            matched_whole = false;

                        subp  += ssize;
                        msize += ssize;
                    @}@

                    if(matched_whole) {
                        size += msize;
                    } else {
                        break;
                    }

                    if(!multiple) {
                        break;
                    }
                }
            @}@

            return size;
        }
    @}@

    // A StackSlice here is a set of 0 or more consecutive lr_stack
    // entries. It's used to represent the match(es) which went into
    // 1 particular step (see ReductionParameter, below), or the set
    // of all steps which led to a current rule match (see
    // all_matched_steps(), below), or any other slice of the lr_stack.
    class StackSlice {
        int base_index; // in lr_stack
        int size;       // also in lr_stack

        // owner here is annoying because we should be able to
        // infer it... jest feature?
        const @class_name@ &owner;

    public:
        // returns the number of lr_stack entries in this slice:
        int count() const { return size; }

        // returns the number of parameter stack entries for this
        // entire slice.
        int param_count() const {
            StackEntry sel = owner.lr_stack_entry(base_index);

            // ejected -> 0 params
            if(sel.ejected()) return 0;

            // this slice "contains" all arguments starting
            // at the position in the argument stack starting
            // at the argument from the base element and going
            // to just before the one for the base element of
            // the slice above us, or the top of the argument
            // stack if we're the topmost slice
            int cap_ind = base_index + size;
            if(cap_ind < owner.lr_stack_size()) {
                StackEntry eel = owner.lr_stack_entry(cap_ind);
                return eel.param_ind - sel.param_ind;
            } else {
                // goes to the end of the arg stack:
                return owner.param_stack_size() - sel.param_ind;
            }
        }

        // returns the corresponding base in the param stack
        // or -1 if there is no such thing.
        int param_base() const {
            return owner.lr_stack_entry(base_index).param_ind;
        }

        // construct a slice with a particular base and count.
        // if the count is -1 or unspecified, construct a slice
        // with the given base to the top of the stack
        StackSlice(const @class_name@ &o, int base, int count = -1) :
            base_index(base),
            size(count),
            owner(o)
        {
            if(size == -1) {
                size = owner.lr_stack.size() - base;
            }
        }

        // Negative indexes are offset from a hypothetical argument
        // just past the end of the slice (i.e. -1 means end-of-slice).
        // Accessing to entries outside the slice yields a "false"
        // stack entry.
        StackEntry operator [](int ind) const {
            if(ind < 0) ind += size; // allow negative indexes

            int off = ind + base_index;
            if((off < owner.lr_stack_size()) && (off >= 0)) {
                return owner.lr_stack[off];
            } else {
                return StackEntry();
            }
        }

        // Returns the nth "product" (from the argument stack)
        // corresponding to this slice.
        // If the index passed is out of bounds, returns a 
        // default product.
        // Note that there may be 0 products for any slice,
        // so the 0th is not guaranteed to be anything real.
        Product product(int ind = 0, src_location caller = CALLER()) const {
            const int pbase = param_base();
            const int num_args = param_count();
            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind >= 0) && (ind < num_args)) {
                unsigned int sind = pbase + ind;
                return owner.param_stack_entry(sind, caller);
            } else {
                return Product();
            }
        }

        std::string to_str() const {
            std::string out;
            for(int ind = 0; ind < size; ++ind) {
                out += stringformat("    {}\n", owner.lr_stack[ind]);
            }
            return out;
        }
    };

    // Call this within a reduce function to get a stack slice containing
    // all the steps (StackEntries) for the matched rule.
    // Don't call from outside a reduce function.
    //  hey..... uhh... is this misnamed?  I think it doesn't include
    //  -actually- ejected steps.  errf.  but it's not all params either
    //  because if there's an eject/keep conflict we'll keep the param
    //  here, whether or not this action considers it a parameter.
    StackSlice all_matched_steps() {
        return StackSlice(*this, lr_read_pos);
    }

    // call this like:  prod_type_name(typeid(...));
    static std::string prod_type_name(const std::type_info &tinf) {
        @-for(auto type : prds.all_types) {@
            if(std::type_index(typeid(@type@)) == std::type_index(tinf)) {
                return "@type@";
            }
        @}@
        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }
        if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
            return "Product";
        }
        return "unknown type in prod_type_name";
    }

    // This represents the argument for a given step, which should be one
    // lr stack entry plus a (possibly 0-sized) slice of the param stack
    template<typename ReduceType>
    class ReductionParameter {
        // all access to param and lr stacks go through this:
        StackSlice lr_slice;

    public:
        ReductionParameter(@class_name@ &o, int lr_base, int lr_count) :
            lr_slice(o, lr_base, lr_count) { }

        // returns the number of param_stack entries in this:
        int count() const { return lr_slice.param_count(); }

        // (syntactic sugar for optionals)
        bool exists() const { return count() !=  0; }

        SourcePosition position() const {
            return lr_slice[0].position();
        }

        SourcePosition end_position() const {
            return lr_slice[-1].position();
        }

        // this allows you to refer to the stack slice itself from within
        // reduce functions using the at sign (eg thing@@self())
        ReductionParameter<ReduceType> self() { return *this; }

        // in reduce code, this is accessed via [] or (for the 0th element)
        // just the name of the variable itself.
        const ReduceType val(int ind = 0, src_location ca = CALLER()) const {
            const int num_args = count();

            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind < 0) || (ind >= num_args)) {
                jerror::warning(stringformat(
                    "Index {} out of range ({} items) at {}",
                    ind, num_args, ca
                ));

                // try to return a default item of the ReduceType.
                // this may or may not be possible, depending on the
                // type, but it's better than crashing.
                return ReduceType();
            }

            return std::get<ReduceType>(
                lr_slice.product(ind, ca).var()
            );
        }

        static std::string type_name() {
            return prod_type_name(typeid(ReduceType));
        }

        std::string concatenate() const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
            }
            return out;
        }

        // XXX we pass the Product here so that callers can get at
        // line numbers etc, but ... oh that's outdated.
        // See if we can jsut pass ReduceType
        using ForeachFunc = std::function<void(const Product &)>;
        void foreach(ForeachFunc func) const {
            for(int ind = 0; ind < count(); ++ind) {
                func(lr_slice.product(ind));
            }
        }

        std::string join(const std::string &jv) const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                if(ind < count() - 1)
                    out += stringformat("{}{}", val(ind), jv);
                else // last element
                    out += stringformat("{}", val(ind));
            }
            return out;
        }

        inline std::string to_str() const {
            // XXX do something smarter here
            return lr_slice.to_str();
        }
    };

    void set_state(State st) {
        cur_state = st;
    }

    Product param_stack_entry(int pos, src_location caller = CALLER()) const {
        // this is very similar to lr_stack_entry.  generalize?
        if((pos >= 0) && (pos < param_stack.size())) {
            return param_stack[pos];
        } else {
            jerror::warning(stringformat(
                "param stack access out of range ({}/{}) at {}",
                pos, param_stack.size(), caller
            ));
            return Product();
        }
    }

    State current_state() const {
        return cur_state;
    }

    // this is more or less debugging
    std::string to_str() const {
        std::string out;

        out += stringformat(
            "next up (lr pos {}): {}\n", lr_read_pos, next_up_str()
        );
        out += stringformat(
            "{} bytes of separator since last terminal\n", bytes_eaten
        );
        out += stringformat("lr stack ({} items):\n", lr_stack.size());
        for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
                " {} [{}] {}\n",
                sind == lr_read_pos?"->":"  ", sind, lr_stack_entry(sind)
            );
        }
        out += stringformat("param stack ({} items):\n", param_stack.size());
        for(int sind = param_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
                "    [{}] {::n}\n", sind, param_stack_entry(sind)
            );
        }
        return out;
    }

    Product result() const {
        // (... possibly we should only consider it a result if there's
        // exactly one item on the stack.  could simplify callers)
        return lr_top().product(*this);
    }

    int result_product_id() const {
        return lr_top().element_id;
    }

    // mismatch() begins or continues the backtracking process when
    // a state hits unexpected input.
    void mismatch() {
        // move the lr read pointer to before the last bad push:
        while(lr_stack_entry(--lr_read_pos).mismatch)
            ;

        if(lr_read_pos < 0) {
            lr_read_pos = 0;
            // can't go back any more, so terminate:
            terminate();
        } else {
            // mark whatever was there as a mismatch, and try that
            // state again:
            StackEntry &bad_entry = lr_stack[lr_read_pos];
            bad_entry.mismatch = true;
            cur_state = bad_entry.state;
            reader->go_to(bad_entry.position());
        }
    }

    void terminate() {
        stop_parsing = true;
    }

    // Removes terminals from the top of the lr stack and sets
    // the source read position to the start of the removed
    // terminals.
    // This is used after termination to unwind such that the
    // read position is just after the last successfully parsed
    // thing instead of potentially being after some recognized
    // but unused terminals, thus setting the read pointer to
    // the start of any unrecognized input.
    void rewind_to_nonterm() {
        if(result())
            return; // already after last nonterminal

        size_t rewind_to = reader->current_position();
        while(lr_stack.size() > 0) {
            auto last = lr_stack.back();
            if(last.is_nonterminal()) {
                break;
            }
            rewind_to = last.position();
            lr_pop();
        }
        reader->go_to(rewind_to);
    }

    // Returns a string with either the next bit of text
    // (in French quotes) or the next production
    std::string next_up_str() const {
        if(StackEntry next = lr_next()) {
            return stringformat(
                "{} = {::n}",
                element_str(next.element_id), next.product(*this)
            );
        } else {
            return stringformat(
                "«{}» ({}:{::n})",
                reader->debug_peek(32),
                reader->filename(), reader->current_position()
            );
        }
    }

    // not passing by reference here - instead, crossing fingers
    // and hoping it really just gets inlined.
    inline void post_parse(@prds.output_type()@ result) {
        @if(prds.post_parse) {@
            @prds.post_parse.format()@
        @}@
    }

    bool more_to_parse() const {
        // there's more to parse if:
        //  - we haven't been told to stop (due to matching _fpl_goal,
        //    or errors, or whatever)
        //  - and there's more input -or- we're not at the goal
        return !stop_parsing
            && ((!eof() || lr_stack.size() > 1) || !result_is_goal());
    }

    // resets the state of the parser, discarding anything on
    // the stack.
    // does _not_ reset the input position, so as to allow
    // mixed-parser parses.
    void reset() {
        @if(opts.debug) {@
            std::cerr << "resetting @class_name@!!!\n";
        @}@
        lr_stack.clear();
        lr_read_pos      = 0;
        param_stack.clear();
        set_state(&@class_name@::state_0);
        bytes_eaten      = 0;
        stop_parsing     = false;
        num_errors       = 0;
    }

    // In an fpl parser, we do not want to require that the whole
    // input has been consumed.  This allows piecewise parsing.
    // For example, a top down parser can invoke an fpl parser
    // to handle some class of expressions, receive the result,
    // and then continue parsing whatever it was parsing.  Or,
    // let's say you're parsing a stream of input, and you want
    // to parse it as it comes in instead of all at once after
    // getting the entire thing.
    //
    // So, this parses as much as it can, then leaves the parser
    // as intact as possible so that the caller can examine it
    // for errors or whatever and decide what to do.
    //
    void parse_partial() {
        do {
            State st = current_state();
            (this->*st)();
        } while(more_to_parse());
    }

    // Attempts to parse a goal from the current input.
    // If we didn't parse a goal, input remains at the
    // position from the start of parse.
    // Any additional input after the goal is left and may be
    // parsed with additional passes of this or another parser.
    // If it parsed a goal product, that product will be returned.
    // Otherwise, returns a false product.
    const Product parse_goal() {
        reset();
        parse_partial();
        rewind_to_nonterm();
        if(result_is_goal()) {
            return result();
        }
        return Product();
    }

    // Returns a string containing a list of possible terminals
    // when in the state passed.  Used for error messages.
    static std::string expected_terminals(State st) {
        @-for(int sti = 0; sti < prds.num_states(); sti++) {-@
            @declare state: prds.states.at(sti)@
            if(&@prds.state_fn(state, true)@ == st) {
                return @-for(auto term: state.terminals()) {-@
                    "@c_str_escape(term.to_str())@, "
                @-}-@ "";
            }
        @}@
        return "";
    }

    void report_parse_error(const std::string &errm) {
        // at this point, it looks clearest to just pass the
        // error through.  I'm keeping this function as a
        // place to hook counters or whatever, however.
        error(errm);
    }

    // returns a string telling why parse() failed, or
    // an empty string if it appears to have worked
    std::string why_bad_parse() const {
        Product got = result();
        int got_id  = result_product_id();

        // In this case, we're assuming we have the entire input.
        // So, we expect:
        //   - we're at eof (end of input)
        //   - only the result left on the stack
        //   - result is a goal
        if(!eof()) {
            // If we're not at end of input, we stopped when we
            // didn't recognize something.  If there's currently 
            // a "result", that's what was unexpected (i.e. it
            // recognized something, but that something didn't
            // fit the bigger picture).  Otherwise, it means we
            // got some generally unrecognized input:
            std::string prev_str;
            if(StackEntry prev = lr_prev()) {
                prev_str = stringformat(
                    " after {} at {}",
                    element_str(prev.grammar_element_id()),
                    prev.position()
                );
            }
            if(got_id >= 0 && is_nonterminal(got_id)) {
                return stringformat(
                    "unexpected element{}: {} ({}).\nso far we have:\n{}",
                    prev_str,
                    element_str(got_id), got,
                    StackSlice(*this, 0)
                    //next_up_str()
                );
            } else  {
                return stringformat(
                    "unrecognised input{}.  expected one of: {}",
                    prev_str,
                    expected_terminals(current_state())
                );
            }
        } else if(lr_stack_size() > 1) {
            // If there's extra stuff on the stack after we rewound,
            // it means we recognized more than one component, but
            // nothing complete.
            return "incomplete input";
        } else if(!result_is_goal()) {
            return stringformat(
                "parsed a {} = {}, but that's not a goal ({})",
                element_str(got_id), got, "@join(prds.goals, ", ")@"
            );
        }
        return "";
    }

    // Parses the contents of the current reader.
    // Input contents are assumed to be complete.
    // Calls error() if any parse errors were detected.
    // Returns whatever it got, regardless of errors,
    // which might mean returning a default of whatever
    // the reduce type is.
    @prds.output_type()@ parse() {
        // we're parsing from initial state...
        reset();
        parse_partial();

        // consume any additional "separators" (eg whitespace,
        // comments) before checking the parse, since it's
        // going to check eof()
        eat_separator();

        std::string errm = why_bad_parse();
        if(errm.length()) {
            report_parse_error(errm);
        } else {
            post_parse(result().val());
        }

        return result().val();
    }

private:

    @for(auto mem : prds.parser_members) {@
        @mem.format()@
        // return to "private" after each such block.
        // this way, authors can add public members
        // to the parser without turning other stuff public 
        private:
    @}@

    @/* custom scanners:
        these are expected to return something iterable.
        an empty iterable indicates no match; otherwise
        the generated Terminal will contain the items
        returned.
    */@
    @for(auto &[scanner_name, scanner_code] : prds.scanners) {@
        #line @scanner_code.line@ "@scanner_code.source_file@"
        auto custom_scanner_@scanner_name@(fpl_reader &input) {
            @scanner_code.format()@
        }
    @}@

    @/* "shift" methods.  these check for the relevant element and,
        if there's a match, change the state to the state passed.
    */@
    @for(auto element : prds.elements) {@
        @if(element.is_nonterminal()) {@
            @#fpl_x_parser_shift_nonterm(prds, element, opts)@
        @} else {@
            // (terminals and assertions - everything else)
            @#fpl_x_parser_shift_term(prds, element, opts)@
        @}@
    @}@
    @#fpl_x_parser_shift_none(prds, grammar_element(), opts)@

public:

    typedef enum {
        @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
            @declare el: prds.elements[el_id]@
            @prds.element_id_name(el_id)@, // @el_id@ @el.to_str()@
        @-}-@
    } ElementID;

    // returns a string describing the element matching the ID
    // passed. this is for debugging.
    static std::string element_str(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @declare el: prds.elements[el_id]@
                case @el_id@: return "@c_str_escape(el.expr)@";
            @-}-@
        }
        return stringformat("¡unknown element id {}!", id);
    }

    static bool is_nonterminal(int id, const std::string &caller = CALLER()) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @if(prds.elements[el_id].is_nonterminal()) {-@ 
                    case @el_id@: return true;
                @} else {-@
                    case @el_id@: return false;
                @}-@
            @-}-@
        }
        jerror::error(stringformat(
            "internal error {}: invalid terminal id: {}\n", caller, id
        ));
        return false;
    }

    // returns the name of the state function for the state pointer passed
    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh
        @for(int st = 0; st < prds.num_states(); st++) {-@
            if(&@prds.state_fn(st, true)@ == st) return "@prds.state_fn(st)@";
        @}@
        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    // return a stack-trace style dump of the state passed.
    static const char *state_string(State st) {
        @for(int sti = 0; sti < prds.num_states(); sti++) {-@
            if(&@prds.state_fn(sti, true)@ == st) {
                return "@prds.state_fn(sti, false)@:\n"
                       @prds.states.at(sti).to_str(
                           &prds, "\"    ", "\\n\"\n", true
                       )@;
            }
        @}@
        return "<invalid state>";
    }

    // Returns true if elements matching the element id passed
    // are ejected in the context of the given state, or false
    // otherwise.
    static bool state_ejects(State st, int element_id) {
        @-for(int sti = 0; sti < prds.num_states(); sti++) {-@
            @declare state: prds.states.at(sti)@
            if(&@prds.state_fn(state, true)@ == st) {
                @for(auto eje : state.ejected_elements()) {@
                    if(ElementID::@prds.element_id_name(eje)@ == element_id) {
                        return true;
                    } else
                @}@
                {
                    return false;
                }
            } else
        @-}-@
        {
            return false;
        }
    }

    static bool is_goal(int el_id) {
        switch(el_id) {
            @for(auto gstr : prds.goals) {-@
                case ElementID::_@gstr@: return true;
            @}@
            default: return false;
        }
        return false;
    }

    bool result_is_goal() const {
        return is_goal(result_product_id());
    }

    static size_t separator_length(const utf8_byte *inp) {
        @if(prds.separator_code.size() == 0) {-@
            // no separators specified, so separate on space:
            return space_length(inp);
        @}-@

        @for(auto sepc : prds.separator_code) {-@
            {
                @sepc.format()@
            }
        @}-@

        @/* catchall: if nothing returned a length yet, no separator */@
        return 0;
    }

    size_t eat_separator() {
        bytes_eaten += reader->eat_separator(separator_length);
        return bytes_eaten;
    }

    // reduction rules:
    @for(auto rule : prds.rules) {@
        @if(!rule.is_subexpression()) {@
            @#fpl_x_parser_reduce_action(prds, rule)@
        @}@
    @}@

    // parser states:
    @for(int stn = 0; stn < prds.num_states(); stn++) {@
        @#fpl_x_parser_state(prds, prds.states.at(stn), prds.opts)@
    @}@

};

#endif // header guard

@if(opts.generate_main || prds.default_main) {@
    @#fpl_default_main(prds)@
@} else if(prds.main_guts) {@
    int main(int argc, const char **argv) {
        @prds.main_guts.format()@
    }
@}@

