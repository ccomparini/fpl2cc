@parameter: const productions &prds @
@parameter: const fpl_options &opts @
@declare class_name: prds.parser_class_name()@
@realign: #line {} "{}" @

#ifndef @class_name@_H
#define @class_name@_H

/*
  generated by fpl2cc @opts.version()@ from @source.filename()@

  options:
    @opts.to_str()@

  calculated goal(s):
    @prds.goal@
 */

@for(auto fn : opts.impl_sources) {@
    @code_block::from_file(fn, opts.src_path, "(command line)", 1).format()@
@}@

#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>

#include "fpl2cc/fpl_reader.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"

@if(prds.preamble.size()) {@
    @for(auto pre : prds.preamble) {@
        @pre.format()@
    @}@
@}@


class @class_name@ {
public:
    void state(); // this just facilitates the "using State"
    using State = decltype(&@class_name@::state);

    class Terminal {
        // the first string in "matches" is the entire terminal match
        // and will exist for exact matches as well as regex matches.
        // subsequent matches are used for capture groups in a regex
        // match.
        std::vector<std::string> matches;
    public:

        Terminal() { } // false valued terminal

        Terminal(const std::string &src, const std::string &caller = CALLER()) {
            matches.push_back(src);
        }

        Terminal(const std::cmatch &src) {
            for(auto srcm : src)
                matches.push_back(srcm);
        }

        Terminal(const utf8_byte *p, int l = 0) {
            if(p) matches.push_back(std::string((const char *)p, 0, l));
        }

        std::string to_str() const {
            if(matches.size())
                return matches[0];
            return "";
        }

        // returns a string containing the contents of the regex capture
        // group indicated by the index passed.
        // for example, if the regex /(.)y(.*)/ matched the string "dyad",
        // capgroup(0) would be "d" and capgroup(1) would be "ad".
        // default is the 0th capgroup.
        // returns the empty string for any non-existent capture groups.
        std::string capgroup(int capi = 0) const {
            if(capi + 1 < matches.size()) {
                return matches[capi + 1];
            }
            return "";
        }

        operator bool() const {
            return matches.size() > 0;
        }

        operator std::string() const { return to_str(); }

        std::string operator+(const std::string & rhs) const {
            return to_str() + rhs;
        }
    };

    class Product {
    public:
        using Var = std::variant<
            @-for(auto type : prds.all_types) {-@
                @type@,
            @-}-@
            Terminal
        >;

        Var red;
    private:

        int  element_id;

        SourcePosition pos;

    public:
        // Note:  this is relying on element id 0 being a null/error element.
        Product() : element_id(0) {
        };

        Product(Terminal tm, int el_id, const SourcePosition &position) :
            red(tm), element_id(el_id), pos(position) {
            if(!is_terminal()) {
                jerror::error(stringformat(
                    "FAIL: {} ain't no terminal\n", el_id
                ));
            }
        };

        // type-specific constructors:
        @-for(auto type : prds.all_types) {-@
            Product(@type@ result, int el_id, const SourcePosition &p) :
                red(result), element_id(el_id), pos(p) {

                if(is_terminal()) {
                    jerror::error(stringformat(
                        "FAIL: {} is a terminal\n", el_id
                    ));
                }
            };
        @-}-@

        const Var &var() const { return red; }

        operator bool() const {
            return element_id != 0;
        }

        int grammar_element_id() const { return element_id; }
        bool is_terminal() const { return @class_name@::is_terminal(element_id); }

        SourcePosition position() const { return pos; }

        std::string type_name() const {
            if(std::holds_alternative<Terminal>(red)) return "Terminal";
            @-for(auto type : prds.all_types) {-@
                if(std::holds_alternative<@type@>(red)) return "@type@";
            @-}-@
            // can't get here?
            jerror::error("Unknown type for product");
            return "unknown type";
        }

        // this is for debug and similar:
        std::string to_str() const {
            std::string out;
            if(element_id > 0) {
                if(is_terminal()) {
                    out += "terminal " + std::to_string(element_id) + " «";
                    out += std::get<Terminal>(var()).to_str();
                    out += "»";
                } else {
                    out += nonterm_str(element_id);
                    @-for(auto type : prds.all_types) {-@
                        if(std::holds_alternative<@type@>(var())) {
                            out += stringformat(
                                " (value: «{}»)", std::get<@type@>(var())
                            );
                        } else 
                    @}-@
                    { out += "<unknown type>"; }
                }
            } else {
                out = "null product";
            }
            return out;
        }

        // phase out if possible, because this only supports the
        // top reduce_type and that's wacky.
        @prds.reduce_type@ val(const std::string &caller = CALLER()) const {
            if(!std::holds_alternative<@prds.reduce_type@>(red)) {
                jerror::error(stringformat(
                    "FAILULAR: product holds type {} and not @prds.reduce_type@ at {}\n",
                    type_name(), caller
                ));
                @prds.reduce_type@ dummy;
                return dummy;
            }
            return std::get<@prds.reduce_type@>(red);
        }

        std::string term_str() const {
            if(is_terminal())
                return std::get<Terminal>(red).to_str();

            return stringformat("{} is not a terminal", nonterm_str(element_id));
        }

        std::string capgroup(int capi) const {
            if(is_terminal())
                return std::get<Terminal>(red).capgroup(capi);
            return "";
        }
    };

    struct StackEntry {
        State   state;
        Product product;

        StackEntry(State st, Product pr) :
            state(st),
            product(pr) {
        }

        // creates a "false" stack entry:
        StackEntry() : state(NULL) {
        }

        StackEntry(const StackEntry &) = default;

        inline operator bool() const {
            return state != NULL;
        }

        inline int grammar_element_id() const {
            return product.grammar_element_id();
        }

        inline SourcePosition position() const {
            return product.position();
        }

        inline int line_number() const {
            return position().line_number();
        }

        inline std::string filename() const {
            return position().filename();
        }

        std::string to_str() const {
            std::string line_no = "line " + std::to_string(line_number());

            return stringformat("{}, {::n} ({})", 
                state_to_str(state),
                product.to_str(),
                product.position()
            );
        }

        // Shortcuts to access products/terminals:
        std::string capgroup(int capi) const {
            return product.capgroup(capi);
        }

    };

    void lr_push(State st, Product pr) {
        lr_stack.push_back(StackEntry(st, pr));
        cur_state = st;
    }

private:
    fpl_reader_p            reader; // XXX must be non-null
    State                   cur_state;
    Product                 last_product;
    std::vector<StackEntry> lr_stack;
    int                     lr_arg_base; // base ind for current reduce call
    size_t                  bytes_eaten; // since last terminal
    bool                    stop_parsing;
    int                     max_errors;
    int                     num_errors;

    bool                    single_step; // debugging

    // this is called when something appears to have
    // gone wrong due to a bug in the parser itself:
    void internal_error(const std::string &msg) {
        error(stringformat(
            "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
        ));
        terminate();
    }

public:
    // constructors:
    @class_name@(const @class_name@ &rhs) = delete;

    @class_name@(fpl_reader_p rdr) :
        reader(rdr),
        cur_state(NULL),
        lr_arg_base(-1),
        bytes_eaten(0),
        stop_parsing(false),
        max_errors(1),
        num_errors(0),
        single_step(false) {

        @if(opts.single_step) {@
            set_single_step(true);
        @}@

        // reserve more than we'll need so we don't have to realloc:
        lr_stack.reserve(1000);
    }

    // debugging:
    void set_single_step(bool newval) { single_step = newval; }
    void debug_pause() {
        int inch;
        if(single_step)
            inch = getchar();
        if(inch == 'c')
            single_step = false;
    }

    void set_max_errors(int newmax) { max_errors = newmax; }

    void error(size_t pos, const std::string &msg) {
        std::string full_msg = reader->format_error_message(pos, msg);
        fputs(full_msg.c_str(), stderr);
        if(++num_errors > max_errors) {
            fputs("too many errors.  aborting\n", stderr);
            terminate();
        }
    }

    void error(const std::string &msg) {
        error(reader->current_position(), msg);
    }

    int error_count() const { return num_errors; }

    bool eof() const {
        return reader->eof();
    }


private:
    StackEntry lr_pop() {
        StackEntry popped;
        if(lr_stack.size() > 0) {
            popped = lr_stack.back();
            lr_stack.pop_back();
        } // else popped is a "false" entry

        if(lr_stack.size() == 0) {
            // we've popped back down to the initial state:
            cur_state = &@class_name@::state_0;
        } else {
            cur_state = lr_stack[lr_stack.size() - 1].state;
        }

        return popped;
    }

public:

    inline std::string filename() const {
        return reader->filename();
    }

    inline int line_number() const {
        return reader->line_number();
    }

    inline int line_number(size_t pos) const {
        return reader->line_number(pos);
    }

    inline SourcePosition position() const {
        return SourcePosition(reader);
    }

    inline fpl_reader_p_c const_reader() const {
        return reader;
    }

    inline int lr_stack_size() const {
        return lr_stack.size();
    }

    inline int lr_top() const {
        return lr_stack.size() - 1;
    }

    // "pops" and discards down to the new top specified
    inline int lr_pop_to(int new_top) {
        if(new_top >= 0) {
            cur_state = lr_stack[new_top].state;
        } else {
            cur_state = &@class_name@::state_0;
        }
        lr_stack.resize(new_top + 1);
        return lr_top();
    }

    inline StackEntry lr_stack_entry(int pos) const {
        if((pos >= 0) && (pos < lr_stack_size())) {
            return lr_stack[pos];
        } else {
            return StackEntry();
        }
    }

    class StackSlice {
        int base_index;
        int size;

        // owner here is annoying because we should be able to
        // infer it. it should always be the "this" (assuming
        // StackSlices are private).  jest feature?
        const @class_name@ &owner;

    public:
        int count() const { return size; }

        // (syntactic sugar for optionals)
        bool exists() const { return count() !=  0; }

        // construct a slice with a particular base and count.
        // if the count is -1 or unspecified, construct a slice
        // with the given base to the top of the stack
        StackSlice(@class_name@ &o, int base, int count = -1) :
            base_index(base),
            size(count),
            owner(o)
        {
            if(size == -1) {
                size = o.lr_stack_size() - base;
            }
        }

        // construct a slice by pseudo-popping a set of elements of
        // the same type from the stack.  We use this for things like
        // constructing arguments for rules with repetition or optional
        // parameters.
        // "pseudo-popping" means reading from and updating the "pos"
        // integer passsed, instead of actually popping from the stack
        // (we only remove from the stack after the reduction rule
        // is executed).  This is so that you can call this multiple
        // times for multiple arguments.
// XXX comment makes less sense now that it's passing boolean multiple
        StackSlice(@class_name@ &o, int element_id, bool multiple, int &pos) :
            size(0),
            owner(o)
        {
            // starting at pos and going backward down the stack,
            // scan elements matching the id passed:
            while(StackEntry se = owner.lr_stack_entry(pos)) {
                if(se.grammar_element_id() != element_id) {
                    break;
                }
                pos--;
                size++;

                if(!multiple) break;
            }
            base_index = pos + 1;
        }

        // Negative indexes are offset from a hypothetical argument
        // just past the end of the slice (i.e. -1 means end-of-slice).
        // Accessing to entries outside the slice yields a "false"
        // stack entry.
        inline StackEntry operator [](int ind) const {
            if(ind < 0) ind += size; // allow negative indexes

            int off = ind + base_index;
            if((off < owner.lr_stack_size()) && (off >= 0)) {
                return owner.lr_stack[off];
            } else {
                return StackEntry();
            }
        }

        inline Product product(int ind = 0) const {
            if(ind < 0) ind += size; // negative indexes are relative to end

            if((ind >= 0) && (ind < size)) {
                unsigned int sind = base_index + ind;
                if(sind > owner.lr_stack.size())
                    jerror::error(stringformat( 
                        "stack slice access out of stack range. {} + {} = {} > {}\n",
                        base_index, ind, sind, owner.lr_stack.size()
                    ));
                return owner.lr_stack[sind].product;
            } else {
                return Product();
            }
        }

        inline std::string term_str(int ind = 0) const {
            return product(ind).term_str();
        }

        using ForeachFunc = std::function<void(const Product &)>;
        void foreach(ForeachFunc func) const {
            for(int ind = 0; ind < size; ++ind) {
                func(product(ind));
            }
        }

        inline std::string to_str() const {
            std::string out;
            for(int ind = 0; ind < size; ++ind) {
                out += std::to_string(ind) + " (abs " + std::to_string(base_index + ind) + "): ";
                out += product(ind).to_str() + "\n";
            }
            return out;
        }
    };

    // call within a reduce function to get a stack slice containing all
    // the arguments to that reduce function.
    // don't call from outside a reduce function.  it gets initialized
    // just before the call. (pass it instead?)
    StackSlice all_args() {
        return StackSlice(*this, lr_arg_base + 1);
    }

    // call this like:  prod_type_name(typeid(...));
    static std::string prod_type_name(const std::type_info &tinf) {
        @-for(auto type : prds.all_types) {@
            if(std::type_index(typeid(@type@)) == std::type_index(tinf)) {
                return "@type@";
            }
        @}@
        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }
        if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
            return "Product";
        }
        return "unknown type in prod_type_name";
    }

    template<typename ReduceType>
    struct StackSliceSpecialization : public StackSlice {
        StackSliceSpecialization(@class_name@ &o, int element_id, bool multiple, int &pos) :
            StackSlice(o, element_id, multiple, pos) { }

        // this allows you to pass the stack slice itself from within
        // reduce functions using the at sign (eg thing@@self())
        StackSliceSpecialization<ReduceType> self() { return *this; }

        // in reduce code, this is accessed via [] or (for the 0th element)
        // just the name of the variable itself.
        const ReduceType val(int ind = 0) const {
            ReduceType got = std::get<ReduceType>(product(ind).var());
            return got;
        }

        static std::string type_name() {
            return prod_type_name(typeid(ReduceType));
        }

        std::string concatenate() const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
            }
            return out;
        }

        std::string join(const std::string &jv) const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
                if(ind < count() - 1)
                    out += jv;
            }
            return out;
        }
    };

    void set_product(const Product &pr) {
        if(last_product) {
            // if this happens, it's almost certainly a bug in fpl2cc
            // since it means we're setting a new product without having
            // shifted whatever nonterm product was next up..
            internal_error(stringformat(
                "splatting last_product ({}) with {}\n",
                last_product.to_str(), pr.to_str()
            ));
        }
        last_product = pr;
    }

    void set_state(State st) {
        cur_state = st;
    }

    State current_state() const {
        return cur_state;
    }

    // this is more or less debugging
    std::string to_str() const {
        std::string out;

        std::string next_up;
        if(last_product) {
            next_up = last_product.to_str();
        } else {
            next_up = stringformat(
                "«{}» ({}:{::n})",
                reader->debug_peek(32),
                reader->filename(), reader->current_position()
            );
        }
        out += stringformat("next up: {::n}\n", next_up);
        out += stringformat(
            "{} bytes of separator since last terminal\n", bytes_eaten
        );
        out += stringformat("stack ({} items)\n", lr_stack.size());
        for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
                "    [{}] {}\n", sind, lr_stack_entry(sind).to_str()
            );
        }
        return out;
    }

    const Product &result() const {
        return last_product;
    }

    static bool is_goal(const Product &pr) {
        return is_goal(pr.grammar_element_id());
    }

    void terminate() {
        stop_parsing = true;
    }

    // rewind to the point just after the last nonterminal.
    // this is used after termination to unwind such that the
    // read position is just after the last successfully parsed
    // thing instead of potentially being after some recognized
    // but unused terminals, thus setting the read pointer to
    // the start of any unrecognized input.
    void rewind_to_nonterm() {
        StackEntry last_popped;
        size_t rewind_to = reader->current_position();
        while(lr_stack.size() > 0) {
            last_popped = lr_pop();
            Product &top_prod = last_popped.product;
            if(top_prod.is_terminal()) {
                rewind_to = top_prod.position().position();
            } else {
                last_product = top_prod;
                break;
            }
        }

        if(last_popped) {
            cur_state = last_popped.state;
            reader->go_to(rewind_to);
        }
    }

    // returns a string with either the next bit of text
    // (in French quotes) or the name of the next production
    std::string debug_next_up() {
        if(last_product) {
            return nonterm_str(last_product.grammar_element_id());
        } else {
            return stringformat("«{}»", reader->debug_peek().c_str());
        }
    }

    // not passing by reference here - instead, crossing fingers
    // and hoping it really just gets inlined.
    inline void post_parse(@prds.reduce_type@ result) {
        @if(prds.post_parse) {@
            @prds.post_parse.format()@
        @}@
    }

    bool more_to_parse() const {
        // there's more to parse if:
        //  - we haven't been told to stop (due to errors or whatever)
        //  - and there's more input -or- we're not at the goal
        return !stop_parsing
            && ((!eof() || lr_stack.size() > 0) || !is_goal(last_product));
    }

    // resets the state of the parser, discarding anything on
    // the stack.
    // does _not_ reset the input position, so as to allow
    // mixed-parser parses.
    void reset() {
        @if(opts.debug) {@
            std::cerr << "resetting @class_name@!!!\n";
        @}@
        lr_stack.clear();
        set_state(&@class_name@::state_0);
        last_product     = Product();
        bytes_eaten      = 0;
        stop_parsing     = false;
        num_errors       = 0;
    }

    // In an fpl parser, we do not want to require that the whole
    // input has been consumed.  this allows piecewise parsing.
    // for example, a top down parser can invoke an fpl parser
    // to handle some class of expressions, receive the result,
    // and then continue parsing whatever it was parsing, or
    // you're parsing a stream of input, and you want to parse
    // it as it comes in instead of all at once after getting
    // the entire thing.
    //
    // So, this parses as much as it can, then leaves the parser
    // as intact as possible so that the caller can examine it
    // for errors or whatever and decide what to do.
    //
    void parse_partial() {
        do {
            State st = current_state();
            (this->*st)();
        } while(more_to_parse());
    }

    // Attempts to parse a goal from the current input.
    // If we didn't parse a goal, input remains at the
    // position from the start of parse.
    // Any additional input after the goal is left and may be
    // parsed with additional passes of this or another parser.
    // If whatever we parsed was a goal, we return that and
    // reset the result to a false product.   Otherwise,
    // we return a false product.
    const Product parse_goal() {
        reset();
        parse_partial();
        rewind_to_nonterm();
        Product got = result();
        if(is_goal(got)) {
            last_product = Product();
            return got;
        }
        return Product();
    }

    // Parses the contents of the current reader.
    // Input contents are assumed to be complete.
    // Calls error() if any parse errors were detected.
    // Returns whatever it got, regardless of errors,
    // which might mean returning a default of whatever
    // the reduce type is.
    @prds.reduce_type@ parse() {
        // we're parsing from initial state...
        reset();

        // errors should be handed up to the caller somehow,
        // but for now I'm going to let callers use parse_partial
        // and figure out errors if that's what they want.

        parse_partial();
        rewind_to_nonterm();
        Product got = result();

        // consume any additional "separators" (eg whitespace,
        // comments) before checking if we're at end of input:
        eat_separator();

        // In this case, we're assuming we have the entire input.
        // So, we expect:
        //   - we're at eof (end of input)
        //   - nothing left on the stack
        //   - result is a goal
        std::string errm;
        if(!eof()) {
            // If we're not at end of input, we stopped when we
            // didn't recognize something.  If there's currently 
            // a "result", that's what was unexpected (i.e. it
            // recognized something, but that something didn't
            // fit the bigger picture).  Otherwise, it means we
            // got some generally unrecognized input:
            std::string message;
            if(got) {
                errm = stringformat("unexpected {}", got.to_str());
            } else  {
                errm = "unrecognised input";
            }
            error(message);
        } else if(lr_stack_size() > 0) {
            // there's stuff on the stack after we rewound,
            // it means we recognized more than one component,
            // but nothing complete.
            errm = "incomplete input";
        } else if(!is_goal(got)) {
            errm = stringformat(
                "parsed a {} = {}, but that's not a goal (@prds.goal@)",
                nonterm_str(got.grammar_element_id()), got
            );
        }

        if(errm.length()) {
            error(stringformat(
                "{}\n"
                "here's what we have so far:\n{}"
                "{}and state was:\n{}\n",
                errm, StackSlice(*this, 0),
                got?stringformat("next up would have been {}\n", got):"",
                state_string(cur_state)
            ));
        }

        post_parse(got.val());

        return got.val();
    }



private:

    @for(auto mem : prds.parser_members) {@
        @mem.format()@
        // return to "private" after each such block.
        // this way, authors can add public members
        // to the parser without turning other stuff public 
        private:
    @}@

    inline bool shift_TERM_EXACT(
        const std::string &match, int el_id, State new_st
    ) {
        // if there's a product (nonterminal) up next,
        // we don't want to shift a terminal.
        if(last_product)
            return false;

        @if(opts.debug) {@
            std::cerr << stringformat(
                "maybe shift '{}' to {}? ",
                element_str(el_id), state_to_str(new_st)
            );
        @}@

        const SourcePosition &pos = position();
        if(reader->read_exact_match(match)) {
            @if(opts.debug) {@
                std::cerr << "yes\n";
            @}@
            lr_push(new_st, Product(Terminal(match), el_id, pos));
            bytes_eaten = 0;
            return true;
        }

        @if(opts.debug) {@
            std::cerr << "no\n";
        @}@
        return false;
    }

    inline bool shift_TERM_REGEX(
        const std::string &re, int el_id, State new_st
    ) {
        // (again, don't match if there's a product up next)
        if(last_product)
            return false;

        @if(opts.debug) {@
            std::cerr << stringformat(
                "maybe shift /{}/ to {}? ",
                element_str(el_id), state_to_str(new_st)
            );
        @}@

        const SourcePosition pos = position();
        std::cmatch match = reader->read_re(re.c_str());

        // XXX bug:  if there's a 0-byte match but multiple
        // is allowed, the parser ends up looping infinitely
        // reading 0 bytes and saying "ok yeah that matched".
        if(!match.empty()) { // note 0-byte match is considered not empty
            @if(opts.debug) {@
                std::cerr << "yes\n";
            @}@
            Terminal term(match);
            lr_push(new_st, Product(term, el_id, pos));
            bytes_eaten = 0;
            return true;
        }

        @if(opts.debug) {@
            std::cerr << "no\n";
        @}@
        return false;
    }

    inline bool shift_NONTERM_PRODUCTION(
        const std::string &, int el_id, State new_st
    ) {
        @if(opts.debug) {@
            std::cerr << stringformat(
                "maybe shift {} to {}? ",
                element_str(el_id), state_to_str(new_st)
            );
        @}@
        if(last_product && el_id == last_product.grammar_element_id()) {
            @if(opts.debug) {@
                std::cerr << "yes\n";
            @}@
            lr_push(new_st, last_product);
            last_product = Product();
            return true;
        }
        @if(opts.debug) {@
            std::cerr << "no\n";
        @}@
        return false;
    }

    inline bool shift_LACK_OF_SEPARATOR(
        const std::string &, int el_id, State new_st
    ) {
        if(!bytes_eaten) {
            Terminal term("⦑lack-of-separator⦒");
            lr_push(new_st, Product(term, el_id, position()));
            return true;
        }
        return false;
    }

public:

    typedef enum {
        @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
            @declare el: prds.elements[el_id]@
            @prds.element_id_name(el_id)@, // @el_id@ @el.to_str()@
        @-}-@
    } ElementID;

    // deprecated.  use element_str instead (which handles terminals
    // as well)
    static std::string nonterm_str(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @declare el: prds.elements[el_id]@
                @if(el.type == grammar_element::NONTERM_PRODUCTION) {-@
                    case @el_id@: return "@el.nonterm_id_str()@";
                @}-@
            @-}-@
        }
        return std::to_string(id) + " is not a nonterm.";
    }

    // returns a string describing the element matching the ID
    // passed. this is for debugging.
    static std::string element_str(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @declare el: prds.elements[el_id]@
                case @el_id@: return "@c_str_escape(el.expr)@";
            @-}-@
        }
        return stringformat("¡unknown element id {}!", id);
    }

    static bool is_terminal(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @if(prds.elements[el_id].is_terminal()) {-@ 
                    case @el_id@: return true;
                @} else {-@
                    case @el_id@: return false;
                @}-@
            @-}-@
        }
        fprintf(stderr, "invalid terminal id: %i\n", id);
        return false;
    }

    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh
        @for(auto st: prds.states) {-@
            if(&@prds.state_fn(st, true)@ == st) return "@prds.state_fn(st)@";
        @}@
        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    static const char *state_string(State st) {
        @for(auto st: prds.states) {-@
            if(&@prds.state_fn(st, true)@ == st) {
                return "@prds.state_fn(st, false)@:\n"
                       @st.to_str(&prds, "\"    ", "\\n\"\n", true)@;
            }
        @}@
        return "<invalid state>";
    }

    static bool is_goal(int id) {
        switch(id) {
            @for(auto gstr : prds.goal) {-@
                case ElementID::_@gstr@: return true;
            @}@
            default: return false;
        }
        return false;
    }

    static size_t separator_length(const utf8_byte *inp) {
        @if(prds.separator_code.size() == 0) {-@
            return space_length(inp);
        @}-@

        @for(auto sepc : prds.separator_code) {-@
            @sepc.format_scoped()@
        @}-@

        @/* catchall: if nothing returned a length yet, no separator */@
        return 0;
    }

    size_t eat_separator() {
        bytes_eaten += reader->eat_separator(separator_length);
        return bytes_eaten;
    }

    // reduction rules:
    @for(auto rule : prds.rules) {@
        @#fpl_x_parser_reduce_action(prds, rule)@
    @}@

    // parser states:
    @for(productions::lr_set state : prds.states) {@
        @#fpl_x_parser_state(prds, state, prds.opts)@
    @}@


};

#endif // header guard

@if(opts.generate_main || prds.default_main) {@
    @#fpl_default_main(prds)@
@} else if(prds.main_guts) {@
    int main(int argc, const char **argv) {
        @prds.main_guts.format()@
    }
@}@

