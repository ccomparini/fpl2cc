@parameter: const productions &prds @
@parameter: const fpl_options &opts @
@declare class_name: prds.parser_class_name()@
@realign: #line {} "{}" @

#ifndef @class_name@_H
#define @class_name@_H

/*
  generated by fpl2cc @opts.version()@ from @source.filename()@

  options:
    @opts.to_str()@

  calculated goal(s):
    @prds.goal@
 */

@for(auto fn : opts.impl_sources) {@
    @code_block::from_file(fn, opts.src_path, "(command line)", 1).format()@
@}@

#include <array>
#include <cstdint>
#include <regex>
#include <stdlib.h>
#include <string>
#include <typeindex>
#include <typeinfo>
#include <variant>
#include <vector>

#include "fpl2cc/fpl_reader.h"
#include "util/jerror.h"
#include "util/src_location.h"
#include "util/stringformat.h"

@if(prds.preamble.size()) {@
    @for(auto pre : prds.preamble) {@
        @pre.format()@
    @}@
@}@

class @class_name@ {
public:
    void state(); // this just facilitates the "using State"
    using State = decltype(&@class_name@::state);

    class Terminal {
        // the first string in "matches" is the entire terminal match
        // and will exist for exact matches as well as regex matches.
        // subsequent matches are used for capture groups in a regex
        // match.
        std::vector<std::string> matches;
    public:

        Terminal() { } // false valued terminal

        Terminal(const std::string &src, const std::string &caller = CALLER()) {
            matches.push_back(src);
        }


        template<typename Iter>
        Terminal(Iter begin, Iter end) : matches(begin, end) {
        }

        std::string to_str() const {
            if(matches.size())
                return matches[0];
            return "";
        }

        // returns a string containing the contents of the regex capture
        // group indicated by the index passed.
        // for example, if the regex /(.)y(.*)/ matched the string "dyad",
        // capgroup(0) would be "d" and capgroup(1) would be "ad".
        // default is the 0th capgroup.
        // returns the empty string for any non-existent capture groups.
        std::string capgroup(int capi = 0) const {
            if(capi + 1 < matches.size()) {
                return matches[capi + 1];
            }
            return "";
        }

        operator bool() const {
            return matches.size() > 0;
        }

        operator std::string() const { return to_str(); }

        std::string operator+(const std::string & rhs) const {
            return to_str() + rhs;
        }
    };

    class Product {
        struct false_product { };
        using Var = std::variant<
            false_product,
            @-for(auto type : prds.all_types) {-@
                @type@,
            @-}-@
            Terminal
        >;

        Var red;

    public:
        // creates a false-valued Product:
        Product() : red(false_product()) { }

        Product(Terminal tm) : red(tm) { }

        // type-specific constructors:
        @-for(auto type : prds.all_types) {-@
            Product(@type@ result) : red(result) { }
        @-}-@

        const Var &var() const { return red; }

        operator bool() const {
            return !std::holds_alternative<false_product>(red);
        }


        std::string type_name() const {
            if(std::holds_alternative<false_product>(red))
                return "<no type>";

            if(std::holds_alternative<Terminal>(red))
                return "Terminal";

            @-for(auto type : prds.all_types) {-@
                if(std::holds_alternative<@type@>(red))
                    return "@type@";
            @-}-@
            // can't get here?
            jerror::error("Unknown type for product");
            return "unknown type";
        }

        std::string var_str() const {
            if(std::holds_alternative<false_product>(red))
                return "<null product>";

            if(std::holds_alternative<Terminal>(var()))
                return stringformat("{}", std::get<Terminal>(var()));

            @-for(auto type : prds.all_types) {-@
                if(std::holds_alternative<@type@>(var())) {
                    // using stringformat here because it supports
                    // several ways of converting to string:
                    return stringformat("{}", std::get<@type@>(var()));
                }
            @-}@

            jerror::error("Unknown type for product");
            return "unknown type";
        }

        // this is for debug and similar:
        std::string to_str() const {
            std::string out;
            return stringformat("{} «{}»", type_name(), var_str());
        }

        // phase out if possible, because this only supports the
        // top reduce_type and that's wacky.
        @prds.reduce_type@ val(const std::string &caller = CALLER()) const {
            if(!std::holds_alternative<@prds.reduce_type@>(red)) {
                jerror::error(stringformat(
                    "FAILULAR: product holds type {} and not @prds.reduce_type@ at {}\n",
                    type_name(), caller
                ));
                @prds.reduce_type@ dummy;
                return dummy;
            }
            return std::get<@prds.reduce_type@>(red);
        }

        std::string capgroup(int capi) const {
            if(std::holds_alternative<Terminal>(red))
                return std::get<Terminal>(red).capgroup(capi);
            return "";
        }
    };

    // This is an lr stack entry (as opposed to a param stack entry).
    // In the new dual stack scheme, you would use one of these to
    // refer to the param stack, however.
    struct StackEntry {
        State          state;
        int            element_id;
        SourcePosition pos;        // start of match in source code
        int            param_ind;  // offset in param_stack

        StackEntry(State st, int el_id, SourcePosition p, int pind) :
            state(st),
            element_id(el_id),
            pos(p),
            param_ind(pind) {
        }

        // creates a "false" stack entry:
        StackEntry() : state(NULL), element_id(-1), param_ind(0) {
        }

        StackEntry(const StackEntry &) = default;

        operator bool() const {
            return state != NULL;
        }

        int grammar_element_id() const {
            return element_id;
        }

        SourcePosition position() const {
            return pos;
        }

        int line_number() const {
            return position().line_number();
        }

        std::string filename() const {
            return position().filename();
        }

        bool is_nonterminal() const {
            return @class_name@::is_nonterminal(element_id);
        }

/*
XXX
kill:  this no longer makes sense;  products are in the argument stack.
but, this is used in rewind, which is interesting and indicates bugs
because what if there are multiple products?
probably need to make the argument stack 3 point.
 */
        Product product(const @class_name@ &owner) const {
            if(param_ind >= 0 && param_ind < owner.param_stack.size()) {
                return owner.param_stack[param_ind];
            }
            return Product();
        }

        std::string to_str() const {
            return stringformat("{} {} param[{}] ({})",
                state_to_str(state),
                element_str(element_id),
                param_ind,  // need the owner to get the product
                position()
            );
        }
    };

    // Pushes an element to the lr or parameter stacks as appropriate.
    // "ejected" elements (those marked with a '^' in fpl source) are
    // not pushed to the param stack.
// XXX ALSO maybe don't push to lr if doing so would be redundant.
// but how to tell?
    void lr_push(
        int element_id, bool eject, const SourcePosition &pos, Product pr
    ) {
        lr_stack.push_back(StackEntry(
            cur_state, element_id, pos, param_stack.size()
        ));

        if(!eject) {
            param_stack.push_back(pr);
        }
    }

private:
    fpl_reader_p            reader;      // (must be non-null)
    State                   cur_state;
    int                     last_product_id; // (element id)
    Product                 last_product;
    std::vector<StackEntry> lr_stack;
    int                     lr_frame_start;  // during current reduce call
    std::vector<Product>    param_stack;
    size_t                  bytes_eaten; // since last terminal
    bool                    stop_parsing;
    int                     max_errors;
    int                     num_errors;

    bool                    single_step; // debugging

    // this is called when something appears to have
    // gone wrong due to a bug in the parser itself:
    void internal_error(const std::string &msg) {
        error(stringformat(
            "\nInternal error: {}\nstate:\n{}\n", msg, to_str()
        ));
        terminate();
    }

public:
    // constructors:
    @class_name@(const @class_name@ &rhs) = delete;

    @class_name@(fpl_reader_p rdr) :
        reader(rdr),
        cur_state(&@class_name@::state_0),
        last_product_id(0),
        lr_frame_start(0),
        bytes_eaten(0),
        stop_parsing(false),
        max_errors(1),
        num_errors(0),
        single_step(false) {

        @if(opts.single_step) {@
            set_single_step(true);
        @}@

        // reserve more than we'll need so we don't have to realloc:
// XXX check what happens when this overflows
        lr_stack.reserve(1000);
        param_stack.reserve(1000);
    }

    // debugging:
    void set_single_step(bool newval) { single_step = newval; }
    void debug_pause() {
        int inch;
        if(single_step)
            inch = getchar();
        if(inch == 'c')
            single_step = false;
    }

    void set_max_errors(int newmax) { max_errors = newmax; }

    void error(size_t pos, const std::string &msg) {
        std::string full_msg = reader->format_error_message(pos, msg);
        fputs(full_msg.c_str(), stderr);
        if(++num_errors > max_errors) {
            fputs("too many errors.  aborting\n", stderr);
            terminate();
        }
    }

    void error(const std::string &msg) {
        error(reader->current_position(), msg);
    }

    int error_count() const { return num_errors; }

    bool eof() const {
        return reader->eof();
    }

public:

    std::string filename() const {
        return reader->filename();
    }

    int line_number() const {
        return reader->line_number();
    }

    int line_number(size_t pos) const {
        return reader->line_number(pos);
    }

    SourcePosition position() const {
        return SourcePosition(reader);
    }

    fpl_reader_p_c const_reader() const {
        return reader;
    }

    int param_stack_size() const {
        return param_stack.size();
    }

    int lr_stack_size() const {
        return lr_stack.size();
    }

    int lr_top_index() const {
        return lr_stack.size() - 1;
    }

    void lr_pop() {
        if(lr_stack.size() > 0) {
            auto popped = lr_stack.back();
            cur_state = popped.state;
// XXX OHHHH make sure that this doesn't kill extra items off the param stack
// if we are popping (say) an ejected or optional step (in which case there
// can be multiple lr entries with the same parem_ind.  Might be working
// now simply because we're not hitting that case.
// like, don't pop if the new top has the same position as the popped.
// but make a test first.
            if(popped.param_ind >= 0) {
                param_stack.resize(popped.param_ind);
            }
            lr_stack.pop_back();
        }

        if(lr_stack.size() == 0) {
            // else there's nothing left to pop on the lr_stack,
            // and the param stack had better be clear, too, or
            // something is wrong:
            if(param_stack.size() > 0) {
                jerror::warning(stringformat(
                    "popping from empty lr_stack, but there are {} params\n",
                    param_stack.size()
                ));
            }
        }
    }

    // "pops" and discards down to the new maximum index
    // specified
    void lr_pop_to(int new_max) {
        while(lr_top_index() > new_max) {
            lr_pop();
        }
    }

    StackEntry lr_stack_entry(int pos) const {
        if((pos >= 0) && (pos < lr_stack_size())) {
            return lr_stack[pos];
        } else {
            return StackEntry();
        }
    }

    StackEntry lr_top() const {
        return lr_stack_entry(lr_top_index());
    }

    // lr_position_before_XXX(pos, multiple):  returns the first
    // position before pos in the lr stack which does not match
    // the element ID in question.  Recurses on subexpressions.
    @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
        @declare element: prds.elements.at(el_id)@
        @declare elname: prds.element_id_name(el_id)@
        @declare subrule_num:  prds.subrulenum_for_el(element)@
        int lr_position_before_@elname@(int pos, bool multiple) const {

            @if(subrule_num < 0) {@
                // normal case - not a subexpression
                // XXX whhhy does the NULL element match el ID 6?
                // (checking pos >= 0 because of that.  in theory,
                //  shouldn't have to check)
                while(pos >= 0 && lr_stack_entry(pos).element_id == @el_id@) {
                    --pos;
                    if(!multiple)
                        break;
                }
            @} else {@
                @declare subrule: prds.rules[subrule_num]@
                //   @subrule.to_str()@
                int subp = pos;
                int lastp;
                bool matched_whole = true;
                while(subp >= 0) {
                    @for(int sti = subrule.num_steps() - 1; sti >= 0; --sti) {@
                        @declare substep: subrule.nth_step(sti)@
                        @declare sename: prds.element_id_name(substep.gexpr)@
                        @declare mult: substep.qty.multiple@
                        @declare req: !substep.qty.optional@
                        lastp = subp;
                        subp = lr_position_before_@sename@(subp, @mult@);
                        if(@req@ && lastp == subp) matched_whole = false;
                    @}@
                    if(matched_whole)
                        pos = subp;
                    else
                        break;
// XXX what if not multiple?
// add test
                }
            @}@

            return pos;
        }
    @}@

    // lr_count_of_X(pos, multiple):  returns the number of
    // stack entries matching X going forward through the lr stack,
    // starting at the position passed.   If argument "multiple"
    // is false, only counts up to one entry.
    @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
        @declare element: prds.elements.at(el_id)@
        @declare elname: prds.element_id_name(el_id)@
        @declare subrule_num:  prds.subrulenum_for_el(element)@
        int lr_count_of_@elname@(int pos, bool multiple) const {
            int size = 0;
            @if(subrule_num < 0) {@
                // normal case - not a subexpression
                while(lr_stack_entry(pos + size).element_id == @el_id@) {
                    ++size;
                    if(!multiple)
                        break;
                }
            @} else {@
                @declare subrule: prds.rules[subrule_num]@
                //   @subrule.to_str()@
                int subp = pos;
                bool matched_whole = true;
                while(subp < lr_stack_size()) {
                    int ssize = 0; // size of substep
                    int msize = 0; // size of subexpression match
                    @for(int sti = 0; sti < subrule.num_steps(); ++sti) {@
                        @declare substep: subrule.nth_step(sti)@
                        @declare sename: prds.element_id_name(substep.gexpr)@

                        ssize = lr_count_of_@sename@(
                            subp, @substep.qty.multiple@
                        );

                        if(@!substep.qty.optional@ && ssize == 0)
                            matched_whole = false;

                        subp  += ssize;
                        msize += ssize;
                    @}@

                    if(matched_whole) {
                        size += msize;
                    } else {
                        break;
                    }

                    if(!multiple) {
                        break;
                    }
                }
            @}@

            return size;
        }
    @}@

    // A StackSlice here is a set of 0 or more consecutive lr_stack
    // entries. It's used to represent the match(es) which went into
    // 1 particular step (see ReductionParameter, below), or the set
    // of all steps which led to a current rule match (see
    // all_matched_steps(), below), or any other slice of the lr_stack.
    class StackSlice {
        int base_index; // in lr_stack
        int size;       // also in lr_stack

        // owner here is annoying because we should be able to
        // infer it... jest feature?
        const @class_name@ &owner;

    public:
        // returns the number of lr_stack entries in this slice:
        int count() const { return size; }

        // returns the number of parameter stack entries for this
        // entire slice.
        int param_count() const {
            StackEntry sel = owner.lr_stack_entry(base_index);

            // this slice "contains" all arguments starting
            // at the position in the argument stack starting
            // at the argument from the base element and going
            // to just before the one for the base element of
            // the slice above us, or the top of the argument
            // stack if we're the topmost slice
            int cap_ind = base_index + size;
            if(cap_ind < owner.lr_stack_size()) {
                StackEntry eel = owner.lr_stack_entry(cap_ind);
                return eel.param_ind - sel.param_ind;
            } else {
                // goes to the end of the arg stack:
                return owner.param_stack_size() - sel.param_ind;
            }
        }

        // returns the corresponding base in the param stack
        // or -1 if there is no such thing.
        int param_base() const {
            return owner.lr_stack_entry(base_index).param_ind;
        }

        // construct a slice with a particular base and count.
        // if the count is -1 or unspecified, construct a slice
        // with the given base to the top of the stack
        StackSlice(@class_name@ &o, int base, int count = -1) :
            base_index(base),
            size(count),
            owner(o)
        {
            if(size == -1) {
                size = owner.lr_stack.size() - base;
            }
        }

        // Negative indexes are offset from a hypothetical argument
        // just past the end of the slice (i.e. -1 means end-of-slice).
        // Accessing to entries outside the slice yields a "false"
        // stack entry.
        StackEntry operator [](int ind) const {
            if(ind < 0) ind += size; // allow negative indexes

            int off = ind + base_index;
            if((off < owner.lr_stack_size()) && (off >= 0)) {
                return owner.lr_stack[off];
            } else {
                return StackEntry();
            }
        }

        // Returns the nth "product" (from the argument stack)
        // corresponding to this slice.
        // If the index passed is out of bounds, returns a 
        // default product.
        // Note that there may be 0 products for any slice,
        // so the 0th is not guaranteed to be anything real.
        Product product(int ind = 0, src_location caller = CALLER()) const {
            const int num_args = param_count();
            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind >= 0) && (ind < num_args)) {
                unsigned int sind = param_base() + ind;
                return owner.param_stack_entry(sind, caller);
            } else {
                return Product();
            }
        }

        inline std::string to_str() const {
            std::string out;
            for(int ind = 0; ind < size; ++ind) {
                out += stringformat("    {}\n", owner.lr_stack[ind]);
            }
            return out;
        }
    };

    // Call this within a reduce function to get a stack slice containing
    // all the steps (StackEntries) for the matched rule.
    // Don't call from outside a reduce function.
    StackSlice all_matched_steps() {
        return StackSlice(*this, lr_frame_start);
    }

    // call this like:  prod_type_name(typeid(...));
    static std::string prod_type_name(const std::type_info &tinf) {
        @-for(auto type : prds.all_types) {@
            if(std::type_index(typeid(@type@)) == std::type_index(tinf)) {
                return "@type@";
            }
        @}@
        if(std::type_index(typeid(Terminal)) == std::type_index(tinf)) {
            return "Terminal";
        }
        if(std::type_index(typeid(Product)) == std::type_index(tinf)) {
            return "Product";
        }
        return "unknown type in prod_type_name";
    }

    // This represents the argument for a given step, which should be one
    // lr stack entry plus a (possibly 0-sized) slice of the param stack
    template<typename ReduceType>
    class ReductionParameter {
        // all access to param and lr stacks go through this:
        StackSlice lr_slice;

    public:
        ReductionParameter(@class_name@ &o, int lr_base, int lr_count) :
            lr_slice(o, lr_base, lr_count) { }

        // returns the number of param_stack entries in this:
        int count() const { return lr_slice.param_count(); }

        // (syntactic sugar for optionals)
        bool exists() const { return count() !=  0; }

        SourcePosition position() const {
            return lr_slice[0].position();
        }

        SourcePosition end_position() const {
            return lr_slice[-1].position();
        }

        // this allows you to refer to the stack slice itself from within
        // reduce functions using the at sign (eg thing@@self())
        ReductionParameter<ReduceType> self() { return *this; }

        // in reduce code, this is accessed via [] or (for the 0th element)
        // just the name of the variable itself.
        const ReduceType val(int ind = 0, src_location ca = CALLER()) const {
            const int num_args = count();

            if(ind < 0) ind += num_args; // negative = relative to end + 1 

            if((ind < 0) || (ind >= num_args)) {
                jerror::warning(stringformat(
                    "Index {} out of range ({} items) at {}",
                    ind, num_args, ca
                ));

                // try to return a default item of the ReduceType.
                // this may or may not be possible, depending on the
                // type, but it's better than crashing.
                return ReduceType();
            }

            return std::get<ReduceType>(
                lr_slice.product(ind, ca).var()
            );
        }

        static std::string type_name() {
            return prod_type_name(typeid(ReduceType));
        }

        std::string concatenate() const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                out += to_string(val(ind));
            }
            return out;
        }

        // XXX we pass the Product here so that callers can get at
        // line numbers etc, but ... oh that's outdated.
        // See if we can jsut pass ReduceType
        using ForeachFunc = std::function<void(const Product &)>;
        void foreach(ForeachFunc func) const {
            for(int ind = 0; ind < count(); ++ind) {
                func(lr_slice.product(ind));
            }
        }

        std::string join(const std::string &jv) const {
            std::string out;
            for(int ind = 0; ind < count(); ind++) {
                if(ind < count() - 1)
                    out += stringformat("{}{}", val(ind), jv);
                else // last element
                    out += stringformat("{}", val(ind));
            }
            return out;
        }

        inline std::string to_str() const {
            // XXX do something smarter here
            return lr_slice.to_str();
        }
    };

    void set_product(int element_id, const Product &pr) {
        if(last_product) {
            // if this happens, it's almost certainly a bug in fpl2cc
            // since it means we're setting a new product without having
            // shifted whatever nonterm product was next up..
            internal_error(stringformat(
                "splatting last_product ({}) with {}\n",
                last_product, pr
            ));
        }
        last_product_id = element_id;
        last_product    = pr;
    }

    void set_state(State st) {
        cur_state = st;
    }

    void clear_product() {
        last_product_id = 0;
        last_product    = Product();
    }

    Product param_stack_entry(int pos, src_location caller = CALLER()) const {
        // this is very similar to lr_stack_entry.  generalize?
        if((pos >= 0) && (pos < param_stack.size())) {
            return param_stack[pos];
        } else {
            jerror::warning(stringformat(
                "param stack access out of range ({}/{}) at {}",
                pos, param_stack.size(), caller
            ));
            return Product();
        }
    }

    State current_state() const {
        return cur_state;
    }

    // this is more or less debugging
    std::string to_str() const {
        std::string out;

        out += stringformat("next up: {}\n", next_up_str());
        out += stringformat(
            "{} bytes of separator since last terminal\n", bytes_eaten
        );
        out += stringformat("lr stack ({} items):\n", lr_stack.size());
        for(int sind = lr_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
                "    [{}] {}\n", sind, lr_stack_entry(sind)
            );
        }
        out += stringformat("param stack ({} items):\n", param_stack.size());
        for(int sind = param_stack.size() - 1; sind >= 0; --sind) {
            out += stringformat(
                "    [{}] {::n}\n", sind, param_stack_entry(sind)
            );
        }
        return out;
    }

    const Product &result() const {
        return last_product;
    }


    void terminate() {
        stop_parsing = true;
    }

    // rewind to the point just after the last nonterminal.
    // this is used after termination to unwind such that the
    // read position is just after the last successfully parsed
    // thing instead of potentially being after some recognized
    // but unused terminals, thus setting the read pointer to
    // the start of any unrecognized input.
    void rewind_to_nonterm() {
        if(last_product)
            return; // already after last nonterminal

        size_t rewind_to = reader->current_position();
        while(lr_stack.size() > 0) {
            auto last = lr_stack.back();
            if(last.is_nonterminal()) {
                last_product_id = last.element_id;
                last_product    = last.product(*this);
                break;
            }
            rewind_to = last.position();
            lr_pop();
        }
        reader->go_to(rewind_to);

    }

    // returns a string with either the next bit of text
    // (in French quotes) or the next production
    std::string next_up_str() const {
        if(last_product_id) {
            return stringformat(
                "{} = {::n}", element_str(last_product_id), last_product
            );
        } else {
            return stringformat(
                "«{}» ({}:{::n})",
                reader->debug_peek(32),
                reader->filename(), reader->current_position()
            );
        }
    }

    // not passing by reference here - instead, crossing fingers
    // and hoping it really just gets inlined.
    inline void post_parse(@prds.reduce_type@ result) {
        @if(prds.post_parse) {@
            @prds.post_parse.format()@
        @}@
    }

    bool more_to_parse() const {
        // there's more to parse if:
        //  - we haven't been told to stop (due to errors or whatever)
        //  - and there's more input -or- we're not at the goal
        return !stop_parsing
            && ((!eof() || lr_stack.size() > 0) || !result_is_goal());
    }

    // resets the state of the parser, discarding anything on
    // the stack.
    // does _not_ reset the input position, so as to allow
    // mixed-parser parses.
    void reset() {
        @if(opts.debug) {@
            std::cerr << "resetting @class_name@!!!\n";
        @}@
        lr_stack.clear();
        set_state(&@class_name@::state_0);
        last_product_id  = 0;
        last_product     = Product();
        bytes_eaten      = 0;
        stop_parsing     = false;
        num_errors       = 0;
    }

    // In an fpl parser, we do not want to require that the whole
    // input has been consumed.  this allows piecewise parsing.
    // for example, a top down parser can invoke an fpl parser
    // to handle some class of expressions, receive the result,
    // and then continue parsing whatever it was parsing, or
    // you're parsing a stream of input, and you want to parse
    // it as it comes in instead of all at once after getting
    // the entire thing.
    //
    // So, this parses as much as it can, then leaves the parser
    // as intact as possible so that the caller can examine it
    // for errors or whatever and decide what to do.
    //
    void parse_partial() {
        do {
            State st = current_state();
            (this->*st)();
        } while(more_to_parse());
    }

    // Attempts to parse a goal from the current input.
    // If we didn't parse a goal, input remains at the
    // position from the start of parse.
    // Any additional input after the goal is left and may be
    // parsed with additional passes of this or another parser.
    // If whatever we parsed was a goal, we return that and
    // reset the result to a false product.   Otherwise,
    // we return a false product.
    const Product parse_goal() {
        reset();
        parse_partial();
        rewind_to_nonterm();
        if(result_is_goal()) {
            Product got = result();
            clear_product();
            return got;
        }
        return Product();
    }

    // Parses the contents of the current reader.
    // Input contents are assumed to be complete.
    // Calls error() if any parse errors were detected.
    // Returns whatever it got, regardless of errors,
    // which might mean returning a default of whatever
    // the reduce type is.
    //  (a lot of the internal logic here is questionable, at this point)
    @prds.reduce_type@ parse() {
        // we're parsing from initial state...
        reset();

        // errors should be handed up to the caller somehow,
        // but for now I'm going to let callers use parse_partial
        // and figure out errors if that's what they want.

        parse_partial();
        Product got = result();

        // consume any additional "separators" (eg whitespace,
        // comments) before checking if we're at end of input:
        eat_separator();

        // In this case, we're assuming we have the entire input.
        // So, we expect:
        //   - we're at eof (end of input)
        //   - nothing left on the stack
        //   - result is a goal
        std::string errm;
        if(!eof()) {
            // If we're not at end of input, we stopped when we
            // didn't recognize something.  If there's currently 
            // a "result", that's what was unexpected (i.e. it
            // recognized something, but that something didn't
            // fit the bigger picture).  Otherwise, it means we
            // got some generally unrecognized input:
            std::string message;
            if(got) {
                errm = stringformat(
                    "unexpected {} ({})", element_str(last_product_id), got
                );
            } else  {
                errm = "unrecognised input";
            }
            error(message);
        } else if(lr_stack_size() > 0) {
            // there's stuff on the stack after we rewound,
            // it means we recognized more than one component,
            // but nothing complete.
            errm = "incomplete input";
        } else if(!result_is_goal()) {
            errm = stringformat(
                "parsed a {} = {}, but that's not a goal (@prds.goal@)",
                element_str(last_product_id), got
            );
        }

        if(errm.length()) {
            error(stringformat(
                "{}\n"
                "here's what we have so far:\n{}"
                "{} and state was:\n{}\n",
                errm, StackSlice(*this, 0),
                next_up_str(),
                state_string(current_state())
            ));
        }

        post_parse(got.val());

        return got.val();
    }

private:

    @for(auto mem : prds.parser_members) {@
        @mem.format()@
        // return to "private" after each such block.
        // this way, authors can add public members
        // to the parser without turning other stuff public 
        private:
    @}@

    @/* custom scanners:
        these are expected to return something iterable.
        an empty iterable indicates no match; otherwise
        the generated Terminal will contain the items
        returned.
    */@
    @for(auto &[scanner_name, scanner_code] : prds.scanners) {@
        #line @scanner_code.line@ "@scanner_code.source_file@"
        auto custom_scanner_@scanner_name@(fpl_reader &input) {
            @scanner_code.format()@
        }
    @}@

    @/* "shift" methods.  these check for the relevant element and,
        if there's a match, change the state to the state passed.
    */@
    @for(auto element : prds.elements) {@
        @if(element.is_nonterminal()) {@
            @#fpl_x_parser_shift_nonterm(prds, element, opts)@
        @} else {@
            // (terminals and assertions - everything else)
            @#fpl_x_parser_shift_term(prds, element, opts)@
        @}@
    @}@
    @#fpl_x_parser_shift_none(prds, grammar_element(), opts)@

public:

    typedef enum {
        @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
            @declare el: prds.elements[el_id]@
            @prds.element_id_name(el_id)@, // @el_id@ @el.to_str()@
        @-}-@
    } ElementID;


    // returns a string describing the element matching the ID
    // passed. this is for debugging.
    static std::string element_str(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @declare el: prds.elements[el_id]@
                case @el_id@: return "@c_str_escape(el.expr)@";
            @-}-@
        }
        return stringformat("¡unknown element id {}!", id);
    }

    static bool is_nonterminal(int id) {
        switch(id) {
            @for(int el_id = 0; el_id < prds.elements.size(); ++el_id) {-@
                @if(prds.elements[el_id].is_nonterminal()) {-@ 
                    case @el_id@: return true;
                @} else {-@
                    case @el_id@: return false;
                @}-@
            @-}-@
        }
        fprintf(stderr, "invalid terminal id: %i\n", id);
        return false;
    }

    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh
        @for(int st = 0; st < prds.num_states(); st++) {-@
            if(&@prds.state_fn(st, true)@ == st) return "@prds.state_fn(st)@";
        @}@
        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    static const char *state_string(State st) {
        @for(int st = 0; st < prds.num_states(); st++) {-@
            if(&@prds.state_fn(st, true)@ == st) {
                return "@prds.state_fn(st, false)@:\n"
                       @prds.states.at(st).to_str(
                           &prds, "\"    ", "\\n\"\n", true
                       )@;
            }
        @}@
        return "<invalid state>";
    }

    static bool is_goal(int el_id) {
        switch(el_id) {
            @for(auto gstr : prds.goal) {-@
                case ElementID::_@gstr@: return true;
            @}@
            default: return false;
        }
        return false;
    }

    bool result_is_goal() const {
        return is_goal(last_product_id);
    }

    static size_t separator_length(const utf8_byte *inp) {
        @if(prds.separator_code.size() == 0) {-@
            return space_length(inp);
        @}-@

        @for(auto sepc : prds.separator_code) {-@
            @sepc.format_scoped()@
        @}-@

        @/* catchall: if nothing returned a length yet, no separator */@
        return 0;
    }

    size_t eat_separator() {
        bytes_eaten += reader->eat_separator(separator_length);
        return bytes_eaten;
    }

    // reduction rules:
    @for(auto rule : prds.rules) {@
        @if(!rule.is_subexpression()) {@
            @#fpl_x_parser_reduce_action(prds, rule)@
        @}@
    @}@

    // parser states:
    @for(int stn = 0; stn < prds.num_states(); stn++) {@
        @#fpl_x_parser_state(prds, prds.states.at(stn), prds.opts)@
    @}@

};

#endif // header guard

@if(opts.generate_main || prds.default_main) {@
    @#fpl_default_main(prds)@
@} else if(prds.main_guts) {@
    int main(int argc, const char **argv) {
        @prds.main_guts.format()@
    }
@}@

