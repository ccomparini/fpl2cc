@parameter: const productions &prds @
@parameter: const options &opts @

#ifndef @ prds.parser_class_name() @_H
#define @ prds.parser_class_name() @_H

/*
  generated by fpl2cc

  options:
    @opts.to_str()@

  calculated goal(s):
    @prds.goal@
 */

// impl_sources things go here... what even is it?
@for(auto fn : opts.impl_sources) {@
    @code_block::from_file(fn, opts.src_path, "(command line)", 1).format()@
@}@
// finished impl_sources things

#include <string>
#include "fpl2cc/fpl_reader.h"
#include "fpl2cc/fpl_base_parser.h"

@if(prds.preamble.size()) {@
    @for(auto pre : prds.preamble) {@
        @pre.format()@
    @}@
@}@

class @ prds.parser_class_name() @ {

public:
    // state() and reduce_type tell FPLBaseParser what types to use
    void state();
    int error_count() { return base_parser.error_count(); }
    static @prds.reduce_type@ reduce_type;

private:
    using FPLBP = FPLBaseParser<@ prds.parser_class_name() @>;
    using State = FPLBP::State;
    using Product = FPLBP::Product;
    using StackEntry = FPLBP::StackEntry;
    FPLBP base_parser;

    @for(auto mem : prds.parser_members) {@
        @mem.format()@
        // return to "private" after each such block.
        // this way, authors can add public members
        // to the parser without turning other stuff public 
        private:
    @}@

public:
    @ prds.nonterm_enum() @
    static std::string state_to_str(State st) {
        if(!st) return "NULL";
        // c++ won't let you compare pointers in a switch statement.. sigh
        @for(auto st: prds.states) {@
            if(&@prds.state_fn(st, true)@ == st) return "@prds.state_fn(st)@";
        @}@
        // if we got here, the State (pointer) passed doesn't match any
        // of our state functions:
        return "<not a state>";
    }

    static const char *state_string(State st) {
        @for(auto st: prds.states) {@
            if(&@prds.state_fn(st, true)@ == st) {
                return "@prds.state_fn(st, false)@:\n"
                       @st.to_str(&prds, "\"    ", "\\n\"\n", true)@;
            }
        @}@
        return "<invalid state>";
    }

    static bool is_goal(int id) {
        switch(id) {
            @for(auto gstr : prds.goal) {@
                case NontermID::_@gstr@: return true;
            @}@
            default: return false;
        }
        return false;
    }

    @ prds.separator_method().format() @
    @ prds.eat_separator_code() @

    // reduction rules:
    @for(auto rule : prds.rules) {@
        @prds.reduce_action(rule).format()@
    @}@

    // parser states:
    @for(productions::lr_set state : prds.states) {@
        @prds.code_for_state(state)@
    @}@

    @prds.parser_class_name()@(fpl_reader_p src) : base_parser(src) {
        @if(opts.single_step) {@
            base_parser.set_single_step(true);
        @}@
    }

    std::string to_str() { return base_parser.to_str(); }
    inline @prds.reduce_type@ parse() {
        auto result = base_parser.parse(*this);

        @if(prds.post_parse) {@
            @prds.post_parse.format()@
        @}@

        return result;
    };
};

@if(opts.generate_main || prds.default_main) {@
    @prds.default_main_code()@
@} else if(prds.main_guts) {@
    int main(int argc, const char **argv) {
        @prds.main_guts.format()@
    }
@}@

#endif // header guard
