@parameter: const productions &prds @
@parameter: const grammar_element &el @
@parameter: const fpl_options &opts @
@declare el_id: prds.element_id_name(el)@
@declare el_str: c_str_escape(el.to_str())@
@declare match_str: c_str_escape(el.expr)@

// this creates a function named like:
//   shift_TERM_EXACT__terminal_X()
//   shift_TERM_REGEX__terminal_X()
//   shift_TERM_CUSTOM__terminal_X()
//   (etc - anything which is not a nonterminal)
// .. where X is the element ID number.
bool shift_@el.type_str()@_@el_id@(bool eject) {


    const SourcePosition pos = position();
    Terminal result;
    @if(el.type == grammar_element::TERM_EXACT) {@
        if(reader->read_exact_match("@match_str@")) {
            result = Terminal("@match_str@");
        }
    @} else if(el.type == grammar_element::TERM_REGEX) {@
        std::cmatch match = reader->read_re("@match_str@");
        @/* XXX bug:  if there's a 0-byte match but multiple
            is allowed, the parser ends up looping infinitely
            reading 0 bytes and saying "ok yeah that matched".
            Note: 0-byte match is considered not empty.
        */@
        if(!match.empty()) {
            result = Terminal(match.begin(), match.end());
        }
    @} else if(el.type == grammar_element::TERM_CUSTOM) {@
        auto match = custom_scanner_@el.expr@(*reader);
        if(match.size() > 0) {
            result = Terminal(match.begin(), match.end());
        }
    @} else if(el.type == grammar_element::LACK_OF_SEPARATOR) {@
        if(!bytes_eaten) {
            result = Terminal("⦑lack-of-separator⦒");
        }
    @}@

    if(result) {
        @if(opts.debug) {@
            std::cerr << "shifting @el_str@\n";
        @}@
        lr_push(@el_id@, eject, pos, Product(result));
        // assertions count as terminals.  therefore, clearing
        // bytes_eaten is (strictly speaking) correct, here.
        // but actually I think it's wrong in cases where
        // there may be more than one consecutive lack-of-separator.
        // also, we really have no idea if a TERM_CUSTOM moved
        // the input pointer or what.
        // possibly a better implementation would be to track
        // the position of the end of the last non-0-length
        // separator.
        bytes_eaten = 0;
        return true;
    }

    return false;
}

