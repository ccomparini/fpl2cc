@parameter: const productions &prds @
@parameter: const production_rule &rule @
@parameter: const fpl_options &opts @
@declare num_params: rule.parameter_count()@
@realign: #line {} "{}" @

@/*
 generates the call to the reduce function for the given rule.
*/@
    // we've matched something, and we're going to generate and
    // push a result, so first we need to clear any mismatches
    // from the top of the stack:
    clear_mismatches();

    // INTERESTING... now that we're tracking per-step reserves, we
    // -could- come up with the params in one (backward) pass, as
    // long as we change the reserve counts to go backward instead
    // of forward through the rule...

    @/* Figure out the stack slices for each argument.
        We have to do this outside the call because parameter evaluation
        order is not defined in c++ and we're (pseudo-)popping the stack.
        At the moment, we create a stack slice even for things we're
        not going to pass to the reduce function.
    */@
    @for(int stind = rule.num_steps() - 1; stind >= 0; --stind) {-@
        @declare step: rule.nth_step(stind)@
        @if(!step) {-@
            // If there's no such step, it's a bug in fpl
            #error Bug: no expression for step @stind@ @rule.to_str()@ @rule.location()@
        @-} else {-@
            @declare el_id: prds.element_id(step.gexpr)@
            @declare elname: prds.element_id_name(el_id)@

            lr_read_pos = lr_position_before_@elname@(
                lr_read_pos, @step.qty.multiple@
            );
        @}@
    @}@
    lr_read_pos++;  // (we went until just before the real frame start)

    @if(opts.debug) {-@
        std::cerr << stringformat(
            "reducing by {}  ({} steps, {} params)\n",
            "@c_str_escape(rule.to_str())@", // (rule might have {} in it)
            @rule.num_steps()@, @rule.parameter_count()@
        );
        std::cerr << stringformat(
            "all_matched_steps: {}\n", all_matched_steps()
        );
    @}@

    // Now that we know where the frame starts, we can go forward through
    // the stack to find the appropriate slices for our arguments.  We do
    // need to do this back-and-forth thing to get the arguments correct
    // for rules like: 
    //    foo:first foo*:rest -> bar ;
    int arg_start = lr_read_pos;
    int slice_size;
    @for(int stind = 0; stind < rule.num_steps(); ++stind) {-@
        @declare step: rule.nth_step(stind)@
        @if(!step) {-@
            // no step means there's a bug..
            #error no expression for step @stind@ @rule.to_str()@ @rule.location()@
        @-} else {-@
            @declare el_id: prds.element_index.at(step.gexpr)@
            @declare elname: prds.element_id_name(el_id)@

            slice_size = lr_count_of_@elname@(arg_start, @step.qty.multiple || step.reserve@);

            @if(step.reserve) {@
                // this step is followed by other steps with the same
                // expression but higher priority w/respect to parameters,
                // so we need to reserve @step.reserve@ matches for those
                // params. (example case: foo:a* foo:b -> bar;  need to
                // reserve 1 slot for the b)
                slice_size -= @step.reserve@;
                if(slice_size < 0)
                    slice_size = 0;
            @}@

            @if(!step.skip_on_reduce()) {@
                @/* here's where we declare the argument to pass */@
                ReductionParameter<@prds.type_for(step.gexpr)@>
                    arg_@stind@(*this, arg_start, slice_size);
                @if(opts.debug) {@
                    std::cerr << stringformat(
                        "arg @stind@ is {} @prds.type_for(step.gexpr)@\n",
                        arg_@stind@.count()
                    );
                @}@
            @}@
            arg_start += slice_size;
        @}-@
    @}-@

    @/* this is the call to the reduce code.  Note that here we just label
        all the parameters "arg_xxx" and don't worry about their "real" names.
    */@
    @-prds.type_for(rule.product())@ result = @prds.rule_fn(rule) -@ (
        @-for(int pind = 0; pind < num_params; pind++) {-@
            @- pind?",":"" -@ arg_@-rule.parameter_step_number(pind)-@
        @-}-@
    );

    @if(prds.post_reduce) {@ {
        @prds.post_reduce.format()@
    } @}@

    @declare result_el_id: prds.element_id_name(rule.product_element()) @
    Product prod(result);
    @if(opts.debug) {-@
        std::cerr << stringformat(
            "reduced to  @result_el_id@ = {}\n", prod
        );
    @}@

    @/* (must come before the pop or the position gets lost) */@
    auto src_pos = lr_stack_entry(lr_read_pos).position();

    @/*
        This is what actually pops the stack. Note we pop after
        the reduce - reduce functions refer to items in the param
        stack itself, and not copies. This also keeps the stack
        intact for dealing with errors/debug.
    */@
    lr_pop_to(lr_read_pos - 1);

    @/* ya know, if it weren't for potential side effects, it's
        possible we could get away with not even calling the
        reduce function in the eject case...
    */@
    bool eject = state_ejects(cur_state, @result_el_id@);
    lr_push(@result_el_id@, eject, src_pos, prod);

    @if(opts.debug) {-@
        std::cerr << stringformat("popped to {}\n", lr_top_index());
    @-}-@

