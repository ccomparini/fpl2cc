@parameter: const productions &prds @
@parameter: const production_rule &rule @
@parameter: const fpl_options &opts @
@declare num_params: rule.num_reduce_params()@
@realign: #line {} "{}" @

@/*
 generates the call to the reduce function for the given rule.
*/@
    // we've matched something, and we're going to generate and
    // push a result, so first we need to clear any mismatches
    // from the top of the stack:
    clear_mismatches();

    @/* Figure out the stack slices for each argument.
        We have to do this outside the call because parameter evaluation
        order is not defined in c++ and we're (pseudo-)popping the stack.
        At the moment, we create a stack slice even for things we're
        not going to pass to the reduce function.
    */@
    @for(int stind = rule.num_steps() - 1; stind >= 0; --stind) {-@
        @declare step: rule.nth_step(stind)@
        @if(!step) {-@
            // If there's no such step, it's a bug in fpl
            #error Bug: no expression for step @stind@ @rule.to_str()@ @rule.location()@
        @-} else {-@
            @declare el_id: prds.element_id(step.gexpr)@
            @declare elname: prds.element_id_name(el_id)@

            lr_read_pos = lr_position_before_@elname@(
                lr_read_pos, @step.qty.multiple@
            );
        @}@
    @}@
    lr_read_pos++;  // (we went until just before the real frame start)

    @if(opts.debug) {-@
        std::cerr << stringformat(
            "reducing by {}  ({} steps, {} params)\n",
            "@c_str_escape(rule.to_str())@", // (rule might have {} in it)
            @rule.num_steps()@, @rule.num_reduce_params()@
        );
        std::cerr << stringformat(
            "all_matched_steps: {}\n", all_matched_steps()
        );
    @}@

    // Now that we know where the frame starts, we can go forward through
    // the stack to find the appropriate slices for our arguments.  We do
    // need to do this back-and-forth thing to get the arguments correct
    // for rules like: 
    //    foo:first foo*:rest -> bar ;
    int arg_start = lr_read_pos;
    int slice_size;
    @for(int stind = 0; stind < rule.num_steps(); ++stind) {-@
        @declare step: rule.nth_step(stind)@
        @if(!step) {-@
            // XXX real error here
            #error Bug: no expression for step @stind@ @rule.to_str()@ @rule.location()@
        @-} else {-@
            @declare el_id: prds.element_index.at(step.gexpr)@
            @declare elname: prds.element_id_name(el_id)@
            slice_size = lr_count_of_@elname@(arg_start, @step.qty.multiple@);
            ReductionParameter<@prds.type_for(step.gexpr)@>
                arg_@stind@(*this, arg_start, slice_size);
            arg_start += slice_size;
            @if(opts.debug) {@
                std::cerr << stringformat(
                    "arg @stind@ is {} @prds.type_for(step.gexpr)@\n",
                    arg_@stind@.count()
                );
            @}@
        @}-@
    @}-@

    @/* this is the call to the reduce code: */@
    @-prds.type_for(rule.product())@ result = @prds.rule_fn(rule) -@ (
        @-for(int pind = 0; pind < num_params; pind++) {-@
            @- pind?",":"" -@ arg_@-rule.reduce_param_step_num(pind)-@
        @-}-@
    );

    @if(prds.post_reduce) {@ {
        @prds.post_reduce.format()@
    } @}@

    @declare result_el_id: prds.element_id_name(rule.product_element()) @
    Product prod(result);
    @if(opts.debug) {-@
        std::cerr << stringformat(
            "reduced to  @result_el_id@ = {}\n", prod
        );
    @}@

    @/* (must come before the pop or the position gets lost) */@
    auto src_pos = arg_0.position();

    @/*
        This is what actually pops the stack. Note we pop after
        the reduce - reduce functions refer to items in the param
        stack itself, and not copies. This also keeps the stack
        intact for dealing with errors/debug.
    */@
    lr_pop_to(lr_read_pos - 1);

    @/* ya know, if it weren't for potential side effects, it's
        possible we could get away with not even calling the
        reduce function in the eject case...
    */@
    bool eject = state_ejects(cur_state, @result_el_id@);
    lr_push(@result_el_id@, eject, src_pos, prod);

    @if(opts.debug) {-@
        std::cerr << stringformat("popped to {}\n", lr_top_index());
    @-}-@

