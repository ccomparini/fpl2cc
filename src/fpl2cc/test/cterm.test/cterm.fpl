#
#  second custom terminal/scanner test.
#
#  The cscan one has gotten too rangy and out of hand.
#
#  This one mainly tests compound terminals.
#

@default_main
@produces std::string
@goal done

@import `builtins`

# hmm what if we can invoke subgrammars as terminals?

@terminal abc ('a' 'b' 'c')
@terminal not_a_then_abc (!'a' 'a' 'b' 'c')
@terminal num_then_k (/[0-9]+/ 'k')
@assertion on_first_line +{
    return reader->line_number() == 1;
}+
@terminal foo_on_first_line (&on_first_line 'foo')

@terminal abc_nl_eof (&abc "\n" &eof)

token+ -> done +{ return token@join("\n"); }+

&foo_on_first_line  -> token +{ return "Foo on first line"; }+
&abc_nl_eof         -> token +{ return "abc on last line"; }+
&abc                -> token;
&num_then_k         -> token +{
    return stringformat("k preceeded by {}", num_then_k.capgroup(0));
}+

&not_a_then_abc      -> token;
'foo'                -> token;
#!&abc          -> token;
