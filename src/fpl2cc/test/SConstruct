
import glob
import os

Import('env')
env = env.Clone()

# fpl_reader has its own (fairly straightforward) test:
env.Program('reader', [ 'reader.cc' ])
env.Command('reader.out', 'reader', '$SOURCE > $TARGET')
env.CompareOut('reader.success', [ 'reader.expect', 'reader.out' ])

env.Append(BUILDERS = {
    'CaptureFplCompile': Builder(
        action = run_and_capture_action(['bin/fpl2cc', '--debug-single-step']),
        suffix = '.result',
        src_suffix = '.fpl'
    )
})

env.CaptureFplCompile('eject_keep_conflict')
env.CompareOut('eject_keep_conflict.success', [ 'eject_keep_conflict.expect', 'eject_keep_conflict.result' ])

#
# fpl language tests:
#
# dependencies:
#   [src language]: [src language].cc
#   [src language].cc: [src language].fpl
#   [src language].test/[test name].result: [src language].test/[test name].[src language] [src language]
#   [src language].test/[test name].success: [src language].test/[test name].expect [src language].test/[test name].result
#
# So each test language is defined by an .fpl file,
# and then each test consists of a source file for that language and
# a .expect file with the corresponding expected .result file.
# This lets us black-box test the fpl compiler for various cases.
#
# references (these were hard to find):
#   scons' idea of a target:
#     https://scons.org/doc/latest/HTML/scons-api/SCons.Node/#
#   action variables:
#     https://scons.org/doc/production/HTML/scons-user.html#app-variables
#


# each language we might be using to test will have an fpl,
# so the set of fpl files determines the set of languages
# we're going to use:
fpls = Glob('*.fpl')

def build_default(lprog):
    return env.Program(lprog, [ lprog + '.cc' ])

def build_json_exe(lprog):
    return env.Program(lprog, [ lprog + '.cc' ], LIBS = 'jest')

# functions for generating the executable for a given language.
# if a given language executable needs particular libraries
# or whatever, put the name of your custom env.Program (or
# equivalent) here.  if not, build_default() will be called,
# which should work for most cases.
build_lang_exe = {
    "json": build_json_exe,
}

# this sets up:
#   [lang]: [lang].cc
#   [lang].cc: [lang].fpl #bin/fpl2cc
# for each language we're testing, and makes the builder for:
#   [x].result: [x].[lang] [lang]
for fpl in fpls:
    langprog, foo = os.path.splitext(fpl.get_abspath())
    language = os.path.basename(langprog)

    # running anything written in the given language requires
    # that language to exist, so we want this dependency:
    env.Append(
        SCANNERS = Scanner(
            function = lambda node, env, path: [ langprog ],
            skeys = [ language ]
        )
    )

    # .. and now create a builder for running the language program:
    env.Append(BUILDERS = {
        'FPLTestLang_' + language: Builder(
            action = run_and_capture_action(langprog),
            suffix = '.result',
            src_suffix = language
        )
    })

    # .. and, the language program is built from <lang>.fpl
    if 'FPL_TEST_DEBUG' in os.environ:
        env.Fpl2cc(language + '.cc', [ langprog + '.fpl' ], FPLOPTS="--debug-single-step")
    else:
        env.Fpl2cc(language + '.cc', [ langprog + '.fpl' ])

    # and it depends on the fpl compiler (which is ultimately
    # what we're testing):
    env.Depends(language + '.cc', [ '#bin/fpl2cc' ])

    compiler = build_lang_exe.get(language, build_default)(langprog)


test_dirs = Glob('*.test')

# sets up:
#   [lang].test/[t].success: [lang].test/[t].expect [lang].test/[t].result
# and the invocation of the generated language program:
#   [x].result: [lang] [x].[lang]
# for each "expect" file.
for test_dir in test_dirs:
    language, foo = os.path.splitext(test_dir.name)

    expecteds = Glob(test_dir.name + '/*.expect')
    for expected in expecteds:
        test_name, foo = os.path.splitext(expected.get_path())
        src_file = test_name + '.' + language
        success_file = test_name + '.success'
        result_file  = test_name + '.result'
        env.Depends(result_file, [ language ])
        getattr(env, 'FPLTestLang_' + language)(result_file, [ src_file ])
        env.CompareOut(success_file, [ expected, result_file ])



