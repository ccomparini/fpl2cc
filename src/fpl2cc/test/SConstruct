import glob
import os
import sys

Import('env')
env = env.Clone()

# Support running fpl-generated languages in debug mode.
# Example usage:
#   FPL_TEST_DEBUG=1 scons build/fpl2cc/test/wcalc.test/prec.success
interactive=False
fpl_options=""
if 'FPL_TEST_DEBUG' in os.environ:
    interactive=True
    fpl_options="--debug-single-step"

env.Append(BUILDERS = {
    'CaptureFplCompile': Builder(
        action = run_and_capture_action(
            fpl_compile_command(), varlist=["FPLOPTS"]
        ),
        emitter = depend_on_fpl2cc(),
	src_suffix = '.fpl',
	suffix = '.cc'
    )
})

# fpl_reader has its own (fairly straightforward) test:
env.Program('reader', [ 'reader.cc' ])
env.Command('reader.out', 'reader', '$SOURCE > $TARGET')
env.CompareOut('reader.success', [ 'reader.expect', 'reader.out' ])

#
# fpl language tests:
#
# dependencies:
#   [src language].test/[src language]: [src language].cc
#   [src language].test/[src language].cc: [src language].fpl
#   [src language].test/[test name].result: [src language].test/[test name].[src language] [src language]
#   [src language].test/[test name].success: [src language].test/[test name].expect [src language].test/[test name].result
#
# So each test language is defined by an .fpl file,
# and then each test consists of a source file for that language and
# a .expect file with the corresponding expected .result file.
# This lets us black-box test the fpl compiler for various cases.
#
# references (these were hard to find):
#   scons' idea of a target:
#     https://scons.org/doc/latest/HTML/scons-api/SCons.Node/#
#   action variables:
#     https://scons.org/doc/production/HTML/scons-user.html#app-variables
#

def build_default(lprog):
    return env.Program(lprog, [ lprog + '.cc' ])

def build_json_exe(lprog):
    return env.Program(lprog, [ lprog + '.cc' ], LIBS = 'jest')

# If a given language executable needs particular libraries
# or whatever, put the name of your custom env.Program (or
# equivalent) here.  If not, build_default() will be called,
# which should work for most cases.
build_lang_exe = {
    "json": build_json_exe,
}

# given a directory name like foo/bar/bat.test,
# infers the language name "bat".
def language_from_directory(directory):
    langbase, ext = os.path.splitext(directory)
    return os.path.basename(langbase)

# this sets up:
#   [lang]: [lang].cc
#   [lang].cc: [lang].fpl #bin/fpl2cc
# for the language whose specification corresponds to the
# directory passed, and makes the builder for:
#   [x].result: [x].[lang] [lang]
def make_language_rules(env, directory):
    language = language_from_directory(directory)
    langbase = directory + '/' + language

    # (langprog = the name of the language executable)
    langprog = langbase

    # running anything written in the given language requires
    # that language to exist, so we want this dependency:
    env.Append(
        SCANNERS = Scanner(
            function = lambda node, env, path: [ langprog ],
            skeys = [ language ]
        )
    )

    # .. and now create a builder for running the language program:
    env.Append(BUILDERS = {
        'FPLTestLang_' + language: Builder(
            action = run_and_capture_action([langprog, "$SOURCE"]),
            emitter = depend_on(langprog),
            src_suffix = language,
            suffix = '.result'
        )
    })

    # .. and, the language program is built from <lang>.fpl
    langsource = langbase + '.fpl'
    langcc     = langbase + '.cc'
    capfile    = langbase + '.fpl_result'
    #print(f"fpl options on {langsource}: {fpl_options}", file=sys.stderr)
    env.CaptureFplCompile(
        [ langcc, capfile ],  [ langsource ],
        FPLOPTS=fpl_options, CAPFILE=capfile
    )

    compiler = build_lang_exe.get(langbase, build_default)(langprog)


test_dirs = Glob('*.test')

# sets up:
#   [lang].test/[t].success: [lang].test/[t].expect [lang].test/[t].result
# and the invocation of the generated language program:
#   [x].result: [lang] [x].[lang]
# for each "expect" file.
for test_dir in test_dirs:
    make_language_rules(env, test_dir.get_abspath())

    language, foo = os.path.splitext(test_dir.name)

    # we might expect certain output from the fpl compile
    # itself (for example, to test warnings emitted by
    # fpl2cc):
    fpl_expecteds = Glob(test_dir.name + '/*.fpl_expect')
    for expected in fpl_expecteds:
        test_name, foo = os.path.splitext(expected.get_path())
        env.CompareOut(
            test_name + '.success', [ expected, test_name + '.fpl_result' ]
        )


    expecteds = Glob(test_dir.name + '/*.expect')
    for expected in expecteds:
        test_name, foo = os.path.splitext(expected.get_path())
        src_file = test_name + '.' + language
        success_file = test_name + '.success'
        result_file  = test_name + '.result'
        # call the test lang compile rule for the soure:
        test_lang_builder = getattr(env, 'FPLTestLang_' + language)
        test_lang_builder(
            result_file, [ src_file ],
            INTERACTIVE=interactive,
            QUIET=True  # avoid spam when testing errors
        )
        env.CompareOut(success_file, [ expected, result_file ])



