
@produces double
@goal statements
@comment_style c

(expression ';'^)*:statement -> statements ;

# Primary expressions are in their own fpl not because it's
# good structure (it's not), but to test if subexpressions
# in subfpl dtrt.  (At one point, there was a bug involving
# name collisions among imported subexpressions)
`expression` -> expression ;

# functions:
'sum' argument_list:args -> sum ;
sum -> expression ;

# this is an argument list in the c style (though it's inherently
# variadic), where commas are required before any but the first
# element:
'('^ (expression (','^ expression)*)?:args ')'^ -> argument_list ;

#'['^ (number (','^ number)*)? ']'^ -> number_list;

####### implementations:
+{
#include<math.h>
}+

+number(digits) +{ return std::stod(digits); }+

+natural_log_base +{ return M_E; }+
+pi               +{ return M_PI; }+


+add(lhs, rhs) +{
    return lhs + rhs;
}+

+sub(lhs, rhs) +{
    return lhs - rhs;
}+

+mult(terms) +{
    double result = terms[0];
    for(int ind = 1; ind < terms@count(); ind++) {
        result *= terms[ind];
    }
    return result;
}+

+div(numerator, denominator) +{
    return numerator/denominator;
}+

@type_for argument_list std::vector<double>
+argument_list(args) +{
    std::vector<double> out;
    out.reserve(args@count());
    args@foreach([&out](const Product &el)->void {
        out.push_back(el.val());
    });
    return out;
}+

#+number_list(number) +{
#    // std::cerr << stringformat("YAY we got a number list:\n{}\n", number@join(", "));
#    return number@count(); // XXX just to return something.
#}+

+sum(args) +{
    double sum = 0;
    for(auto el : args) {
        sum += el;
    }
    return sum;
}+

+statements(statement) +{
    statement@foreach([](const Product &el)->void {
       std::cout << stringformat("{}\n", el.val());
    });
    return statement@count();
}+

@default_main

