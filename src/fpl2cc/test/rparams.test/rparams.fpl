@goal shopping_list

#
# test parameters for:
#   o parameter melding (multiple same-name parameters)
#   - common/deep subexpressions
#   - complex subexpressions 

'ðŸ‡' -> grapes;
'ðŸŠ' -> tangerine;
'ðŸ‹' -> lemon;
'ðŸŒ' -> banana;
'ðŸŽ' -> apple;

grapes    -> fruit;
tangerine -> fruit;
lemon     -> fruit;
banana    -> fruit;
apple     -> fruit;

# Common subexpression w/ melding and bubble-up:
# The reduce action should expect one "fruit" parameter
#'('^ fruit (','^ fruit)* ')'^ -> shopping_list; ain't right
#'('^ (fruit (','^ fruit)*)? ')'^ -> shopping_list;
'('^ (fruit (','^ fruit)*) ')'^ -> fruit_list;

fruit_list -> shopping_list;

######### reduce actions/implementations

@type_for grapes std::string
@type_for tangerine std::string
@type_for lemon std::string
@type_for banana std::string
@type_for apple std::string
# wtb not the above^^.  either inherit "up" or generate types which work.

@type_for fruit std::string
@type_for shopping_list std::list<std::string>
@type_for fruit_list std::list<std::string>
@default_main
@post_parse +{
    for(auto item : result) {
        std::cerr << stringformat("{}\n", item);
    }
}+

+fruit_list(fruit) +{
    std::list<std::string> list;
    // OMG we need a reasonable grammar for this
    fruit@foreach([&list](const Product &fr)->void {
        //list.push_back(stringformat("{}", fr));
        list.push_back(fr.var_str());
    });
    return list;
}+

