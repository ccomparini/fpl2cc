
+{
    #include <list>
    #include <map>
    #include <unistd.h>
    #include <variant>
    #include <vector>
    #include "util/to_hex.h" // debugging

    static bool is_big_endian()
    {
        union {
            uint32_t num;
            char     byte[4];
        } bint;
        bint.num = 0x04030201;
    
        return bint.byte[0] == 0x04; 
    }
}+

@produces bkv_item

+{
    enum bkv_type {
        bkv_t_null = 0x0 << 29,
        bkv_t_bool = 0x1 << 29,
        bkv_t_int  = 0x2 << 29,
        bkv_t_num  = 0x3 << 29,
        bkv_t_str  = 0x4 << 29,
        bkv_t_arr  = 0x5 << 29,
        bkv_t_obj  = 0x6 << 29,
    };

    struct bkv_item;
    using bkv_int    = long long;
    using bkv_num    = double;
    using bkv_array  = std::vector<bkv_item>;
    using bkv_object = std::map<std::string, bkv_item>;
    struct bkv_item {
        bkv_type type;

        using JSONVal = std::variant<
            bool,
            bkv_int,
            bkv_num,
            std::string,
            bkv_array,
            bkv_object
        >;
        JSONVal value;

        bkv_item()                     : type(bkv_t_null), value(false) { }
        bkv_item(bool v)               : type(bkv_t_bool), value(v)     { }
        bkv_item(char d)               : type(bkv_t_num),  value(d)     { }
        bkv_item(int d)                : type(bkv_t_num),  value(d)     { }
        bkv_item(long d)               : type(bkv_t_num),  value(d)     { }
        bkv_item(long long d)          : type(bkv_t_num),  value(d)     { }
        bkv_item(double d)             : type(bkv_t_num),  value(d)     { }
        bkv_item(const std::string &s) : type(bkv_t_str),  value(s)     { }
        bkv_item(const bkv_array &in)  : type(bkv_t_arr),  value(in)    { }
        bkv_item(const bkv_object &in) : type(bkv_t_obj),  value(in)    { }

        std::string to_str() const {
            switch(type) {
                // everything gets its own line to make diffing easier
                case bkv_t_null:
                     return "<null>\n";
                case bkv_t_bool:
                     return std::get<bool>(value)?"<true>\n":"<false>\n";
                case bkv_t_int:
                      return stringformat("{}\n", std::get<bkv_int>(value));
                case bkv_t_num:
                      return stringformat("{}\n", std::get<bkv_num>(value));
                case bkv_t_str:
                      return stringformat("'{}'\n", std::get<std::string>(value));
                case bkv_t_arr:
                      return stringformat("{}\n", std::get<bkv_array>(value));
                case bkv_t_obj:
                      return stringformat("{}\n", std::get<bkv_object>(value));
            }

            return stringformat("Unknown type {} for {} in to_str", type);
        }
    };

    // key/value pair for within an object:
    struct bkv_obj_member {
        std::string key;
        bkv_item    val;
        bkv_obj_member(const std::string &k, const bkv_item &v) :
            key(k),
            val(v) {
        }
    };

    std::string to_string(const bkv_array &in, int indent = 0) {
        std::string out = stringformat("{} items: [\n", in.size());
        for(auto item : in) {
            out += item.to_str();
        }
        return out + "]\n";
    }

    std::string to_string(const bkv_object &in, int indent = 0) {
        std::string out = stringformat("{} items: (\n", in.size());
        for (auto const &kv : in) {
            out += stringformat("'{}' => {}", kv.first, kv.second);
        }
        return out + ")\n";
    }
}+

@main +{
// XXX see if we can default_main this
    if(argc < 2) {
        // use jerror?  read stdin?
        fpl_reader::default_fail("Please provide a source file name.\n");
    }
    fpl_reader_p inp = std::make_shared<fpl_reader>(argv[1]);
    json_parser parser(inp);
    auto result = parser.parse();
    return parser.error_count()?-1:0;
}+

@post_parse +{
    std::cout << stringformat("======\n{}\n======\n", result);
}+

@grammar json

@type_for boolean bool
+boolean(true_val)  +{ return true;  }+
+boolean(false_val) +{ return false; }+

@type_for value bkv_item
+value(null_val)    +{ return bkv_item(); }+

@type_for object bkv_object
@type_for member bkv_obj_member
+object(members) +{
    bkv_object out;
    members@foreach([&out](const Product &memi)->void {
        // this is.. super ugly
        const bkv_obj_member &mem = std::get<bkv_obj_member>(memi.var());
        out[mem.key] = mem.val;
    });
    return out;
}+

@type_for array bkv_array
+array(elements) +{
    bkv_array out;
    // WTB automatic way to do this.  construct from iterators?
    elements@foreach([&out](const Product &item)->void {
        out.push_back(item.val());
    });
    return out;
}+

@type_for string std::string
+string(src) +{
    // without taking the capgroup, it'll include the enclosing
    // quotes.  we probably want a way to do this automatically..
    return src.capgroup(0);
}+

@type_for float_val bkv_num
+number(float_val) +{
    return bkv_item(std::stod(float_val));
}+

@type_for integer bkv_int
+number(integer) +{
    return bkv_item(std::stol(integer));
}+

