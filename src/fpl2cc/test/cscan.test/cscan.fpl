#
# Test all kinds of scanner/terminal match and inverted match.
#
# (Formerly, this tested "custom" scanners.)
#

+{
#include<iostream>
#include<list>
#include<map>
}+

@produces std::string

@internal +{
    std::map<std::string, std::string> symtab;
}+

# end-of-file (or input) assertion:
@scanner eof +{
    return reader->eof();
}+

# "scans" and expands a variable
@scanner variable +{
    auto start = reader->current_position();
    auto match = reader->read_re("[a-zA-Z0-9_-]+");
    if(!match.empty()) {
        // ... we read something which might be a variable..
        auto found = symtab.find(match.str());
        if(found != symtab.end()) {
            // ... viola, it is one.  Return its value:
            return Terminal(found->second);
        }
    }
    reader->go_to(start); // no match; put the scan back
    return Terminal();
    
}+

# XXX custom scanner with args here.. like, string scanning?

stuff* the_end -> done +{
    std::cout << stuff@join("\n") + "\n" + the_end + "\n";
    return "totally done";
}+

block -> stuff;

&eof -> the_end +{
    return "ding!";
}+

"\xF0\x9F\x98\x81" -> stuff +{ return "yay 😁"; }+

"\x23" -> stuff +{ return "hash"; }+ # one byte '#'
'\x23' -> stuff;                     # 4 chars: literal \x23

'\b'   -> stuff +{ return "backslash b"; }+ # 2 chars: backslash, then b
"\b"   -> stuff +{ return "I take that last byte back"; }+
"\e\b" -> stuff +{ return "no escape!"; }+ # 2 bytes: ESC and 

"\U3069":to   -> stuff +{ return "don't stub your " + to.to_str(); }+
#"\U1F408":cat -> stuff +{ return cat + " says meow"; }+  # XXX this should work! gar..
#"\U0001F408":cat -> stuff +{ return cat + " says meow"; }+ # XXX this should work too! w/out to_str()
"\u0001F408":cat -> stuff +{ return cat.to_str() + " says meow"; }+

#"\u1F1FA\u1F1F8" -> us_flag... check if this works..

"\"" -> literal_double_quote +{ return "double quote"; }+ #"
literal_double_quote -> stuff;
# yay, this correctly causes conflict warning. (integrate with tests?)
#'"'  -> also_double_quote +{ return "also double quote; cant get here"; }+
#also_double_quote -> stuff;

# this is identical to 'U'
"\U" -> stuff +{ return "you? no, U!"; }+

# Let's say (for test purposes) that blocks are enclosed
# in U+27E6 and U+27E7 Mathemetical Square Brackets
# ("⟦" and "⟧"). (
# There's a little bit of weird interplay with how spaces
# are handled here.  the default separator code will eat
# any space after the start_of_block, but then the guts
# ends up including the space all the way up to the
# end of block.  it's... correct?  yes. counterintuitive
# though.
"⟦" !"⟧":guts "⟧" -> block +{
    return stringformat("block: [{}]", guts);
}+

# also for test purposes, other blocks can be specified,
# let's say, like this:
@scanner block_2_start /([+-])\{/
@scanner block_2_end   /\}([+-])/
&block_2_start !&block_2_end:guts &block_2_end -> block +{
    auto start = block_2_start.capgroup(0);
    auto end   = block_2_end.capgroup(0);
    std::string description = "confusing";
    if(start != end) {
        description = "mixed";
    } else if(start == "-") {
        description = "minus";
    } else if(start == "+") {
        description = "plus";
    }
    return stringformat("{} block: [{}]\n", description, guts);
}+

# assign a variable for later expansion:
/[a-zA-Z0-9_-]+/:name '='^ string -> assignment +{
    symtab[name] = string;
    return "";
}+
assignment -> stuff;


# strings are double quoted; quotes can be escaped with
# a backslash.  really, this is to test inverting revex match.
'"'^ !/"|(:?\")/:guts '"'^ -> string;

&variable  -> stuff;

/.+/:anything_else -> stuff +{
    return stringformat("other stuff: '{}'\n", anything_else);
}+

@default_main
