#
# Custom scanner test
#


# TODO:
#   - check that source positions/lengths/whatever for custom
#     scanners make sense.  if they don't, change how this whole
#     thing works.
#   - document how it's supposed to scan, which is that (at present)
#     it just calls parser/reader methods..
#

@produces std::string

+{

const utf8_buffer LeftDoubleBracket((utf8_byte *)"⟦", 3);
const utf8_buffer RightDoubleBracket((utf8_byte *)"⟧", 3);

}+

# end-of-file (or input) assertion:
@scanner eof +{
    return reader->eof();
}+

# let's say (for test purposes) that blocks are enclosed
# in U+27E6 and U+27E7 Mathemetical Square Brackets
# ("⟦" and "⟧").
@scanner start_of_block +{
    if(reader->read_bytes_equalling(LeftDoubleBracket)) {
        return std::string("⟦");
    }
    return false; // no match
}+

@scanner not_end_of_block +{
    size_t start = reader->current_position();

    while(reader->read_byte_not_equalling(RightDoubleBracket[0])) {
        // we may have found an end bracket:
        if(
            reader->peek(0) == RightDoubleBracket[0] &&
            reader->peek(1) == RightDoubleBracket[1] &&
            reader->peek(2) == RightDoubleBracket[2]
        ) {
            return reader->read_range(start, reader->current_position());
        } // else false alarm but keep looking
    }
    return false;
}+

@scanner end_of_block +{
    if(reader->read_bytes_equalling(RightDoubleBracket)) {
        return "⟧";
    }
    return false;
}+

stuff* the_end -> done +{
    std::cout << stuff@join("\n") + "\n" + the_end + "\n";
    return "totally done";
}+

block -> stuff;

&eof -> the_end +{
    return "ding!";
}+

# there's a little bit of weird interplay with how spaces
# are handled here.  the default separator code will eat
# any space after the start_of_block, but then the guts
# ends up including the space all the way up to the
# end of block.  it's... correct?  the custom scanners
# are working, anyway, and that's the point of this.
&start_of_block guts &end_of_block -> block +{
    return stringformat("block: [{}]", guts);
}+

&not_end_of_block:huh_need_this -> guts +{
//std::cerr << stringformat("scanned guts! ⎧\n{}\n⎩", huh_need_this@join("\n⎪"));
    //return not_end_of_block; ohhhh.... name....e.e..e.e.
    return huh_need_this;
}+

#/.+/ -> stuff;

+{
#include<iostream>
#include<list>
}+

@default_main
