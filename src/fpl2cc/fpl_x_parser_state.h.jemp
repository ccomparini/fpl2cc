@parameter: const productions &prds @
@parameter: const productions::lr_set &state @
@parameter: const fpl_options &opts @
@declare sfn: prds.state_fn(state) @
@realign: #line {} "{}" @

//
@state.to_str(&prds, "// ")-@
//
void @sfn@() {
    @/* skip any separator before doing anything else, saving the
        number of bytes it took up.  we need to do this before
        trying to match terminals (of course), and we use the
        number of bytes eaten for lack-of-separator assertions.
    */@
    eat_separator();

    @if(opts.debug) {@
        std::cerr << stringformat(
            "======= @sfn@ =======\n"
            "{::c}\n{}\n--\n",
            state_string(&@prds.fq_member_name(sfn)@), *this
        );
        debug_pause();
    @}@

    @for(auto trans : state.transitions(prds)) {-@
        @declare right_of_dot: trans.right_of_dot@
        @declare type: right_of_dot.type_str()@
        @declare el_id: prds.element_id_name(right_of_dot)@
        @/* call here is to shift_nonterm_xxx, shift_term_xxx, etc,
            which will call lr_shift or such as approriate.
            see src/fpl2cc/fpl_x_parser_shift_* for details. */@
        if(shift_@type@_@el_id@(@trans.eject@)) {
            @if(trans.what == productions::lr_transition::STATE) {@
                @declare next_state: prds.state_fn(trans.which, true)@
                set_state(&@next_state@);
                @if(opts.debug) {@
                    std::cerr << "   next state:  @trans.which@\n";
                @}@
            @} else if(trans.what == productions::lr_transition::REDUCTION) {@
                @declare rule: prds.rules[trans.which]@
                @if(opts.debug) {-@
                    std::cerr << "    @sfn@ is going to reduce by rule "
                                 "@c_str_escape(rule.to_str())@\n";
                @-}-@
                @#fpl_x_parser_reduce_call(prds, rule, opts)@
            @} else {@
                #error unknown transition type for @trans@
            @}@
        } else
    @-}-@
    {
        // else we hit something we don't specifically handle here.
        // It could be an error, or a successful partial or full parse.
        // Callers will decide, but for now we're done parsing:
        @if(opts.debug) {-@
            std::cerr <<  "    terminating in @sfn@\n";
        @}@
        terminate();
    }
 
    @if(opts.debug) {-@
        std::cerr << "======= @sfn@ end =======\n";
    @}@
}
