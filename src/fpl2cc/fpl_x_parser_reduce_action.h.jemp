@parameter: const productions &prds@
@parameter: const production_rule &rule@
@declare return_type: prds.type_for(rule.product())@
@declare num_params: rule.num_reduce_params()@
@realign: #line {} "{}" @

@return_type@ @rule.rule_fn()@(
    @-for(int pind = 0; pind < num_params; pind++) {-@
        @declare step: rule.reduce_param(pind) @
        @- pind?", ":"" -@ StackSliceSpecialization<@prds.type_for(step.gexpr)@> @step.variable_name()-@
    @-}-@
) {
    // @rule.to_str()@
    @#fpl_x_parser_reduce_action_meta(rule)@

    // @rule.to_str()@
    @if(code_block rule_code = rule.reduce_code()) {-@
        @/* fpl-author-supplied rule code: */@
        @rule_code.format(false)@
    @} else {@
        @/*default is to construct/cast from all non-ejected steps. */@
        #line 1 "@rule.location()@ (default action for @c_str_escape(rule.to_str())@)"
        // @source.filename()@:@source.line_number()@
        return @return_type@(
            @-for(int parmi = 0; parmi < rule.num_reduce_params(); parmi++) {-@
                @declare param: rule.reduce_param(parmi)@
                @declare vname: param.variable_name()@
                @-if(param.is_optional()){-@
                    #line @rule.line_number()@ "@rule.filename()@"
                    #error "no default for optional '@vname@' in rule @rule.to_str()@"
                @-} else if(!param.is_single()){-@
                    #line @rule.line_number()@ "@rule.filename()@"
                    #error "no default for multiple '@vname@' in rule @rule.to_str()@"
                @-} else {-@
                    @-if(parmi > 0){@,@}-@ @/* argument separator */@
                    @-if(param.is_terminal()) {-@
                        @/* by default, pass terminals a strings: */@
                        @-vname@.val().to_str()
                    @-} else {-@
                        @-vname@.val()
                    @-}-@
                @-}-@
            @-}-@
        );
    @}-@
}

